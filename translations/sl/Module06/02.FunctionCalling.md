<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-09-18T23:29:02+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "sl"
}
-->
# Section02 : Klic funkcij v majhnih jezikovnih modelih (SLM)

## Kazalo
1. [Kaj je klic funkcij?](../../../Module06)
2. [Kako deluje klic funkcij](../../../Module06)
3. [Scenariji uporabe](../../../Module06)
4. [Nastavitev klica funkcij s Phi-4-mini in Ollama](../../../Module06)
5. [Delo s klicem funkcij Qwen3](../../../Module06)
6. [Lokalna integracija Foundry](../../../Module06)
7. [Najboljše prakse in odpravljanje težav](../../../Module06)
8. [Napredni primeri](../../../Module06)

## Kaj je klic funkcij?

Klic funkcij je zmogljiva funkcionalnost, ki omogoča majhnim jezikovnim modelom (SLM), da se povežejo z zunanjimi orodji, API-ji in storitvami. Namesto da bi bili omejeni na svoje učne podatke, lahko SLM-ji zdaj:

- **Povezujejo se z zunanjimi API-ji** (vremenske storitve, baze podatkov, iskalniki)
- **Izvajajo specifične funkcije** glede na zahteve uporabnika
- **Pridobivajo informacije v realnem času** iz različnih virov
- **Izvajajo računske naloge** prek specializiranih orodij
- **Verižijo več operacij** za kompleksne delovne tokove

Ta funkcionalnost spremeni SLM-je iz statičnih generatorjev besedila v dinamične AI agente, ki lahko izvajajo naloge v resničnem svetu.

## Kako deluje klic funkcij

Proces klica funkcij sledi sistematičnemu poteku dela:

### 1. Integracija orodij
- **Zunanja orodja**: SLM-ji se lahko povežejo z vremenskimi API-ji, bazami podatkov, spletnimi storitvami in drugimi zunanjimi sistemi
- **Definicije funkcij**: Vsako orodje je definirano s specifičnimi parametri, formati vhodov/izhodov in opisi
- **Združljivost API-jev**: Orodja so integrirana prek standardiziranih vmesnikov (REST API-ji, SDK-ji itd.)

### 2. Definicija funkcij
Funkcije so definirane s tremi ključnimi komponentami:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. Zaznavanje namena
- **Obdelava naravnega jezika**: SLM analizira uporabniški vnos, da razume namen
- **Ujemanje funkcij**: Določi, katere funkcije so potrebne za izpolnitev zahteve
- **Izvleček parametrov**: Identificira in izvleče potrebne parametre iz uporabnikovega sporočila

### 4. Generiranje JSON izhoda
SLM ustvari strukturiran JSON, ki vsebuje:
- Ime funkcije za klic
- Potrebne parametre z ustreznimi vrednostmi
- Kontekst izvajanja in metapodatke

### 5. Zunanje izvajanje
- **Validacija parametrov**: Preveri, ali so vsi potrebni parametri prisotni in pravilno oblikovani
- **Izvajanje funkcije**: Aplikacija izvede določeno funkcijo z danimi parametri
- **Obravnava napak**: Upravljanje z napakami, časovnimi omejitvami in neveljavnimi odgovori

### 6. Integracija odgovora
- **Obdelava rezultatov**: Izhod funkcije se vrne SLM-ju
- **Integracija konteksta**: SLM vključi rezultate v svoj odgovor
- **Komunikacija z uporabnikom**: Predstavi informacije v naravni, pogovorni obliki

## Scenariji uporabe

### Pridobivanje podatkov
Pretvorba naravnih jezikovnih poizvedb v strukturirane API klice:
- **"Pokaži moje nedavne naročila"** → Poizvedba baze podatkov z ID-jem uporabnika in filtri datuma
- **"Kakšno je vreme v Tokiu?"** → Klic vremenskega API-ja z lokacijskim parametrom
- **"Najdi e-pošto od Johna prejšnji teden"** → Poizvedba e-poštne storitve z pošiljateljem in filtri datuma

### Izvajanje operacij
Pretvorba uporabniških zahtev v specifične klice funkcij:
- **"Načrtuj sestanek za jutri ob 14. uri"** → Integracija koledarskega API-ja
- **"Pošlji sporočilo ekipi"** → API komunikacijske platforme
- **"Ustvari varnostno kopijo mojih datotek"** → Operacija datotečnega sistema

### Računske naloge
Obravnava kompleksnih matematičnih ali logičnih operacij:
- **"Izračunaj obresti na $10,000 pri 5% za 10 let"** → Funkcija finančnega izračuna
- **"Analiziraj ta nabor podatkov za trende"** → Orodja za statistično analizo
- **"Optimiziraj to pot za dostavo"** → Algoritmi za optimizacijo poti

### Delovni tokovi obdelave podatkov
Verižni klici več funkcij za kompleksne operacije:
1. **Pridobivanje podatkov** iz več virov
2. **Razčlenjevanje in validacija** informacij
3. **Pretvorba** podatkov v zahtevano obliko
4. **Shranjevanje rezultatov** v ustrezne sisteme
5. **Generiranje poročil** ali vizualizacij

### Integracija UI/UX
Omogočanje dinamičnih posodobitev vmesnika:
- **"Pokaži podatke o prodaji na nadzorni plošči"** → Generiranje in prikaz grafikonov
- **"Posodobi zemljevid z novimi lokacijami"** → Integracija geolokacijskih podatkov
- **"Osveži prikaz zaloge"** → Sinhronizacija podatkov v realnem času

## Nastavitev klica funkcij s Phi-4-mini in Ollama

Microsoftov Phi-4-mini podpira tako enojne kot vzporedne klice funkcij prek Ollama. Tukaj je opis, kako ga nastaviti:

### Predpogoji
- Ollama različica 0.5.13 ali višja
- Model Phi-4-mini (priporočeno: `phi4-mini:3.8b-fp16`)

### Koraki namestitve

#### 1. Namestitev in zagon Phi-4-mini
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. Ustvarjanje predloge ModelFile
Zaradi trenutnih omejitev privzetih predlog Ollama morate ustvariti prilagojen ModelFile s sledečo predlogo:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. Ustvarjanje prilagojenega modela
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### Primer enojnega klica funkcij

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### Primer vzporednega klica funkcij

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## Delo s klicem funkcij Qwen3

Qwen3 ponuja napredne zmogljivosti klica funkcij z odlično zmogljivostjo in prilagodljivostjo. Tukaj je opis, kako ga implementirati:

### Uporaba okvirja Qwen-Agent

Qwen-Agent zagotavlja visokorazredni okvir, ki poenostavi implementacijo klica funkcij:

#### Namestitev
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### Osnovna nastavitev

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### Implementacija prilagojenih funkcij

Prav tako lahko definirate prilagojene funkcije za Qwen3:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### Napredne funkcije Qwen3

#### Nadzor načina razmišljanja
Qwen3 podpira dinamično preklapljanje med načinom razmišljanja in nerazmišljanja:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### Večstopenjski klic funkcij
Qwen3 odlično obvlada verižne klice več funkcij:

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## Lokalna integracija Foundry

Microsoftov Foundry Local zagotavlja API, združljiv z OpenAI, za lokalno izvajanje modelov z izboljšano zasebnostjo in zmogljivostjo.

### Nastavitev in namestitev

#### Windows
Prenesite namestitveni program s [strani za izdaje Foundry Local](https://github.com/microsoft/Foundry-Local/releases) in sledite navodilom za namestitev.

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### Osnovna uporaba

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### Napredne funkcije Foundry Local

#### Upravljanje modelov
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### Optimizacija zmogljivosti
Foundry Local samodejno izbere najboljšo različico modela za vašo strojno opremo:
- **CUDA GPU**: Prenese modele, optimizirane za GPU
- **Qualcomm NPU**: Uporablja različice, pospešene z NPU
- **Samo CPU**: Izbere modele, optimizirane za CPU

## Najboljše prakse in odpravljanje težav

### Najboljše prakse pri definiciji funkcij

#### 1. Jasna in opisna imena
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. Celovite definicije parametrov
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. Validacija vhodov in obravnava napak
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### Pogoste težave in rešitve

#### Težava 1: Funkcija ni bila poklicana
**Simptomi**: Model odgovori z besedilom namesto da bi poklical funkcijo

**Rešitve**:
1. **Preverite opis funkcije**: Poskrbite, da jasno ustreza namenu uporabnika
2. **Preverite definicije parametrov**: Poskrbite, da so vsi potrebni parametri pravilno definirani
3. **Preglejte sistemski poziv**: Vključite jasna navodila o tem, kdaj uporabiti funkcije
4. **Testirajte z eksplicitnimi zahtevami**: Poskusite "Prosim, uporabi vremensko funkcijo za pridobitev podatkov za London"

#### Težava 2: Napačni parametri
**Simptomi**: Funkcija je poklicana z napačnimi ali manjkajočimi parametri

**Rešitve**:
1. **Dodajte primere parametrov**: Vključite vzorčne vrednosti v opise parametrov
2. **Uporabite omejitve enum**: Omejite vrednosti parametrov na specifične možnosti, kadar je to mogoče
3. **Implementirajte nadomestne vrednosti**: Zagotovite smiselne privzete vrednosti za neobvezne parametre

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### Težava 3: Napake pri vzporednem klicu funkcij
**Simptomi**: Izvede se le ena funkcija, ko bi morale biti izvedene več

**Rešitve**:
1. **Preverite podporo modela**: Poskrbite, da vaš model podpira vzporedni klic funkcij
2. **Posodobite sistemski poziv**: Vključite "nekatera orodja" ali "več orodij" v sistemsko sporočilo
3. **Uporabite ustrezne različice modela**: Priporočeno Phi-4-mini:3.8b-fp16 za Ollama

#### Težava 4: Težave s predlogo pri Ollama
**Simptomi**: Klic funkcij ne deluje s privzeto nastavitvijo Ollama

**Rešitve**:
1. **Uporabite prilagojen ModelFile**: Uporabite popravljeno predlogo, ki je navedena v tem priročniku
2. **Posodobite Ollama**: Poskrbite, da uporabljate različico 0.5.13 ali višjo
3. **Preverite kvantizacijo modela**: Višje ravni kvantizacije (Q8_0, fp16) delujejo bolje kot močno kvantizirane različice

### Optimizacija zmogljivosti

#### 1. Učinkovita zasnova funkcij
- **Osredotočite funkcije**: Vsaka funkcija naj ima en sam, jasen namen
- **Minimizirajte zunanje odvisnosti**: Zmanjšajte klice API-jev in omrežne zahteve, kjer je to mogoče
- **Predpomnite rezultate**: Shranite pogosto zahtevane podatke za izboljšanje odzivnih časov

#### 2. Paketna obdelava in asinhrone operacije
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. Upravljanje virov
- **Ponovno uporabo povezav**: Ponovno uporabite povezave do baz podatkov in API-jev
- **Omejevanje hitrosti**: Implementirajte ustrezno omejevanje hitrosti za zunanje API-je
- **Obravnava časovnih omejitev**: Nastavite razumne časovne omejitve za vse zunanje klice

## Napredni primeri

### Sistem za sodelovanje več agentov

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### Sistem za dinamično izbiro orodij

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```
Gotovo! Prosim, prilepite vsebino Markdown datoteke, ki jo želite prevesti, in takoj bom začel.
"""Izvedi funkcijo z obsežnim upravljanjem napak in beleženjem"""
start_time = datetime.now()

try:
    # Preveri, ali funkcija obstaja
    if function_name not in self.functions:
        return FunctionResult(
            success=False,
            error=f"Funkcija '{function_name}' ni bila najdena",
            timestamp=start_time
        )
    
    # Preveri omejitve hitrosti
    if not self._check_rate_limit(function_name):
        return FunctionResult(
            success=False,
            error=f"Prekoračena omejitev hitrosti za funkcijo '{function_name}'",
            timestamp=start_time
        )
    
    # Preveri parametre
    validation_result = self._validate_parameters(function_name, parameters)
    if not validation_result.success:
        return validation_result
    
    # Izvedi funkcijo
    func_info = self.functions[function_name]
    handler = func_info['handler']
    
    if asyncio.iscoroutinefunction(handler):
        result_data = await handler(**parameters)
    else:
        result_data = handler(**parameters)
    
    execution_time = (datetime.now() - start_time).total_seconds()
    
    result = FunctionResult(
        success=True,
        data=result_data,
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Zabeleži uspešno izvedbo
    self._log_function_call(function_name, parameters, result)
    
    return result
    
except Exception as e:
    execution_time = (datetime.now() - start_time).total_seconds()
    result = FunctionResult(
        success=False,
        error=str(e),
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Zabeleži neuspešno izvedbo
    self._log_function_call(function_name, parameters, result)
    
    return result

def _check_rate_limit(self, function_name: str) -> bool:
    """Preveri, ali je klic funkcije znotraj omejitev hitrosti"""
    func_info = self.functions[function_name]
    now = datetime.now()
    
    # Ponastavi števec, če je minila minuta
    if (now - func_info['last_reset']).seconds >= 60:
        func_info['call_count'] = 0
        func_info['last_reset'] = now
    
    # Preveri, ali je znotraj omejitve
    if func_info['call_count'] >= func_info['rate_limit']:
        return False
    
    func_info['call_count'] += 1
    return True

def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
    """Preveri parametre funkcije"""
    func_params = self.functions[function_name]['parameters']
    
    # Preveri obvezne parametre
    for param_name, param_info in func_params.items():
        if param_info.get('required', False) and param_name not in parameters:
            return FunctionResult(
                success=False,
                error=f"Manjka obvezen parameter: {param_name}"
            )
    
    # Preveri tipe parametrov in omejitve
    for param_name, value in parameters.items():
        if param_name in func_params:
            param_info = func_params[param_name]
            
            # Preverjanje tipa
            expected_type = param_info.get('type')
            if expected_type == 'string' and not isinstance(value, str):
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' mora biti niz"
                )
            elif expected_type == 'number' and not isinstance(value, (int, float)):
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' mora biti število"
                )
            elif expected_type == 'boolean' and not isinstance(value, bool):
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' mora biti logična vrednost"
                )
            
            # Preverjanje vrednosti v seznamu
            if 'enum' in param_info and value not in param_info['enum']:
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' mora biti eden od: {param_info['enum']}"
                )
    
    return FunctionResult(success=True)

def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):
    """Zabeleži klic funkcije za namene revizije"""
    log_entry = {
        'timestamp': result.timestamp.isoformat(),
        'function_name': function_name,
        'parameters': parameters,
        'success': result.success,
        'execution_time': result.execution_time,
        'error': result.error if not result.success else None
    }
    
    self.audit_log.append(log_entry)
    
    # Po potrebi zapiši v zunanji sistem beleženja
    if self.config.get('enable_external_logging', False):
        self._write_to_external_log(log_entry)

def _write_to_external_log(self, log_entry: Dict):
    """Zapiši zapis v zunanji sistem beleženja"""
    # Implementacija je odvisna od vaše infrastrukture za beleženje
    # npr. pošlji v ELK stack, CloudWatch itd.
    pass

# Implementacije poslovnih funkcij
async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
    """Pridobi informacije o stranki iz CRM sistema"""
    # Simuliraj klic baze podatkov/API-ja
    await asyncio.sleep(0.1)  # Simuliraj omrežno zakasnitev
    
    customer_data = {
        'customer_id': customer_id,
        'name': 'John Doe',
        'email': 'john.doe@example.com',
        'phone': '+1-555-0123',
        'status': 'active',
        'tier': 'premium'
    }
    
    if include_history:
        customer_data['purchase_history'] = [
            {'date': '2024-01-15', 'product': 'Product A', 'amount': 1500},
            {'date': '2024-03-22', 'product': 'Product B', 'amount': 2300}
        ]
    
    return customer_data

async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                  estimated_value: float, expected_close_date: str) -> Dict:
    """Ustvari novo prodajno priložnost"""
    # Simuliraj klic CRM API-ja
    await asyncio.sleep(0.2)
    
    opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'opportunity_id': opportunity_id,
        'customer_id': customer_id,
        'product_id': product_id,
        'estimated_value': estimated_value,
        'expected_close_date': expected_close_date,
        'status': 'open',
        'created_date': datetime.now().isoformat()
    }

async def _generate_sales_report(self, period: str, region: str = None, 
                               product_category: str = None) -> Dict:
    """Ustvari obsežno prodajno poročilo"""
    # Simuliraj agregacijo podatkov
    await asyncio.sleep(0.5)
    
    return {
        'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
        'period': period,
        'region': region,
        'product_category': product_category,
        'total_sales': 125000.00,
        'total_opportunities': 45,
        'conversion_rate': 0.67,
        'top_products': [
            {'product_id': 'PROD-001', 'sales': 45000},
            {'product_id': 'PROD-002', 'sales': 32000}
        ],
        'generated_at': datetime.now().isoformat()
    }

async def _send_notification(self, recipients: List[str], message: str, 
                           priority: str = 'medium', channel: str = 'email') -> Dict:
    """Pošlji obvestilo prek določenega kanala"""
    # Simuliraj klic storitve za obveščanje
    await asyncio.sleep(0.1)
    
    notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'notification_id': notification_id,
        'recipients': recipients,
        'channel': channel,
        'priority': priority,
        'status': 'sent',
        'sent_at': datetime.now().isoformat()
    }

def get_function_definitions(self) -> List[Dict]:
    """Pridobi definicije funkcij, združljive z OpenAI, za vse registrirane funkcije"""
    definitions = []
    
    for func_name, func_info in self.functions.items():
        definition = {
            'name': func_name,
            'description': func_info['description'],
            'parameters': {
                'type': 'object',
                'properties': {},
                'required': []
            }
        }
        
        for param_name, param_info in func_info['parameters'].items():
            definition['parameters']['properties'][param_name] = {
                'type': param_info['type'],
                'description': param_info.get('description', '')
            }
            
            if 'enum' in param_info:
                definition['parameters']['properties'][param_name]['enum'] = param_info['enum']
            
            if 'default' in param_info:
                definition['parameters']['properties'][param_name]['default'] = param_info['default']
            
            if param_info.get('required', False):
                definition['parameters']['required'].append(param_name)
        
        definitions.append(definition)
    
    return definitions

# Primer uporabe za integracijo v podjetju
async def enterprise_demo():
    """Demonstriraj zmogljivosti AI agenta za podjetja"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # Primer 1: Obdelava povpraševanja strank
    print("=== Obdelava povpraševanja strank ===")
    
    # Pridobi informacije o stranki
    result = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    if result.success:
        print(f"Pridobljene informacije o stranki: {result.data['name']}")
        print(f"Čas izvedbe: {result.execution_time:.3f}s")
    
    # Primer 2: Ustvarjanje prodajne priložnosti
    print("\n=== Ustvarjanje prodajne priložnosti ===")
    
    result = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    if result.success:
        print(f"Priložnost ustvarjena: {result.data['opportunity_id']}")
    
    # Primer 3: Skupinske operacije
    print("\n=== Skupinske operacije ===")
    
    tasks = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': 'Nova priložnost ustvarjena',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    results = await asyncio.gather(*tasks)
    
    for i, result in enumerate(results):
        if result.success:
            print(f"Naloga {i+1} uspešno zaključena")
        else:
            print(f"Naloga {i+1} ni uspela: {result.error}")
    
    # Prikaži revizijski dnevnik
    print(f"\n=== Revizijski dnevnik ({len(agent.audit_log)} zapisov) ===")
    for entry in agent.audit_log[-3:]:  # Prikaži zadnje 3 zapise
        print(f"{entry['timestamp']}: {entry['function_name']} - {'USPEH' if entry['success'] else 'NEUSPEH'}")

# Zaženi demonstracijo za podjetja
# asyncio.run(enterprise_demo())
- **Phi-4 modeli**: [Hugging Face zbirka](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)
- **Qwen3 dokumentacija**: [Uradna Qwen dokumentacija](https://qwen.readthedocs.io/)
- **Ollama**: [Uradna spletna stran](https://ollama.com/)
- **Foundry Local**: [GitHub repozitorij](https://github.com/microsoft/Foundry-Local)
- **Najboljše prakse za klic funkcij**: [Hugging Face vodič](https://huggingface.co/docs/hugs/en/guides/function-calling)

Ne pozabite, da je klic funkcij področje, ki se nenehno razvija. Če boste sledili najnovejšim razvojem v izbranih ogrodjih in modelih, boste lahko gradili bolj učinkovite AI agente.


## ➡️ Kaj sledi

- [03: Integracija protokola konteksta modela (MCP)](./03.IntroduceMCP.md)

---

**Omejitev odgovornosti**:  
Ta dokument je bil preveden z uporabo storitve za prevajanje z umetno inteligenco [Co-op Translator](https://github.com/Azure/co-op-translator). Čeprav si prizadevamo za natančnost, vas prosimo, da upoštevate, da lahko avtomatizirani prevodi vsebujejo napake ali netočnosti. Izvirni dokument v njegovem izvirnem jeziku je treba obravnavati kot avtoritativni vir. Za ključne informacije priporočamo profesionalni prevod s strani človeka. Ne prevzemamo odgovornosti za morebitna napačna razumevanja ali napačne interpretacije, ki bi nastale zaradi uporabe tega prevoda.