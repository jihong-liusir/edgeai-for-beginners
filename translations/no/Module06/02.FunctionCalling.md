<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-09-18T09:50:37+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "no"
}
-->
# Seksjon02: Funksjonskall i Små Språkmodeller (SLMs)

## Innholdsfortegnelse
1. [Hva er funksjonskall?](../../../Module06)
2. [Hvordan funksjonskall fungerer](../../../Module06)
3. [Bruksområder](../../../Module06)
4. [Konfigurering av funksjonskall med Phi-4-mini og Ollama](../../../Module06)
5. [Arbeid med Qwen3 funksjonskall](../../../Module06)
6. [Foundry Local-integrasjon](../../../Module06)
7. [Beste praksis og feilsøking](../../../Module06)
8. [Avanserte eksempler](../../../Module06)

## Hva er funksjonskall?

Funksjonskall er en kraftig funksjonalitet som lar Små Språkmodeller (SLMs) samhandle med eksterne verktøy, API-er og tjenester. I stedet for å være begrenset til treningsdataene sine, kan SLM-er nå:

- **Koble til eksterne API-er** (vær-tjenester, databaser, søkemotorer)
- **Utføre spesifikke funksjoner** basert på brukerforespørsler
- **Hente sanntidsinformasjon** fra ulike kilder
- **Utføre beregningsoppgaver** gjennom spesialiserte verktøy
- **Kjede flere operasjoner** sammen for komplekse arbeidsflyter

Denne funksjonaliteten forvandler SLM-er fra statiske tekstgeneratorer til dynamiske AI-agenter som kan utføre oppgaver i den virkelige verden.

## Hvordan funksjonskall fungerer

Prosessen for funksjonskall følger en systematisk arbeidsflyt:

### 1. Verktøyintegrasjon
- **Eksterne verktøy**: SLM-er kan koble seg til vær-API-er, databaser, webtjenester og andre eksterne systemer
- **Funksjonsdefinisjoner**: Hvert verktøy defineres med spesifikke parametere, inn-/utdataformater og beskrivelser
- **API-kompatibilitet**: Verktøy integreres gjennom standardiserte grensesnitt (REST API-er, SDK-er, osv.)

### 2. Funksjonsdefinisjon
Funksjoner defineres med tre nøkkelkomponenter:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. Intensjonsgjenkjenning
- **Naturlig språkprosessering**: SLM-en analyserer brukerens input for å forstå intensjonen
- **Funksjonsmatching**: Bestemmer hvilke funksjoner som trengs for å oppfylle forespørselen
- **Parameteruttrekking**: Identifiserer og trekker ut nødvendige parametere fra brukerens melding

### 4. Generering av JSON-utdata
SLM-en genererer strukturert JSON som inneholder:
- Navn på funksjonen som skal kalles
- Nødvendige parametere med riktige verdier
- Utføringskontekst og metadata

### 5. Ekstern utførelse
- **Parameterverifisering**: Sikrer at alle nødvendige parametere er til stede og korrekt formatert
- **Funksjonsutførelse**: Applikasjonen utfører den spesifiserte funksjonen med de oppgitte parameterne
- **Feilhåndtering**: Håndterer feil, tidsavbrudd og ugyldige svar

### 6. Integrering av svar
- **Resultatbehandling**: Funksjonsutdata returneres til SLM-en
- **Kontekstintegrering**: SLM-en inkorporerer resultatene i sitt svar
- **Brukerkommunikasjon**: Presenterer informasjonen i et naturlig, samtalebasert format

## Bruksområder

### Datainnhenting
Konverter naturlige språkforespørsler til strukturerte API-kall:
- **"Vis mine siste bestillinger"** → Databaseforespørsel med bruker-ID og datofilter
- **"Hvordan er været i Tokyo?"** → Vær-API-kall med lokasjonsparameter
- **"Finn e-poster fra John forrige uke"** → E-posttjenesteforespørsel med avsender- og datofilter

### Utførelse av operasjoner
Transformer brukerforespørsler til spesifikke funksjonskall:
- **"Planlegg et møte i morgen kl. 14:00"** → Kalender-API-integrasjon
- **"Send en melding til teamet"** → Kommunikasjonsplattform-API
- **"Lag en sikkerhetskopi av filene mine"** → Filhåndteringsoperasjon

### Beregningsoppgaver
Håndter komplekse matematiske eller logiske operasjoner:
- **"Beregn rentes rente på 10 000 kr med 5 % over 10 år"** → Finansberegningsfunksjon
- **"Analyser dette datasettet for trender"** → Statistiske analyseverktøy
- **"Optimaliser denne ruten for levering"** → Ruteoptimaliseringsalgoritmer

### Arbeidsflyter for databehandling
Kjede flere funksjonskall for komplekse operasjoner:
1. **Hent data** fra flere kilder
2. **Analyser og valider** informasjonen
3. **Transformer** data til ønsket format
4. **Lagre resultater** i passende systemer
5. **Generer rapporter** eller visualiseringer

### UI/UX-integrasjon
Muliggjør dynamiske grensesnittoppdateringer:
- **"Vis salgsdata på dashbordet"** → Diagramgenerering og visning
- **"Oppdater kartet med nye lokasjoner"** → Geodata-integrasjon
- **"Oppdater lageroversikten"** → Sanntidssynkronisering av data

## Konfigurering av funksjonskall med Phi-4-mini og Ollama

Microsofts Phi-4-mini støtter både enkelt- og parallellfunksjonskall gjennom Ollama. Slik setter du det opp:

### Forutsetninger
- Ollama versjon 0.5.13 eller nyere
- Phi-4-mini-modell (anbefalt: `phi4-mini:3.8b-fp16`)

### Installasjonstrinn

#### 1. Installer og kjør Phi-4-mini
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. Opprett en tilpasset ModelFile-mal
På grunn av nåværende begrensninger i Ollamas standardmaler, må du opprette en tilpasset ModelFile med følgende mal:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. Opprett den tilpassede modellen
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### Eksempel på enkeltfunksjonskall

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### Eksempel på parallellfunksjonskall

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## Arbeid med Qwen3 funksjonskall

Qwen3 tilbyr avanserte funksjonskall med utmerket ytelse og fleksibilitet. Slik implementerer du det:

### Bruk av Qwen-Agent-rammeverket

Qwen-Agent gir et høynivårammeverk som forenkler implementeringen av funksjonskall:

#### Installasjon
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### Grunnleggende oppsett

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### Tilpasset funksjonsimplementering

Du kan også definere tilpassede funksjoner for Qwen3:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### Avanserte Qwen3-funksjoner

#### Kontroll av tenkemodus
Qwen3 støtter dynamisk bytte mellom tenke- og ikke-tenkemodus:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### Flertrinns funksjonskall
Qwen3 er spesielt god på å kjede flere funksjonskall:

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## Foundry Local-integrasjon

Microsofts Foundry Local gir en OpenAI-kompatibel API for å kjøre modeller lokalt med forbedret personvern og ytelse.

### Oppsett og installasjon

#### Windows
Last ned installasjonsprogrammet fra [Foundry Local releases-siden](https://github.com/microsoft/Foundry-Local/releases) og følg installasjonsinstruksjonene.

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### Grunnleggende bruk

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### Avanserte Foundry Local-funksjoner

#### Modellhåndtering
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### Ytelsesoptimalisering
Foundry Local velger automatisk den beste modellvarianten for maskinvaren din:
- **CUDA GPU**: Laster ned GPU-optimaliserte modeller
- **Qualcomm NPU**: Bruker NPU-akselererte varianter
- **Kun CPU**: Velger CPU-optimaliserte modeller

## Beste praksis og feilsøking

### Beste praksis for funksjonsdefinisjon

#### 1. Klare og beskrivende navn
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. Omfattende parameterdefinisjoner
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. Validering av input og feilhåndtering
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### Vanlige problemer og løsninger

#### Problem 1: Funksjonen blir ikke kalt
**Symptomer**: Modellen svarer med tekst i stedet for å kalle funksjonen

**Løsninger**:
1. **Sjekk funksjonsbeskrivelsen**: Sørg for at den tydelig samsvarer med brukerens intensjon
2. **Verifiser parameterdefinisjoner**: Sørg for at alle nødvendige parametere er riktig definert
3. **Gjennomgå systemprompten**: Inkluder klare instruksjoner om når funksjoner skal brukes
4. **Test med eksplisitte forespørsler**: Prøv "Vennligst bruk værfunksjonen for å hente data for London"

#### Problem 2: Feil parametere
**Symptomer**: Funksjonen kalles med feil eller manglende parametere

**Løsninger**:
1. **Legg til parametereksempler**: Inkluder eksempelverdier i parameterbeskrivelsene
2. **Bruk enum-begrensninger**: Begrens parametere til spesifikke alternativer der det er mulig
3. **Implementer reserveverdier**: Gi fornuftige standardverdier for valgfrie parametere

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### Problem 3: Feil i parallellfunksjonskall
**Symptomer**: Bare én funksjon utføres når flere burde kjøres

**Løsninger**:
1. **Sjekk modellstøtte**: Sørg for at modellen din støtter parallellfunksjonskall
2. **Oppdater systemprompten**: Inkluder "noen verktøy" eller "flere verktøy" i systemmeldingen
3. **Bruk passende modellversjoner**: Phi-4-mini:3.8b-fp16 anbefales for Ollama

#### Problem 4: Malproblemer med Ollama
**Symptomer**: Funksjonskall fungerer ikke med standard Ollama-oppsett

**Løsninger**:
1. **Bruk tilpasset ModelFile**: Bruk den korrigerte malen som er gitt i denne veiledningen
2. **Oppdater Ollama**: Sørg for at du bruker versjon 0.5.13 eller nyere
3. **Sjekk modellkvantisering**: Høyere kvantisering (Q8_0, fp16) fungerer bedre enn sterkt kvantiserte versjoner

### Ytelsesoptimalisering

#### 1. Effektiv funksjonsdesign
- **Hold funksjoner fokuserte**: Hver funksjon bør ha ett klart formål
- **Minimer eksterne avhengigheter**: Reduser API-kall og nettverksforespørsler der det er mulig
- **Cache resultater**: Lagre ofte forespurte data for å forbedre responstiden

#### 2. Batching og asynkrone operasjoner
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. Ressursstyring
- **Forbindelsespooling**: Gjenbruk database- og API-tilkoblinger
- **Ratebegrensning**: Implementer riktig ratebegrensning for eksterne API-er
- **Timeout-håndtering**: Sett rimelige tidsavbrudd for alle eksterne kall

## Avanserte eksempler

### Samarbeidssystem for flere agenter

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### Dynamisk verktøyvalgssystem

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```python
import asyncio
import json
from typing import Dict, List, Any
from dataclasses import dataclass
from datetime import datetime

@dataclass
class FunctionResult:
    """Standard resultatformat for alle funksjonskall"""
    success: bool
    data: Any = None
    error: str = None
    execution_time: float = 0.0
    timestamp: datetime = None

class EnterpriseAIAgent:
    """Produksjonsklar AI-agent med omfattende funksjonskallkapabiliteter"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.functions = {}
        self.audit_log = []
        self.rate_limiters = {}
        
        # Initialiser kjernefunksjoner
        self._register_core_functions()
    
    def _register_core_functions(self):
        """Registrer alle tilgjengelige kjernefunksjoner"""
        
        # CRM-funksjoner
        self.register_function(
            name="get_customer_info",
            description="Hent kundeinformasjon fra CRM",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "include_history": {"type": "boolean", "default": False}
            },
            handler=self._get_customer_info,
            rate_limit=100  # kall per minutt
        )
        
        # Salgsfunksjoner
        self.register_function(
            name="create_sales_opportunity",
            description="Opprett en ny salgsmulighet",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "product_id": {"type": "string", "required": True},
                "estimated_value": {"type": "number", "required": True},
                "expected_close_date": {"type": "string", "required": True}
            },
            handler=self._create_sales_opportunity,
            rate_limit=50
        )
        
        # Analysefunksjoner
        self.register_function(
            name="generate_sales_report",
            description="Generer salgsytelsesrapport",
            parameters={
                "period": {"type": "string", "enum": ["daily", "weekly", "monthly", "quarterly"]},
                "region": {"type": "string", "required": False},
                "product_category": {"type": "string", "required": False}
            },
            handler=self._generate_sales_report,
            rate_limit=10
        )
        
        # Varslingsfunksjoner
        self.register_function(
            name="send_notification",
            description="Send varsel til teammedlemmer",
            parameters={
                "recipients": {"type": "array", "items": {"type": "string"}},
                "message": {"type": "string", "required": True},
                "priority": {"type": "string", "enum": ["low", "medium", "high"], "default": "medium"},
                "channel": {"type": "string", "enum": ["email", "slack", "teams"], "default": "email"}
            },
            handler=self._send_notification,
            rate_limit=200
        )
    
    def register_function(self, name: str, description: str, parameters: Dict, 
                         handler: callable, rate_limit: int = 60):
        """Registrer en ny funksjon med agenten"""
        self.functions[name] = {
            'description': description,
            'parameters': parameters,
            'handler': handler,
            'rate_limit': rate_limit,
            'call_count': 0,
            'last_reset': datetime.now()
        }
    
    async def execute_function(self, function_name: str, parameters: Dict) -
# Introduksjon

Velkommen til dokumentasjonen for prosjektet vårt! Her finner du all nødvendig informasjon for å komme i gang, samt detaljer om hvordan du kan bidra.

## Komme i gang

Følg disse trinnene for å sette opp prosjektet lokalt:

1. Klon depotet:  
   ```bash
   git clone @@INLINE_CODE_1@@
   ```

2. Naviger til prosjektmappen:  
   ```bash
   cd @@INLINE_CODE_2@@
   ```

3. Installer avhengigheter:  
   ```bash
   @@INLINE_CODE_3@@
   ```

4. Start applikasjonen:  
   ```bash
   @@INLINE_CODE_4@@
   ```

## Bidra

Vi setter pris på alle bidrag! Her er noen måter du kan hjelpe:

- **Rapporter feil**: Hvis du finner en feil, vennligst opprett en sak på @@INLINE_CODE_5@@.
- **Foreslå forbedringer**: Har du ideer til hvordan vi kan forbedre prosjektet? Del dem med oss!
- **Send inn kode**: Hvis du ønsker å bidra med kode, følg disse trinnene:
  1. Fork depotet.
  2. Lag en ny gren for endringene dine.
  3. Send inn en pull request.

## Vanlige spørsmål

### Hvordan kan jeg kontakte teamet?
Du kan nå oss via e-post på @@INLINE_CODE_6@@.

### Er det en liste over kjente problemer?
Ja, du finner den på @@INLINE_CODE_7@@.

### Kan jeg bruke dette prosjektet kommersielt?
Se lisensfilen for detaljer.

## Lisens

Dette prosjektet er lisensiert under @@INLINE_CODE_8@@.
"""Utfør en funksjon med omfattende feilhåndtering og logging"""
start_time = datetime.now()

try:
    # Sjekk at funksjonen eksisterer
    if function_name not in self.functions:
        return FunctionResult(
            success=False,
            error=f"Funksjon '{function_name}' ikke funnet",
            timestamp=start_time
        )
    
    # Sjekk ratebegrensninger
    if not self._check_rate_limit(function_name):
        return FunctionResult(
            success=False,
            error=f"Ratebegrensning overskredet for funksjon '{function_name}'",
            timestamp=start_time
        )
    
    # Valider parametere
    validation_result = self._validate_parameters(function_name, parameters)
    if not validation_result.success:
        return validation_result
    
    # Utfør funksjonen
    func_info = self.functions[function_name]
    handler = func_info['handler']
    
    if asyncio.iscoroutinefunction(handler):
        result_data = await handler(**parameters)
    else:
        result_data = handler(**parameters)
    
    execution_time = (datetime.now() - start_time).total_seconds()
    
    result = FunctionResult(
        success=True,
        data=result_data,
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Logg vellykket kjøring
    self._log_function_call(function_name, parameters, result)
    
    return result
    
except Exception as e:
    execution_time = (datetime.now() - start_time).total_seconds()
    result = FunctionResult(
        success=False,
        error=str(e),
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Logg mislykket kjøring
    self._log_function_call(function_name, parameters, result)
    
    return result

def _check_rate_limit(self, function_name: str) -> bool:
    """Sjekk om funksjonskall er innenfor ratebegrensninger"""
    func_info = self.functions[function_name]
    now = datetime.now()
    
    # Nullstill teller hvis et minutt har gått
    if (now - func_info['last_reset']).seconds >= 60:
        func_info['call_count'] = 0
        func_info['last_reset'] = now
    
    # Sjekk om det er under grensen
    if func_info['call_count'] >= func_info['rate_limit']:
        return False
    
    func_info['call_count'] += 1
    return True

def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
    """Valider funksjonsparametere"""
    func_params = self.functions[function_name]['parameters']
    
    # Sjekk påkrevde parametere
    for param_name, param_info in func_params.items():
        if param_info.get('required', False) and param_name not in parameters:
            return FunctionResult(
                success=False,
                error=f"Mangler påkrevd parameter: {param_name}"
            )
    
    # Valider parameter-typer og begrensninger
    for param_name, value in parameters.items():
        if param_name in func_params:
            param_info = func_params[param_name]
            
            # Typevalidering
            expected_type = param_info.get('type')
            if expected_type == 'string' and not isinstance(value, str):
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' må være en streng"
                )
            elif expected_type == 'number' and not isinstance(value, (int, float)):
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' må være et tall"
                )
            elif expected_type == 'boolean' and not isinstance(value, bool):
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' må være en boolsk verdi"
                )
            
            # Enum-validering
            if 'enum' in param_info and value not in param_info['enum']:
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' må være en av: {param_info['enum']}"
                )
    
    return FunctionResult(success=True)

def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):
    """Logg funksjonskall for revisjonsformål"""
    log_entry = {
        'timestamp': result.timestamp.isoformat(),
        'function_name': function_name,
        'parameters': parameters,
        'success': result.success,
        'execution_time': result.execution_time,
        'error': result.error if not result.success else None
    }
    
    self.audit_log.append(log_entry)
    
    # Eventuelt skriv til eksternt loggesystem
    if self.config.get('enable_external_logging', False):
        self._write_to_external_log(log_entry)

def _write_to_external_log(self, log_entry: Dict):
    """Skriv loggoppføring til eksternt loggesystem"""
    # Implementasjonen avhenger av din loggeinfrastruktur
    # f.eks., send til ELK stack, CloudWatch, etc.
    pass

# Implementasjoner av forretningsfunksjoner
async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
    """Hent kundeinformasjon fra CRM-systemet"""
    # Simuler database-/API-kall
    await asyncio.sleep(0.1)  # Simuler nettverksforsinkelse
    
    customer_data = {
        'customer_id': customer_id,
        'name': 'John Doe',
        'email': 'john.doe@example.com',
        'phone': '+1-555-0123',
        'status': 'active',
        'tier': 'premium'
    }
    
    if include_history:
        customer_data['purchase_history'] = [
            {'date': '2024-01-15', 'product': 'Produkt A', 'amount': 1500},
            {'date': '2024-03-22', 'product': 'Produkt B', 'amount': 2300}
        ]
    
    return customer_data

async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                    estimated_value: float, expected_close_date: str) -> Dict:
    """Opprett en ny salgsopportunity"""
    # Simuler CRM API-kall
    await asyncio.sleep(0.2)
    
    opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'opportunity_id': opportunity_id,
        'customer_id': customer_id,
        'product_id': product_id,
        'estimated_value': estimated_value,
        'expected_close_date': expected_close_date,
        'status': 'open',
        'created_date': datetime.now().isoformat()
    }

async def _generate_sales_report(self, period: str, region: str = None, 
                                 product_category: str = None) -> Dict:
    """Generer omfattende salgsrapport"""
    # Simuler dataaggregasjon
    await asyncio.sleep(0.5)
    
    return {
        'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
        'period': period,
        'region': region,
        'product_category': product_category,
        'total_sales': 125000.00,
        'total_opportunities': 45,
        'conversion_rate': 0.67,
        'top_products': [
            {'product_id': 'PROD-001', 'sales': 45000},
            {'product_id': 'PROD-002', 'sales': 32000}
        ],
        'generated_at': datetime.now().isoformat()
    }

async def _send_notification(self, recipients: List[str], message: str, 
                             priority: str = 'medium', channel: str = 'email') -> Dict:
    """Send varsel via spesifisert kanal"""
    # Simuler varselstjenestekall
    await asyncio.sleep(0.1)
    
    notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'notification_id': notification_id,
        'recipients': recipients,
        'channel': channel,
        'priority': priority,
        'status': 'sent',
        'sent_at': datetime.now().isoformat()
    }

def get_function_definitions(self) -> List[Dict]:
    """Hent OpenAI-kompatible funksjonsdefinisjoner for alle registrerte funksjoner"""
    definitions = []
    
    for func_name, func_info in self.functions.items():
        definition = {
            'name': func_name,
            'description': func_info['description'],
            'parameters': {
                'type': 'object',
                'properties': {},
                'required': []
            }
        }
        
        for param_name, param_info in func_info['parameters'].items():
            definition['parameters']['properties'][param_name] = {
                'type': param_info['type'],
                'description': param_info.get('description', '')
            }
            
            if 'enum' in param_info:
                definition['parameters']['properties'][param_name]['enum'] = param_info['enum']
            
            if 'default' in param_info:
                definition['parameters']['properties'][param_name]['default'] = param_info['default']
            
            if param_info.get('required', False):
                definition['parameters']['required'].append(param_name)
        
        definitions.append(definition)
    
    return definitions

# Eksempel på bruk for bedriftsintegrasjon
async def enterprise_demo():
    """Demonstrer bedrifts-AI-agentens evner"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # Eksempel 1: Behandling av kundehenvendelser
    print("=== Behandling av kundehenvendelser ===")
    
    # Hent kundeinformasjon
    result = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    if result.success:
        print(f"Kundeinfo hentet: {result.data['name']}")
        print(f"Kjøretid: {result.execution_time:.3f}s")
    
    # Eksempel 2: Opprettelse av salgsopportunity
    print("\n=== Opprettelse av salgsopportunity ===")
    
    result = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    if result.success:
        print(f"Opportunity opprettet: {result.data['opportunity_id']}")
    
    # Eksempel 3: Batch-operasjoner
    print("\n=== Batch-operasjoner ===")
    
    tasks = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': 'Ny opportunity opprettet',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    results = await asyncio.gather(*tasks)
    
    for i, result in enumerate(results):
        if result.success:
            print(f"Oppgave {i+1} fullført vellykket")
        else:
            print(f"Oppgave {i+1} feilet: {result.error}")
    
    # Vis revisjonslogg
    print(f"\n=== Revisjonslogg ({len(agent.audit_log)} oppføringer) ===")
    for entry in agent.audit_log[-3:]:  # Vis de siste 3 oppføringene
        print(f"{entry['timestamp']}: {entry['function_name']} - {'SUKSESS' if entry['success'] else 'FEILET'}")

# Kjør bedriftsdemo
# asyncio.run(enterprise_demo())
- **Phi-4 Modeller**: [Hugging Face Collection](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)
- **Qwen3 Dokumentasjon**: [Offisiell Qwen Dokumentasjon](https://qwen.readthedocs.io/)
- **Ollama**: [Offisiell nettside](https://ollama.com/)
- **Foundry Local**: [GitHub-repositorium](https://github.com/microsoft/Foundry-Local)
- **Beste praksis for funksjonskall**: [Hugging Face Guide](https://huggingface.co/docs/hugs/en/guides/function-calling)

Husk at funksjonskall er et felt i utvikling, og det å holde seg oppdatert på de nyeste fremskrittene innen dine valgte rammeverk og modeller vil hjelpe deg med å bygge mer effektive AI-agenter.


## ➡️ Hva er neste steg

- [03: Integrering av Model Context Protocol (MCP)](./03.IntroduceMCP.md)

---

**Ansvarsfraskrivelse**:  
Dette dokumentet er oversatt ved hjelp av AI-oversettelsestjenesten [Co-op Translator](https://github.com/Azure/co-op-translator). Selv om vi streber etter nøyaktighet, vær oppmerksom på at automatiserte oversettelser kan inneholde feil eller unøyaktigheter. Det originale dokumentet på sitt opprinnelige språk bør anses som den autoritative kilden. For kritisk informasjon anbefales profesjonell menneskelig oversettelse. Vi er ikke ansvarlige for misforståelser eller feiltolkninger som oppstår ved bruk av denne oversettelsen.