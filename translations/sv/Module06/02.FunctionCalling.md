<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-09-18T07:20:53+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "sv"
}
-->
# Section02 : Funktionsanrop i små språkmodeller (SLMs)

## Innehållsförteckning
1. [Vad är funktionsanrop?](../../../Module06)
2. [Hur funktionsanrop fungerar](../../../Module06)
3. [Användningsområden](../../../Module06)
4. [Konfigurera funktionsanrop med Phi-4-mini och Ollama](../../../Module06)
5. [Arbeta med Qwen3 funktionsanrop](../../../Module06)
6. [Foundry Local-integration](../../../Module06)
7. [Bästa praxis och felsökning](../../../Module06)
8. [Avancerade exempel](../../../Module06)

## Vad är funktionsanrop?

Funktionsanrop är en kraftfull funktion som gör det möjligt för små språkmodeller (SLMs) att interagera med externa verktyg, API:er och tjänster. Istället för att vara begränsade till sin träningsdata kan SLM:er nu:

- **Ansluta till externa API:er** (vädertjänster, databaser, sökmotorer)
- **Utföra specifika funktioner** baserat på användarens begäran
- **Hämta realtidsinformation** från olika källor
- **Utföra beräkningsuppgifter** med hjälp av specialiserade verktyg
- **Koppla ihop flera operationer** för komplexa arbetsflöden

Denna funktion förvandlar SLM:er från statiska textgeneratorer till dynamiska AI-agenter som kan utföra verkliga uppgifter.

## Hur funktionsanrop fungerar

Processen för funktionsanrop följer ett systematiskt arbetsflöde:

### 1. Verktygsintegration
- **Externa verktyg**: SLM:er kan ansluta till väder-API:er, databaser, webbtjänster och andra externa system
- **Funktionsdefinitioner**: Varje verktyg definieras med specifika parametrar, in-/utdataformat och beskrivningar
- **API-kompatibilitet**: Verktyg integreras via standardiserade gränssnitt (REST API:er, SDK:er, etc.)

### 2. Funktionsdefinition
Funktioner definieras med tre nyckelkomponenter:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. Intentdetektion
- **Naturlig språkförståelse**: SLM analyserar användarens input för att förstå avsikten
- **Matchning av funktioner**: Avgör vilka funktioner som behövs för att uppfylla begäran
- **Parameterutvinning**: Identifierar och extraherar nödvändiga parametrar från användarens meddelande

### 4. Generering av JSON-utdata
SLM genererar strukturerad JSON som innehåller:
- Funktionsnamn att anropa
- Nödvändiga parametrar med lämpliga värden
- Exekveringskontext och metadata

### 5. Extern exekvering
- **Parameterverifiering**: Säkerställer att alla nödvändiga parametrar finns och är korrekt formaterade
- **Funktionskörning**: Applikationen kör den angivna funktionen med de angivna parametrarna
- **Felhantering**: Hanterar fel, tidsgränser och ogiltiga svar

### 6. Integrering av svar
- **Resultatbearbetning**: Funktionsutdata returneras till SLM
- **Kontextintegrering**: SLM införlivar resultaten i sitt svar
- **Användarkommunikation**: Presenterar informationen i ett naturligt, konversationsformat

## Användningsområden

### Datahämtning
Omvandla naturliga språkfrågor till strukturerade API-anrop:
- **"Visa mina senaste beställningar"** → Databassökning med användar-ID och datumfilter
- **"Hur är vädret i Tokyo?"** → Väder-API-anrop med platsparameter
- **"Hitta mejl från John förra veckan"** → E-posttjänstsökning med avsändare och datumfilter

### Operationer
Omvandla användarens begäran till specifika funktionsanrop:
- **"Schemalägg ett möte imorgon kl. 14:00"** → Kalender-API-integration
- **"Skicka ett meddelande till teamet"** → Kommunikationsplattform-API
- **"Skapa en säkerhetskopia av mina filer"** → Filhanteringsoperation

### Beräkningsuppgifter
Hantera komplexa matematiska eller logiska operationer:
- **"Beräkna ränta på $10,000 med 5% i 10 år"** → Finansiell beräkningsfunktion
- **"Analysera denna dataset för trender"** → Statistiska analysverktyg
- **"Optimera denna rutt för leverans"** → Ruttoptimeringsalgoritmer

### Databehandlingsarbetsflöden
Koppla ihop flera funktionsanrop för komplexa operationer:
1. **Hämta data** från flera källor
2. **Analysera och verifiera** informationen
3. **Transformera** data till önskat format
4. **Lagra resultat** i lämpliga system
5. **Generera rapporter** eller visualiseringar

### UI/UX-integration
Möjliggör dynamiska gränssnittsuppdateringar:
- **"Visa försäljningsdata på instrumentpanelen"** → Diagramgenerering och visning
- **"Uppdatera kartan med nya platser"** → Geospatial dataintegration
- **"Uppdatera lagerdisplayen"** → Realtidssynkronisering av data

## Konfigurera funktionsanrop med Phi-4-mini och Ollama

Microsofts Phi-4-mini stöder både enskilda och parallella funktionsanrop via Ollama. Så här konfigurerar du det:

### Förutsättningar
- Ollama version 0.5.13 eller högre
- Phi-4-mini-modell (rekommenderad: `phi4-mini:3.8b-fp16`)

### Installationssteg

#### 1. Installera och kör Phi-4-mini
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. Skapa anpassad ModelFile-mall
På grund av nuvarande begränsningar i Ollamas standardmallar måste du skapa en anpassad ModelFile med följande mall:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. Skapa den anpassade modellen
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### Exempel på enskilt funktionsanrop

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### Exempel på parallellt funktionsanrop

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## Arbeta med Qwen3 funktionsanrop

Qwen3 erbjuder avancerade funktionsanropsmöjligheter med utmärkt prestanda och flexibilitet. Så här implementerar du det:

### Använda Qwen-Agent Framework

Qwen-Agent tillhandahåller ett hög-nivåramverk som förenklar implementeringen av funktionsanrop:

#### Installation
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### Grundläggande konfiguration

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### Anpassad funktionsimplementering

Du kan också definiera anpassade funktioner för Qwen3:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### Avancerade Qwen3-funktioner

#### Kontroll av tänkande läge
Qwen3 stöder dynamisk växling mellan tänkande och icke-tänkande lägen:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### Flerstegs funktionsanrop
Qwen3 är utmärkt på att koppla ihop flera funktionsanrop:

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## Foundry Local-integration

Microsofts Foundry Local tillhandahåller ett OpenAI-kompatibelt API för att köra modeller lokalt med förbättrad integritet och prestanda.

### Konfiguration och installation

#### Windows
Ladda ner installationsprogrammet från [Foundry Local releases page](https://github.com/microsoft/Foundry-Local/releases) och följ installationsinstruktionerna.

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### Grundläggande användning

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### Avancerade Foundry Local-funktioner

#### Modellhantering
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### Prestandaoptimering
Foundry Local väljer automatiskt den bästa modellvarianten för din hårdvara:
- **CUDA GPU**: Laddar GPU-optimerade modeller
- **Qualcomm NPU**: Använder NPU-accelererade varianter
- **Endast CPU**: Väljer CPU-optimerade modeller

## Bästa praxis och felsökning

### Bästa praxis för funktionsdefinition

#### 1. Tydliga och beskrivande namn
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. Omfattande parameterdefinitioner
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. Validering av indata och felhantering
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### Vanliga problem och lösningar

#### Problem 1: Funktionen anropas inte
**Symptom**: Modellen svarar med text istället för att anropa funktionen

**Lösningar**:
1. **Kontrollera funktionsbeskrivningen**: Säkerställ att den tydligt matchar användarens avsikt
2. **Verifiera parameterdefinitioner**: Kontrollera att alla nödvändiga parametrar är korrekt definierade
3. **Granska systemprompten**: Inkludera tydliga instruktioner om när funktioner ska användas
4. **Testa med explicita begäranden**: Prova "Använd väderfunktionen för att hämta data för London"

#### Problem 2: Felaktiga parametrar
**Symptom**: Funktionen anropas med felaktiga eller saknade parametrar

**Lösningar**:
1. **Lägg till parameterexempel**: Inkludera exempelvärden i parameterbeskrivningarna
2. **Använd enum-begränsningar**: Begränsa parametervärden till specifika alternativ när det är möjligt
3. **Implementera reservvärden**: Tillhandahåll rimliga standardvärden för valfria parametrar

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### Problem 3: Fel vid parallella funktionsanrop
**Symptom**: Endast en funktion körs när flera borde köras

**Lösningar**:
1. **Kontrollera modellstöd**: Säkerställ att din modell stöder parallella funktionsanrop
2. **Uppdatera systemprompten**: Inkludera "några verktyg" eller "flera verktyg" i systemmeddelandet
3. **Använd lämpliga modellversioner**: Phi-4-mini:3.8b-fp16 rekommenderas för Ollama

#### Problem 4: Mallproblem med Ollama
**Symptom**: Funktionsanrop fungerar inte med Ollamas standardinställning

**Lösningar**:
1. **Använd anpassad ModelFile**: Använd den korrigerade mallen som tillhandahålls i denna handledning
2. **Uppdatera Ollama**: Säkerställ att du använder version 0.5.13 eller högre
3. **Kontrollera modellkvantisering**: Högre kvantiseringsnivåer (Q8_0, fp16) fungerar bättre än kraftigt kvantiserade versioner

### Prestandaoptimering

#### 1. Effektiv funktionsdesign
- **Håll funktioner fokuserade**: Varje funktion bör ha ett enda, tydligt syfte
- **Minimera externa beroenden**: Minska API-anrop och nätverksförfrågningar där det är möjligt
- **Cachea resultat**: Lagra ofta begärda data för att förbättra svarstider

#### 2. Batchning och asynkrona operationer
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. Resurshantering
- **Anslutningspoolning**: Återanvänd databas- och API-anslutningar
- **Hastighetsbegränsning**: Implementera korrekt hastighetsbegränsning för externa API:er
- **Timeout-hantering**: Ställ in rimliga tidsgränser för alla externa anrop

## Avancerade exempel

### System för samarbete mellan flera agenter

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### System för dynamiskt verktygsval

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```python
import asyncio
import json
from typing import Dict, List, Any
from dataclasses import dataclass
from datetime import datetime

@dataclass
class FunctionResult:
    """Standardresultatformat för alla funktionsanrop"""
    success: bool
    data: Any = None
    error: str = None
    execution_time: float = 0.0
    timestamp: datetime = None

class EnterpriseAIAgent:
    """Produktionsklar AI-agent med omfattande funktionsanropsmöjligheter"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.functions = {}
        self.audit_log = []
        self.rate_limiters = {}
        
        # Initiera kärnfunktioner för verksamheten
        self._register_core_functions()
    
    def _register_core_functions(self):
        """Registrera alla tillgängliga verksamhetsfunktioner"""
        
        # CRM-funktioner
        self.register_function(
            name="get_customer_info",
            description="Hämta kundinformation från CRM",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "include_history": {"type": "boolean", "default": False}
            },
            handler=self._get_customer_info,
            rate_limit=100  # anrop per minut
        )
        
        # Försäljningsfunktioner
        self.register_function(
            name="create_sales_opportunity",
            description="Skapa en ny försäljningsmöjlighet",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "product_id": {"type": "string", "required": True},
                "estimated_value": {"type": "number", "required": True},
                "expected_close_date": {"type": "string", "required": True}
            },
            handler=self._create_sales_opportunity,
            rate_limit=50
        )
        
        # Analysfunktioner
        self.register_function(
            name="generate_sales_report",
            description="Generera försäljningsprestandarapport",
            parameters={
                "period": {"type": "string", "enum": ["daily", "weekly", "monthly", "quarterly"]},
                "region": {"type": "string", "required": False},
                "product_category": {"type": "string", "required": False}
            },
            handler=self._generate_sales_report,
            rate_limit=10
        )
        
        # Notifikationsfunktioner
        self.register_function(
            name="send_notification",
            description="Skicka notifikation till teammedlemmar",
            parameters={
                "recipients": {"type": "array", "items": {"type": "string"}},
                "message": {"type": "string", "required": True},
                "priority": {"type": "string", "enum": ["low", "medium", "high"], "default": "medium"},
                "channel": {"type": "string", "enum": ["email", "slack", "teams"], "default": "email"}
            },
            handler=self._send_notification,
            rate_limit=200
        )
    
    def register_function(self, name: str, description: str, parameters: Dict, 
                         handler: callable, rate_limit: int = 60):
        """Registrera en ny funktion med agenten"""
        self.functions[name] = {
            'description': description,
            'parameters': parameters,
            'handler': handler,
            'rate_limit': rate_limit,
            'call_count': 0,
            'last_reset': datetime.now()
        }
    
    async def execute_function(self, function_name: str, parameters: Dict) -
I'm sorry, but I need the content of the markdown file to proceed with the translation. Could you please provide the text you'd like me to translate?
"""Utför en funktion med omfattande felhantering och loggning"""
start_time = datetime.now()

try:
    # Kontrollera att funktionen finns
    if function_name not in self.functions:
        return FunctionResult(
            success=False,
            error=f"Funktionen '{function_name}' hittades inte",
            timestamp=start_time
        )
    
    # Kontrollera gränser för anrop
    if not self._check_rate_limit(function_name):
        return FunctionResult(
            success=False,
            error=f"Gränsen för anrop överskriden för funktionen '{function_name}'",
            timestamp=start_time
        )
    
    # Validera parametrar
    validation_result = self._validate_parameters(function_name, parameters)
    if not validation_result.success:
        return validation_result
    
    # Utför funktionen
    func_info = self.functions[function_name]
    handler = func_info['handler']
    
    if asyncio.iscoroutinefunction(handler):
        result_data = await handler(**parameters)
    else:
        result_data = handler(**parameters)
    
    execution_time = (datetime.now() - start_time).total_seconds()
    
    result = FunctionResult(
        success=True,
        data=result_data,
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Logga lyckat utförande
    self._log_function_call(function_name, parameters, result)
    
    return result
    
except Exception as e:
    execution_time = (datetime.now() - start_time).total_seconds()
    result = FunctionResult(
        success=False,
        error=str(e),
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Logga misslyckat utförande
    self._log_function_call(function_name, parameters, result)
    
    return result

def _check_rate_limit(self, function_name: str) -> bool:
    """Kontrollera om funktionsanropet är inom gränserna"""
    func_info = self.functions[function_name]
    now = datetime.now()
    
    # Återställ räknaren om en minut har passerat
    if (now - func_info['last_reset']).seconds >= 60:
        func_info['call_count'] = 0
        func_info['last_reset'] = now
    
    # Kontrollera om gränsen är överskriden
    if func_info['call_count'] >= func_info['rate_limit']:
        return False
    
    func_info['call_count'] += 1
    return True

def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
    """Validera funktionsparametrar"""
    func_params = self.functions[function_name]['parameters']
    
    # Kontrollera obligatoriska parametrar
    for param_name, param_info in func_params.items():
        if param_info.get('required', False) and param_name not in parameters:
            return FunctionResult(
                success=False,
                error=f"Saknar obligatorisk parameter: {param_name}"
            )
    
    # Validera parametrars typer och begränsningar
    for param_name, value in parameters.items():
        if param_name in func_params:
            param_info = func_params[param_name]
            
            # Typvalidering
            expected_type = param_info.get('type')
            if expected_type == 'string' and not isinstance(value, str):
                return FunctionResult(
                    success=False,
                    error=f"Parametern '{param_name}' måste vara en sträng"
                )
            elif expected_type == 'number' and not isinstance(value, (int, float)):
                return FunctionResult(
                    success=False,
                    error=f"Parametern '{param_name}' måste vara ett nummer"
                )
            elif expected_type == 'boolean' and not isinstance(value, bool):
                return FunctionResult(
                    success=False,
                    error=f"Parametern '{param_name}' måste vara en boolean"
                )
            
            # Enum-validering
            if 'enum' in param_info and value not in param_info['enum']:
                return FunctionResult(
                    success=False,
                    error=f"Parametern '{param_name}' måste vara en av: {param_info['enum']}"
                )
    
    return FunctionResult(success=True)

def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):
    """Logga funktionsanrop för revisionsändamål"""
    log_entry = {
        'timestamp': result.timestamp.isoformat(),
        'function_name': function_name,
        'parameters': parameters,
        'success': result.success,
        'execution_time': result.execution_time,
        'error': result.error if not result.success else None
    }
    
    self.audit_log.append(log_entry)
    
    # Eventuellt skriva till extern loggningssystem
    if self.config.get('enable_external_logging', False):
        self._write_to_external_log(log_entry)

def _write_to_external_log(self, log_entry: Dict):
    """Skriv loggpost till extern loggningssystem"""
    # Implementeringen beror på din loggningsinfrastruktur
    # t.ex., skicka till ELK-stack, CloudWatch, etc.
    pass

# Implementering av affärsfunktioner
async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
    """Hämta kundinformation från CRM-systemet"""
    # Simulera databas-/API-anrop
    await asyncio.sleep(0.1)  # Simulera nätverksfördröjning
    
    customer_data = {
        'customer_id': customer_id,
        'name': 'John Doe',
        'email': 'john.doe@example.com',
        'phone': '+1-555-0123',
        'status': 'active',
        'tier': 'premium'
    }
    
    if include_history:
        customer_data['purchase_history'] = [
            {'date': '2024-01-15', 'product': 'Produkt A', 'amount': 1500},
            {'date': '2024-03-22', 'product': 'Produkt B', 'amount': 2300}
        ]
    
    return customer_data

async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                  estimated_value: float, expected_close_date: str) -> Dict:
    """Skapa en ny försäljningsmöjlighet"""
    # Simulera CRM API-anrop
    await asyncio.sleep(0.2)
    
    opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'opportunity_id': opportunity_id,
        'customer_id': customer_id,
        'product_id': product_id,
        'estimated_value': estimated_value,
        'expected_close_date': expected_close_date,
        'status': 'open',
        'created_date': datetime.now().isoformat()
    }

async def _generate_sales_report(self, period: str, region: str = None, 
                               product_category: str = None) -> Dict:
    """Generera omfattande försäljningsrapport"""
    # Simulera dataaggregering
    await asyncio.sleep(0.5)
    
    return {
        'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
        'period': period,
        'region': region,
        'product_category': product_category,
        'total_sales': 125000.00,
        'total_opportunities': 45,
        'conversion_rate': 0.67,
        'top_products': [
            {'product_id': 'PROD-001', 'sales': 45000},
            {'product_id': 'PROD-002', 'sales': 32000}
        ],
        'generated_at': datetime.now().isoformat()
    }

async def _send_notification(self, recipients: List[str], message: str, 
                           priority: str = 'medium', channel: str = 'email') -> Dict:
    """Skicka meddelande via angiven kanal"""
    # Simulera anrop till meddelandetjänst
    await asyncio.sleep(0.1)
    
    notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'notification_id': notification_id,
        'recipients': recipients,
        'channel': channel,
        'priority': priority,
        'status': 'sent',
        'sent_at': datetime.now().isoformat()
    }

def get_function_definitions(self) -> List[Dict]:
    """Hämta OpenAI-kompatibla funktionsdefinitioner för alla registrerade funktioner"""
    definitions = []
    
    for func_name, func_info in self.functions.items():
        definition = {
            'name': func_name,
            'description': func_info['description'],
            'parameters': {
                'type': 'object',
                'properties': {},
                'required': []
            }
        }
        
        for param_name, param_info in func_info['parameters'].items():
            definition['parameters']['properties'][param_name] = {
                'type': param_info['type'],
                'description': param_info.get('description', '')
            }
            
            if 'enum' in param_info:
                definition['parameters']['properties'][param_name]['enum'] = param_info['enum']
            
            if 'default' in param_info:
                definition['parameters']['properties'][param_name]['default'] = param_info['default']
            
            if param_info.get('required', False):
                definition['parameters']['required'].append(param_name)
        
        definitions.append(definition)
    
    return definitions

# Exempel på användning för företagsintegration
async def enterprise_demo():
    """Demonstrera företags-AI-agentens kapabiliteter"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # Exempel 1: Bearbetning av kundförfrågningar
    print("=== Bearbetning av kundförfrågningar ===")
    
    # Hämta kundinformation
    result = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    if result.success:
        print(f"Kundinformation hämtad: {result.data['name']}")
        print(f"Utförandetid: {result.execution_time:.3f}s")
    
    # Exempel 2: Skapa försäljningsmöjlighet
    print("\n=== Skapa försäljningsmöjlighet ===")
    
    result = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    if result.success:
        print(f"Möjlighet skapad: {result.data['opportunity_id']}")
    
    # Exempel 3: Batchoperationer
    print("\n=== Batchoperationer ===")
    
    tasks = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': 'Ny möjlighet skapad',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    results = await asyncio.gather(*tasks)
    
    for i, result in enumerate(results):
        if result.success:
            print(f"Uppgift {i+1} slutförd framgångsrikt")
        else:
            print(f"Uppgift {i+1} misslyckades: {result.error}")
    
    # Visa revisionslogg
    print(f"\n=== Revisionslogg ({len(agent.audit_log)} poster) ===")
    for entry in agent.audit_log[-3:]:  # Visa de senaste 3 posterna
        print(f"{entry['timestamp']}: {entry['function_name']} - {'FRAMGÅNG' if entry['success'] else 'MISSLYCKAD'}")

# Kör företagsdemonstrationen
# asyncio.run(enterprise_demo())
- **Phi-4 Modeller**: [Hugging Face Collection](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)
- **Qwen3 Dokumentation**: [Officiell Qwen Dokumentation](https://qwen.readthedocs.io/)
- **Ollama**: [Officiell Webbplats](https://ollama.com/)
- **Foundry Local**: [GitHub Repository](https://github.com/microsoft/Foundry-Local)
- **Bästa praxis för funktionsanrop**: [Hugging Face Guide](https://huggingface.co/docs/hugs/en/guides/function-calling)

Kom ihåg att funktionsanrop är ett område som ständigt utvecklas, och att hålla sig uppdaterad med de senaste framstegen inom dina valda ramverk och modeller kommer att hjälpa dig att bygga mer effektiva AI-agenter.


## ➡️ Vad händer härnäst

- [03: Integrering av Model Context Protocol (MCP)](./03.IntroduceMCP.md)

---

**Ansvarsfriskrivning**:  
Detta dokument har översatts med hjälp av AI-översättningstjänsten [Co-op Translator](https://github.com/Azure/co-op-translator). Även om vi strävar efter noggrannhet, bör du vara medveten om att automatiserade översättningar kan innehålla fel eller inexaktheter. Det ursprungliga dokumentet på dess originalspråk bör betraktas som den auktoritativa källan. För kritisk information rekommenderas professionell mänsklig översättning. Vi ansvarar inte för eventuella missförstånd eller feltolkningar som uppstår vid användning av denna översättning.