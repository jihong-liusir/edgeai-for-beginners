<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "7256301d9d690c2054eabbf2bc5b10bf",
  "translation_date": "2025-09-23T01:11:02+00:00",
  "source_file": "Module08/06.ModelsAsTools.md",
  "language_code": "lt"
}
-->
# Sesija 6: Foundry Local – Modeliai kaip Įrankiai

## Apžvalga

Naudokite AI modelius kaip moduliuojamus, pritaikomus įrankius, veikiančius tiesiogiai įrenginyje su Foundry Local. Ši sesija pabrėžia praktinius darbo procesus, skirtus privatumo išsaugojimui, mažo delsimo prognozėms ir kaip integruoti šiuos įrankius per SDK, API ar CLI. Taip pat sužinosite, kaip prireikus pereiti prie Azure AI Foundry.

Nuorodos:
- Foundry Local dokumentacija: https://learn.microsoft.com/en-us/azure/ai-foundry/foundry-local/
- Integracija su prognozavimo SDK: https://learn.microsoft.com/en-us/azure/ai-foundry/foundry-local/how-to/how-to-integrate-with-inference-sdks
- Hugging Face modelių kompiliavimas: https://learn.microsoft.com/en-us/azure/ai-foundry/foundry-local/how-to/how-to-compile-hugging-face-models

## Mokymosi tikslai
- Kurti modelio-kaip-įrankio šablonus įrenginyje
- Integruoti per OpenAI suderinamą REST API arba SDK
- Pritaikyti modelius specifiniams domeno poreikiams
- Planuoti hibridinį mastelį su Azure AI Foundry

## 1 dalis: Įrankių abstrakcijos (žingsnis po žingsnio)

Tikslas: Atvaizduoti modelius kaip įrankius su aiškiais kontraktais ir paprastu maršrutizatoriumi.

1 žingsnis) Apibrėžti įrankio sąsają ir registrą  
```python
# tools/registry.py
from dataclasses import dataclass
from typing import Callable, Dict

@dataclass
class Tool:
    name: str
    description: str
    input_schema: Dict
    output_schema: Dict
    handler: Callable[[Dict], Dict]

REGISTRY: Dict[str, Tool] = {}

def register(tool: Tool):
    REGISTRY[tool.name] = tool

def get_tool(name: str) -> Tool:
    return REGISTRY[name]
```
  
2 žingsnis) Įgyvendinti du įrankius, pagrįstus Foundry Local  
```python
# tools/impl.py
import requests, os
from tools.registry import Tool, register

BASE_URL = os.getenv("OPENAI_BASE_URL", "http://localhost:8000/v1")
API_KEY = os.getenv("OPENAI_API_KEY", "local-key")
HEADERS = {"Content-Type": "application/json", "Authorization": f"Bearer {API_KEY}"}

# Chat tool (general assistant)

def chat_handler(payload: dict) -> dict:
    model = payload.get("model", "phi-4-mini")
    messages = payload.get("messages", [{"role":"user","content":"Hello"}])
    r = requests.post(f"{BASE_URL}/chat/completions", json={
        "model": model,
        "messages": messages,
        "max_tokens": payload.get("max_tokens", 300),
        "temperature": payload.get("temperature", 0.6)
    }, headers=HEADERS, timeout=60)
    r.raise_for_status()
    msg = r.json()["choices"][0]["message"]["content"]
    return {"content": msg}

register(Tool(
    name="chat.assistant",
    description="General chat assistant",
    input_schema={"type":"object","properties":{"messages":{"type":"array"}}},
    output_schema={"type":"object","properties":{"content":{"type":"string"}}},
    handler=chat_handler
))

# Summarizer tool

def summarize_handler(payload: dict) -> dict:
    model = payload.get("model", "phi-4-mini")
    text = payload.get("text", "")
    messages = [
        {"role":"system","content":"You summarize text into 3 concise bullet points."},
        {"role":"user","content": f"Summarize:\n{text}"}
    ]
    r = requests.post(f"{BASE_URL}/chat/completions", json={
        "model": model,
        "messages": messages,
        "max_tokens": 200,
        "temperature": 0.2
    }, headers=HEADERS, timeout=60)
    r.raise_for_status()
    return {"summary": r.json()["choices"][0]["message"]["content"]}

register(Tool(
    name="text.summarize",
    description="Summarize text into bullets",
    input_schema={"type":"object","properties":{"text":{"type":"string"}}},
    output_schema={"type":"object","properties":{"summary":{"type":"string"}}},
    handler=summarize_handler
))
```
  
3 žingsnis) Maršrutizatorius pagal užduotį  
```python
# tools/router.py
from tools.registry import get_tool

def route(task: str, payload: dict):
    mapping = {
        "general": "chat.assistant",
        "summarize": "text.summarize"
    }
    tool = get_tool(mapping[task])
    return tool.handler(payload)

if __name__ == "__main__":
    # Ensure: foundry model run phi-4-mini
    print(route("general", {"messages":[{"role":"user","content":"Hi!"}]}))
    print(route("summarize", {"text":"Edge AI brings models to devices for privacy and low latency."}))
```
  

## 2 dalis: SDK ir API integracija (žingsnis po žingsnio)

Tikslas: Naudoti OpenAI Python SDK su Foundry Local galiniu tašku.

1 žingsnis) Įdiegti  
```cmd
cd Module08
.\.venv\Scripts\activate
pip install openai
```
  
2 žingsnis) Konfigūruoti aplinkos kintamuosius  
```cmd
setx OPENAI_BASE_URL http://localhost:8000/v1
setx OPENAI_API_KEY local-key
```
  
3 žingsnis) Kviesti pokalbių API  
```python
# sdk_demo.py
from openai import OpenAI
import os

client = OpenAI(
    base_url=os.getenv("OPENAI_BASE_URL", "http://localhost:8000/v1"),
    api_key=os.getenv("OPENAI_API_KEY", "local-key")
)

resp = client.chat.completions.create(
    model="phi-4-mini",
    messages=[{"role": "user", "content": "Summarize edge AI in one sentence."}],
    max_tokens=64
)
print(resp.choices[0].message.content)
```
  

## 3 dalis: Domeno pritaikymas (žingsnis po žingsnio)

Tikslas: Pritaikyti išvestis domenui naudojant šablonus ir JSON schemą.

1 žingsnis) Sukurti domeno šabloną  
```python
# domain/templates.py
BUSINESS_ANALYST_SYSTEM = """
You are a senior business analyst. Provide:
1) Key insights
2) Risks
3) Next steps
Respond in valid JSON with fields: insights, risks, next_steps.
"""
```
  
2 žingsnis) Užtikrinti JSON išvestį  
```python
# domain/analyst.py
import requests, os, json

BASE_URL = os.getenv("OPENAI_BASE_URL", "http://localhost:8000/v1")
API_KEY = os.getenv("OPENAI_API_KEY", "local-key")
HEADERS = {"Content-Type":"application/json","Authorization":f"Bearer {API_KEY}"}

from domain.templates import BUSINESS_ANALYST_SYSTEM

def analyze(text: str) -> dict:
    messages = [
        {"role":"system","content": BUSINESS_ANALYST_SYSTEM},
        {"role":"user","content": f"Analyze this business text:\n{text}"}
    ]
    r = requests.post(f"{BASE_URL}/chat/completions", json={
    "model":"phi-4-mini",
        "messages": messages,
        "response_format": {"type":"json_object"},
        "temperature": 0.3
    }, headers=HEADERS, timeout=60)
    r.raise_for_status()
    # Parse JSON content
    content = r.json()["choices"][0]["message"]["content"]
    return json.loads(content)

if __name__ == "__main__":
    print(analyze("Sales dipped 12% in Q3 due to supply constraints and marketing cuts."))
```
  

## 4 dalis: Neprisijungus ir saugumo pozicija (žingsnis po žingsnio)

Tikslas: Užtikrinti privatumą ir atsparumą, kai modeliai veikia kaip įrankiai vietoje.

1 žingsnis) Iš anksto paruošti ir patikrinti vietinį galinį tašką  
```cmd
foundry model run phi-4-mini
curl http://localhost:8000/v1/models
```
  
2 žingsnis) Išvalyti įvestis  
```python
# security/sanitize.py
import re
EMAIL_RE = re.compile(r"[\w\.-]+@[\w\.-]+")
PHONE_RE = re.compile(r"\+?\d[\d\s\-]{7,}\d")

def sanitize(text: str) -> str:
    text = EMAIL_RE.sub("[REDACTED_EMAIL]", text)
    text = PHONE_RE.sub("[REDACTED_PHONE]", text)
    return text
```
  
3 žingsnis) Vietinis režimas ir žurnalavimas  
```python
# security/local_only.py
import os, json, time
LOG = os.getenv("MODELS_AS_TOOLS_LOG", "./tools_logs.jsonl")

def record(event: dict):
    with open(LOG, "a", encoding="utf-8") as f:
        f.write(json.dumps(event) + "\n")

# Usage before each call
def before_call(tool_name, payload):
    record({"ts": time.time(), "tool": tool_name, "event": "before_call"})

# After each call
def after_call(tool_name, result):
    record({"ts": time.time(), "tool": tool_name, "event": "after_call"})
```
  

## 5 dalis: Mastelio didinimas su Azure AI Foundry (žingsnis po žingsnio)

Tikslas: Atspindėti vietinius modelius su Azure galiniais taškais, kad būtų užtikrinta papildoma talpa.

1 žingsnis) Nuspręsti maršrutizavimo strategiją  
- Pirmiausia vietinis dėl privatumo/delsimo, Azure kaip atsarginis variantas klaidų ar didelių užklausų atveju  

2 žingsnis) Įgyvendinti paprastą maršrutizatoriaus stubą  
```python
# hybrid/router.py
import os, requests

LOCAL_BASE = os.getenv("OPENAI_BASE_URL", "http://localhost:8000/v1")
AZURE_BASE = os.getenv("AZURE_FOUNDRY_BASE_URL", "")  # set to your project endpoint
API_KEY = os.getenv("OPENAI_API_KEY", "local-key")
AZURE_KEY = os.getenv("AZURE_FOUNDRY_API_KEY", "")

HEADERS_LOCAL = {"Content-Type":"application/json","Authorization":f"Bearer {API_KEY}"}
HEADERS_AZURE = {"Content-Type":"application/json","Authorization":f"Bearer {AZURE_KEY}"}

def chat_local(payload: dict):
    r = requests.post(f"{LOCAL_BASE}/chat/completions", json=payload, headers=HEADERS_LOCAL, timeout=60)
    r.raise_for_status()
    return r.json()

def chat_azure(payload: dict):
    if not AZURE_BASE:
        raise RuntimeError("Azure base URL not configured")
    r = requests.post(f"{AZURE_BASE}/chat/completions", json=payload, headers=HEADERS_AZURE, timeout=60)
    r.raise_for_status()
    return r.json()

def hybrid_chat(messages, prefer_local=True):
    payload = {"model":"phi-4-mini", "messages": messages, "max_tokens": 256}
    if prefer_local:
        try:
            return chat_local(payload)
        except Exception:
            return chat_azure(payload)
    else:
        try:
            return chat_azure(payload)
        except Exception:
            return chat_local(payload)

if __name__ == "__main__":
    # Ensure local model is running
    print(hybrid_chat([{"role":"user","content":"Hello from hybrid router!"}]))
```
  

## Praktinių užduočių kontrolinis sąrašas
- [ ] Užregistruoti bent du įrankius ir nukreipti užklausas  
- [ ] Kviesti Foundry Local per OpenAI SDK ir tiesioginį REST  
- [ ] Užtikrinti JSON išvestis domeno šablonui  
- [ ] Išvalyti ir žurnalizuoti vietines užklausas  
- [ ] Įgyvendinti paprastą hibridinį maršrutizatorių su Azure atsarginiu variantu  

## Apibendrinimas

Foundry Local suteikia galimybę naudoti patikimą AI įrenginyje, kur modeliai tampa sudedamaisiais įrankiais. Aiškios sąsajos, valdymas ir hibridinis mastelis leidžia komandoms kurti realaus laiko, saugias AI programas, kurios gerbia vartotojų privatumą ir yra pasirengusios verslui.

---

