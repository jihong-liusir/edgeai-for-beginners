<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-09-18T12:21:02+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "nl"
}
-->
# Sectie02: Functieaanroepen in Kleine Taalmodellen (SLMs)

## Inhoudsopgave
1. [Wat is Functieaanroepen?](../../../Module06)
2. [Hoe Functieaanroepen Werkt](../../../Module06)
3. [Toepassingsscenario's](../../../Module06)
4. [Functieaanroepen instellen met Phi-4-mini en Ollama](../../../Module06)
5. [Werken met Qwen3 Functieaanroepen](../../../Module06)
6. [Foundry Lokale Integratie](../../../Module06)
7. [Best Practices en Probleemoplossing](../../../Module06)
8. [Geavanceerde Voorbeelden](../../../Module06)

## Wat is Functieaanroepen?

Functieaanroepen is een krachtige mogelijkheid waarmee Kleine Taalmodellen (SLMs) kunnen communiceren met externe tools, API's en diensten. In plaats van beperkt te zijn tot hun trainingsdata, kunnen SLMs nu:

- **Verbinden met externe API's** (weerdiensten, databases, zoekmachines)
- **Specifieke functies uitvoeren** op basis van gebruikersverzoeken
- **Realtime informatie ophalen** uit verschillende bronnen
- **Rekenkundige taken uitvoeren** via gespecialiseerde tools
- **Meerdere operaties combineren** voor complexe workflows

Deze mogelijkheid transformeert SLMs van statische tekstgeneratoren naar dynamische AI-agenten die echte taken kunnen uitvoeren.

## Hoe Functieaanroepen Werkt

Het proces van functieaanroepen volgt een systematische workflow:

### 1. Toolintegratie
- **Externe Tools**: SLMs kunnen verbinding maken met weer-API's, databases, webservices en andere externe systemen
- **Functiedefinities**: Elke tool wordt gedefinieerd met specifieke parameters, input/output-formaten en beschrijvingen
- **API-compatibiliteit**: Tools worden geïntegreerd via gestandaardiseerde interfaces (REST API's, SDK's, enz.)

### 2. Functiedefinitie
Functies worden gedefinieerd met drie kerncomponenten:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. Intentiedetectie
- **Natuurlijke Taalverwerking**: Het SLM analyseert gebruikersinvoer om de intentie te begrijpen
- **Functietoewijzing**: Bepaalt welke functie(s) nodig zijn om aan het verzoek te voldoen
- **Parameterextractie**: Identificeert en haalt vereiste parameters uit het bericht van de gebruiker

### 4. JSON-uitvoergeneratie
Het SLM genereert gestructureerde JSON met:
- De naam van de aan te roepen functie
- Vereiste parameters met de juiste waarden
- Uitvoeringscontext en metadata

### 5. Externe Uitvoering
- **Parametervalidatie**: Controleert of alle vereiste parameters aanwezig en correct geformatteerd zijn
- **Functie-uitvoering**: De applicatie voert de gespecificeerde functie uit met de opgegeven parameters
- **Foutafhandeling**: Beheert fouten, time-outs en ongeldige reacties

### 6. Responsintegratie
- **Resultaatverwerking**: De uitvoer van de functie wordt teruggestuurd naar het SLM
- **Contextintegratie**: Het SLM verwerkt de resultaten in zijn antwoord
- **Gebruikerscommunicatie**: Presenteert de informatie in een natuurlijke, conversatiegerichte vorm

## Toepassingsscenario's

### Gegevensopvraging
Zet natuurlijke taalvragen om in gestructureerde API-aanroepen:
- **"Toon mijn recente bestellingen"** → Databasequery met gebruikers-ID en datumfilters
- **"Wat is het weer in Tokio?"** → Weer-API-aanroep met locatieparameter
- **"Vind e-mails van John van vorige week"** → E-mailservicequery met afzender- en datumfilters

### Uitvoering van Operaties
Zet gebruikersverzoeken om in specifieke functieaanroepen:
- **"Plan een vergadering voor morgen om 14:00 uur"** → Kalender-API-integratie
- **"Stuur een bericht naar het team"** → Communicatieplatform-API
- **"Maak een back-up van mijn bestanden"** → Bestandsysteemoperatie

### Rekenkundige Taken
Behandel complexe wiskundige of logische operaties:
- **"Bereken samengestelde rente over $10.000 tegen 5% voor 10 jaar"** → Financiële berekeningsfunctie
- **"Analyseer deze dataset op trends"** → Statistische analysetools
- **"Optimaliseer deze route voor bezorging"** → Route-optimalisatiealgoritmen

### Gegevensverwerkingsworkflows
Combineer meerdere functieaanroepen voor complexe operaties:
1. **Gegevens ophalen** uit meerdere bronnen
2. **Informatie parseren en valideren**
3. **Gegevens transformeren** naar het vereiste formaat
4. **Resultaten opslaan** in geschikte systemen
5. **Rapporten of visualisaties genereren**

### UI/UX-integratie
Maak dynamische interface-updates mogelijk:
- **"Toon verkoopgegevens op het dashboard"** → Grafiekgeneratie en weergave
- **"Werk de kaart bij met nieuwe locaties"** → Geospatiale gegevensintegratie
- **"Ververs de voorraadweergave"** → Realtime gegevenssynchronisatie

## Functieaanroepen instellen met Phi-4-mini en Ollama

Microsoft's Phi-4-mini ondersteunt zowel enkelvoudige als parallelle functieaanroepen via Ollama. Hier leest u hoe u dit instelt:

### Vereisten
- Ollama versie 0.5.13 of hoger
- Phi-4-mini model (aanbevolen: `phi4-mini:3.8b-fp16`)

### Installatiestappen

#### 1. Installeer en Voer Phi-4-mini uit
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. Maak een Aangepast ModelFile Sjabloon
Vanwege huidige beperkingen in Ollama's standaard sjablonen, moet u een aangepast ModelFile maken met het volgende sjabloon:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. Maak het Aangepaste Model
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### Voorbeeld van Enkelvoudige Functieaanroep

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### Voorbeeld van Parallelle Functieaanroep

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## Werken met Qwen3 Functieaanroepen

Qwen3 biedt geavanceerde functieaanroepmogelijkheden met uitstekende prestaties en flexibiliteit. Hier leest u hoe u dit implementeert:

### Gebruik van het Qwen-Agent Framework

Qwen-Agent biedt een hoogwaardig framework dat de implementatie van functieaanroepen vereenvoudigt:

#### Installatie
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### Basisinstelling

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### Aangepaste Functie-implementatie

U kunt ook aangepaste functies definiëren voor Qwen3:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### Geavanceerde Qwen3-functies

#### Controle over Denkmodus
Qwen3 ondersteunt dynamisch schakelen tussen denk- en niet-denkmodi:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### Meerdere Functieaanroepen in Stappen
Qwen3 blinkt uit in het combineren van meerdere functieaanroepen:

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## Foundry Lokale Integratie

Microsoft's Foundry Local biedt een OpenAI-compatibele API voor het lokaal uitvoeren van modellen met verbeterde privacy en prestaties.

### Installatie en Configuratie

#### Windows
Download de installer van de [Foundry Local releases-pagina](https://github.com/microsoft/Foundry-Local/releases) en volg de installatie-instructies.

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### Basisgebruik

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### Geavanceerde Foundry Local-functies

#### Modelbeheer
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### Prestatieoptimalisatie
Foundry Local selecteert automatisch de beste modelvariant voor uw hardware:
- **CUDA GPU**: Downloadt GPU-geoptimaliseerde modellen
- **Qualcomm NPU**: Gebruikt NPU-versnelling
- **Alleen CPU**: Selecteert CPU-geoptimaliseerde modellen

## Best Practices en Probleemoplossing

### Best Practices voor Functiedefinitie

#### 1. Duidelijke en Beschrijvende Namen
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. Uitgebreide Parameterdefinities
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. Invoervalidatie en Foutafhandeling
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### Veelvoorkomende Problemen en Oplossingen

#### Probleem 1: Functie Wordt Niet Aangeroepen
**Symptomen**: Model reageert met tekst in plaats van de functie aan te roepen

**Oplossingen**:
1. **Controleer functiebeschrijving**: Zorg ervoor dat deze duidelijk overeenkomt met de intentie van de gebruiker
2. **Controleer parameterdefinities**: Zorg ervoor dat alle vereiste parameters correct zijn gedefinieerd
3. **Controleer systeemprompt**: Voeg duidelijke instructies toe over wanneer functies moeten worden gebruikt
4. **Test met expliciete verzoeken**: Probeer "Gebruik de weerfunctie om gegevens voor Londen op te halen"

#### Probleem 2: Onjuiste Parameters
**Symptomen**: Functie wordt aangeroepen met verkeerde of ontbrekende parameters

**Oplossingen**:
1. **Voeg parametervoorbeelden toe**: Neem voorbeeldwaarden op in parameterbeschrijvingen
2. **Gebruik enum-beperkingen**: Beperk parameterwaarden tot specifieke opties waar mogelijk
3. **Implementeer standaardwaarden**: Voorzie redelijke standaardwaarden voor optionele parameters

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### Probleem 3: Fouten bij Parallelle Functieaanroepen
**Symptomen**: Slechts één functie wordt uitgevoerd wanneer meerdere zouden moeten worden uitgevoerd

**Oplossingen**:
1. **Controleer modelondersteuning**: Zorg ervoor dat uw model parallelle functieaanroepen ondersteunt
2. **Werk systeemprompt bij**: Voeg "sommige tools" of "meerdere tools" toe aan het systeembericht
3. **Gebruik geschikte modelversies**: Phi-4-mini:3.8b-fp16 aanbevolen voor Ollama

#### Probleem 4: Sjabloonproblemen met Ollama
**Symptomen**: Functieaanroepen werken niet met de standaard Ollama-configuratie

**Oplossingen**:
1. **Gebruik aangepast ModelFile**: Pas het gecorrigeerde sjabloon toe dat in deze handleiding wordt verstrekt
2. **Werk Ollama bij**: Zorg ervoor dat u versie 0.5.13 of hoger gebruikt
3. **Controleer modelkwantisatie**: Hogere kwantisatieniveaus (Q8_0, fp16) werken beter dan sterk gekwantiseerde versies

### Prestatieoptimalisatie

#### 1. Efficiënt Functieontwerp
- **Houd functies gericht**: Elke functie moet één duidelijk doel hebben
- **Minimaliseer externe afhankelijkheden**: Verminder API-aanroepen en netwerkverzoeken waar mogelijk
- **Cache resultaten**: Sla vaak opgevraagde gegevens op om responstijden te verbeteren

#### 2. Batchverwerking en Asynchrone Operaties
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. Beheer van Middelen
- **Verbindingspooling**: Hergebruik database- en API-verbindingen
- **Rate limiting**: Implementeer een juiste rate limiting voor externe API's
- **Timeoutbeheer**: Stel redelijke time-outs in voor alle externe aanroepen

## Geavanceerde Voorbeelden

### Samenwerkend Multi-Agent Systeem

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### Dynamisch Toolselectiesysteem

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```python
import asyncio
import json
from typing import Dict, List, Any
from dataclasses import dataclass
from datetime import datetime

@dataclass
class FunctionResult:
    """Standaardresultaatformaat voor alle functieaanroepen"""
    success: bool
    data: Any = None
    error: str = None
    execution_time: float = 0.0
    timestamp: datetime = None

class EnterpriseAIAgent:
    """Productieklaar AI-agent met uitgebreide functieaanroepmogelijkheden"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.functions = {}
        self.audit_log = []
        self.rate_limiters = {}
        
        # Kernfuncties initialiseren
        self._register_core_functions()
    
    def _register_core_functions(self):
        """Registreer alle beschikbare kernfuncties"""
        
        # CRM-functies
        self.register_function(
            name="get_customer_info",
            description="Klantinformatie ophalen uit CRM",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "include_history": {"type": "boolean", "default": False}
            },
            handler=self._get_customer_info,
            rate_limit=100  # oproepen per minuut
        )
        
        # Verkoopfuncties
        self.register_function(
            name="create_sales_opportunity",
            description="Nieuwe verkoopkans creëren",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "product_id": {"type": "string", "required": True},
                "estimated_value": {"type": "number", "required": True},
                "expected_close_date": {"type": "string", "required": True}
            },
            handler=self._create_sales_opportunity,
            rate_limit=50
        )
        
        # Analysefuncties
        self.register_function(
            name="generate_sales_report",
            description="Verkoopprestatierapport genereren",
            parameters={
                "period": {"type": "string", "enum": ["daily", "weekly", "monthly", "quarterly"]},
                "region": {"type": "string", "required": False},
                "product_category": {"type": "string", "required": False}
            },
            handler=self._generate_sales_report,
            rate_limit=10
        )
        
        # Notificatiefuncties
        self.register_function(
            name="send_notification",
            description="Notificatie sturen naar teamleden",
            parameters={
                "recipients": {"type": "array", "items": {"type": "string"}},
                "message": {"type": "string", "required": True},
                "priority": {"type": "string", "enum": ["low", "medium", "high"], "default": "medium"},
                "channel": {"type": "string", "enum": ["email", "slack", "teams"], "default": "email"}
            },
            handler=self._send_notification,
            rate_limit=200
        )
    
    def register_function(self, name: str, description: str, parameters: Dict, 
                         handler: callable, rate_limit: int = 60):
        """Registreer een nieuwe functie bij de agent"""
        self.functions[name] = {
            'description': description,
            'parameters': parameters,
            'handler': handler,
            'rate_limit': rate_limit,
            'call_count': 0,
            'last_reset': datetime.now()
        }
    
    async def execute_function(self, function_name: str, parameters: Dict) -
It seems you've provided instructions for translating a markdown file, but I don't see the actual content of the file you'd like translated. Could you please share the text you'd like me to translate?
"""Voer een functie uit met uitgebreide foutafhandeling en logging"""
starttijd = datetime.now()

try:
    # Controleer of de functie bestaat
    if function_name not in self.functions:
        return FunctionResult(
            success=False,
            error=f"Functie '{function_name}' niet gevonden",
            timestamp=starttijd
        )
    
    # Controleer op limieten
    if not self._check_rate_limit(function_name):
        return FunctionResult(
            success=False,
            error=f"Limiet overschreden voor functie '{function_name}'",
            timestamp=starttijd
        )
    
    # Valideer parameters
    validation_result = self._validate_parameters(function_name, parameters)
    if not validation_result.success:
        return validation_result
    
    # Voer de functie uit
    func_info = self.functions[function_name]
    handler = func_info['handler']
    
    if asyncio.iscoroutinefunction(handler):
        result_data = await handler(**parameters)
    else:
        result_data = handler(**parameters)
    
    uitvoeringstijd = (datetime.now() - starttijd).total_seconds()
    
    result = FunctionResult(
        success=True,
        data=result_data,
        execution_time=uitvoeringstijd,
        timestamp=starttijd
    )
    
    # Log succesvolle uitvoering
    self._log_function_call(function_name, parameters, result)
    
    return result
    
except Exception as e:
    uitvoeringstijd = (datetime.now() - starttijd).total_seconds()
    result = FunctionResult(
        success=False,
        error=str(e),
        execution_time=uitvoeringstijd,
        timestamp=starttijd
    )
    
    # Log mislukte uitvoering
    self._log_function_call(function_name, parameters, result)
    
    return result

def _check_rate_limit(self, function_name: str) -> bool:
    """Controleer of de functie binnen de limieten wordt aangeroepen"""
    func_info = self.functions[function_name]
    nu = datetime.now()
    
    # Reset teller als er een minuut is verstreken
    if (nu - func_info['last_reset']).seconds >= 60:
        func_info['call_count'] = 0
        func_info['last_reset'] = nu
    
    # Controleer of het onder de limiet is
    if func_info['call_count'] >= func_info['rate_limit']:
        return False
    
    func_info['call_count'] += 1
    return True

def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
    """Valideer functieparameters"""
    func_params = self.functions[function_name]['parameters']
    
    # Controleer vereiste parameters
    for param_name, param_info in func_params.items():
        if param_info.get('required', False) and param_name not in parameters:
            return FunctionResult(
                success=False,
                error=f"Ontbrekende vereiste parameter: {param_name}"
            )
    
    # Valideer parameter types en beperkingen
    for param_name, value in parameters.items():
        if param_name in func_params:
            param_info = func_params[param_name]
            
            # Typevalidatie
            expected_type = param_info.get('type')
            if expected_type == 'string' and not isinstance(value, str):
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' moet een string zijn"
                )
            elif expected_type == 'number' and not isinstance(value, (int, float)):
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' moet een getal zijn"
                )
            elif expected_type == 'boolean' and not isinstance(value, bool):
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' moet een boolean zijn"
                )
            
            # Enumvalidatie
            if 'enum' in param_info and value not in param_info['enum']:
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' moet een van de volgende zijn: {param_info['enum']}"
                )
    
    return FunctionResult(success=True)

def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):
    """Log functieaanroep voor auditdoeleinden"""
    log_entry = {
        'timestamp': result.timestamp.isoformat(),
        'function_name': function_name,
        'parameters': parameters,
        'success': result.success,
        'execution_time': result.execution_time,
        'error': result.error if not result.success else None
    }
    
    self.audit_log.append(log_entry)
    
    # Optioneel schrijven naar extern loggingsysteem
    if self.config.get('enable_external_logging', False):
        self._write_to_external_log(log_entry)

def _write_to_external_log(self, log_entry: Dict):
    """Schrijf logboekvermelding naar extern loggingsysteem"""
    # Implementatie hangt af van je loggingsinfrastructuur
    # Bijvoorbeeld, verzenden naar ELK-stack, CloudWatch, etc.
    pass

# Implementaties van bedrijfsfuncties
async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
    """Haal klantinformatie op uit het CRM-systeem"""
    # Simuleer database-/API-aanroep
    await asyncio.sleep(0.1)  # Simuleer netwerkvertraging
    
    klantgegevens = {
        'customer_id': customer_id,
        'name': 'John Doe',
        'email': 'john.doe@example.com',
        'phone': '+1-555-0123',
        'status': 'actief',
        'tier': 'premium'
    }
    
    if include_history:
        klantgegevens['purchase_history'] = [
            {'date': '2024-01-15', 'product': 'Product A', 'amount': 1500},
            {'date': '2024-03-22', 'product': 'Product B', 'amount': 2300}
        ]
    
    return klantgegevens

async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                    estimated_value: float, expected_close_date: str) -> Dict:
    """Creëer een nieuwe verkoopkans"""
    # Simuleer CRM-API-aanroep
    await asyncio.sleep(0.2)
    
    opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'opportunity_id': opportunity_id,
        'customer_id': customer_id,
        'product_id': product_id,
        'estimated_value': estimated_value,
        'expected_close_date': expected_close_date,
        'status': 'open',
        'created_date': datetime.now().isoformat()
    }

async def _generate_sales_report(self, period: str, region: str = None, 
                                 product_category: str = None) -> Dict:
    """Genereer uitgebreide verkooprapportage"""
    # Simuleer data-aggregatie
    await asyncio.sleep(0.5)
    
    return {
        'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
        'period': period,
        'region': region,
        'product_category': product_category,
        'total_sales': 125000.00,
        'total_opportunities': 45,
        'conversion_rate': 0.67,
        'top_products': [
            {'product_id': 'PROD-001', 'sales': 45000},
            {'product_id': 'PROD-002', 'sales': 32000}
        ],
        'generated_at': datetime.now().isoformat()
    }

async def _send_notification(self, recipients: List[str], message: str, 
                             priority: str = 'medium', channel: str = 'email') -> Dict:
    """Verstuur notificatie via het opgegeven kanaal"""
    # Simuleer notificatieservice-aanroep
    await asyncio.sleep(0.1)
    
    notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'notification_id': notification_id,
        'recipients': recipients,
        'channel': channel,
        'priority': priority,
        'status': 'verzonden',
        'sent_at': datetime.now().isoformat()
    }

def get_function_definitions(self) -> List[Dict]:
    """Haal OpenAI-compatibele functiedefinities op voor alle geregistreerde functies"""
    definities = []
    
    for func_name, func_info in self.functions.items():
        definitie = {
            'name': func_name,
            'description': func_info['description'],
            'parameters': {
                'type': 'object',
                'properties': {},
                'required': []
            }
        }
        
        for param_name, param_info in func_info['parameters'].items():
            definitie['parameters']['properties'][param_name] = {
                'type': param_info['type'],
                'description': param_info.get('description', '')
            }
            
            if 'enum' in param_info:
                definitie['parameters']['properties'][param_name]['enum'] = param_info['enum']
            
            if 'default' in param_info:
                definitie['parameters']['properties'][param_name]['default'] = param_info['default']
            
            if param_info.get('required', False):
                definitie['parameters']['required'].append(param_name)
        
        definities.append(definitie)
    
    return definities

# Voorbeeldgebruik voor bedrijfsintegratie
async def enterprise_demo():
    """Demonstreer mogelijkheden van een bedrijfs-AI-agent"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # Voorbeeld 1: Verwerking van klantvragen
    print("=== Verwerking van klantvragen ===")
    
    # Haal klantinformatie op
    result = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    if result.success:
        print(f"Klantinformatie opgehaald: {result.data['name']}")
        print(f"Uitvoeringstijd: {result.execution_time:.3f}s")
    
    # Voorbeeld 2: Creëren van verkoopkansen
    print("\n=== Creëren van verkoopkansen ===")
    
    result = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    if result.success:
        print(f"Kans gecreëerd: {result.data['opportunity_id']}")
    
    # Voorbeeld 3: Batchoperaties
    print("\n=== Batchoperaties ===")
    
    taken = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': 'Nieuwe kans gecreëerd',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    resultaten = await asyncio.gather(*taken)
    
    for i, result in enumerate(resultaten):
        if result.success:
            print(f"Taak {i+1} succesvol voltooid")
        else:
            print(f"Taak {i+1} mislukt: {result.error}")
    
    # Toon auditlogboek
    print(f"\n=== Auditlogboek ({len(agent.audit_log)} vermeldingen) ===")
    for entry in agent.audit_log[-3:]:  # Toon de laatste 3 vermeldingen
        print(f"{entry['timestamp']}: {entry['function_name']} - {'SUCCES' if entry['success'] else 'MISLUKT'}")

# Voer de bedrijfsdemo uit
# asyncio.run(enterprise_demo())

## Conclusie

Functieaanroepen in Small Language Models vertegenwoordigen een paradigmaverschuiving van statische AI-assistenten naar dynamische, capabele agenten die met de echte wereld kunnen communiceren. Deze tutorial heeft behandeld:

### Belangrijke inzichten

1. **Basisbegrip**: Functieaanroepen stellen SLM's in staat om verder te gaan dan hun trainingsdata door verbinding te maken met externe tools en diensten.

2. **Implementatieflexibiliteit**: Er bestaan meerdere benaderingen, van low-level implementaties met aangepaste templates tot high-level frameworks zoals Qwen-Agent en Foundry Local.

3. **Overwegingen voor productie**: Bedrijfsimplementaties vereisen aandacht voor foutafhandeling, limieten, beveiliging en auditlogging.

4. **Prestatieoptimalisatie**: Goede functiedesign, efficiënte uitvoering en slimme caching kunnen de responstijden aanzienlijk verbeteren.

### Toekomstige richtingen

Naarmate SLM-technologie zich blijft ontwikkelen, kunnen we verwachten:

- **Verbeterde nauwkeurigheid van functieaanroepen**: Betere intentiedetectie en parameterextractie
- **Geavanceerdere parallelle verwerking**: Meer verfijnde multi-functie orkestratie
- **Betere integratiestandaarden**: Gestandaardiseerde protocollen voor toolintegratie
- **Geavanceerde beveiligingsfuncties**: Verbeterde authenticatie- en autorisatiemechanismen
- **Uitgebreid ecosysteem**: Groeiende bibliotheek van vooraf gebouwde functies en integraties

### Aan de slag

Om functieaanroepen in je projecten te implementeren:

1. **Begin eenvoudig**: Start met basis scenario's met één functie
2. **Kies je framework**: Kies tussen directe implementatie (Ollama/Phi-4) of framework-geassisteerd (Qwen-Agent)
3. **Ontwerp functies zorgvuldig**: Focus op duidelijke, goed gedocumenteerde functiedefinities
4. **Implementeer foutafhandeling**: Bouw robuuste foutafhandeling vanaf het begin
5. **Schaal geleidelijk**: Ga van eenvoudige naar complexe scenario's naarmate je ervaring opdoet

Functieaanroepen transformeren SLM's van indrukwekkende tekstgeneratoren naar praktische AI-agenten die echte problemen kunnen oplossen. Door de patronen en praktijken in deze tutorial te volgen, kun je krachtige, betrouwbare AI-systemen bouwen die veel verder gaan dan traditionele chatinterfaces.

### Bronnen en referenties
- **Phi-4 Modellen**: [Hugging Face Collectie](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)
- **Qwen3 Documentatie**: [Officiële Qwen Documentatie](https://qwen.readthedocs.io/)
- **Ollama**: [Officiële Website](https://ollama.com/)
- **Foundry Local**: [GitHub Repository](https://github.com/microsoft/Foundry-Local)
- **Best Practices voor Functieaanroepen**: [Hugging Face Gids](https://huggingface.co/docs/hugs/en/guides/function-calling)

Onthoud dat functieaanroepen een zich ontwikkelend vakgebied is. Door op de hoogte te blijven van de nieuwste ontwikkelingen in de door jou gekozen frameworks en modellen, kun je effectievere AI-agenten bouwen.


## ➡️ Wat is de volgende stap

- [03: Model Context Protocol (MCP) Integratie](./03.IntroduceMCP.md)

---

**Disclaimer**:  
Dit document is vertaald met behulp van de AI-vertalingsservice [Co-op Translator](https://github.com/Azure/co-op-translator). Hoewel we streven naar nauwkeurigheid, dient u zich ervan bewust te zijn dat geautomatiseerde vertalingen fouten of onnauwkeurigheden kunnen bevatten. Het originele document in zijn oorspronkelijke taal moet worden beschouwd als de gezaghebbende bron. Voor cruciale informatie wordt professionele menselijke vertaling aanbevolen. Wij zijn niet aansprakelijk voor eventuele misverstanden of verkeerde interpretaties die voortvloeien uit het gebruik van deze vertaling.