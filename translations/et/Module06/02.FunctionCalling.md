<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-10-11T11:29:29+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "et"
}
-->
# Section02 : Funktsioonide kutsumine väikestes keelemudelites (SLM-id)

## Sisukord
1. [Mis on funktsioonide kutsumine?](../../../Module06)
2. [Kuidas funktsioonide kutsumine toimib](../../../Module06)
3. [Rakenduse stsenaariumid](../../../Module06)
4. [Funktsioonide kutsumise seadistamine Phi-4-mini ja Ollama abil](../../../Module06)
5. [Töö Qwen3 funktsioonide kutsumisega](../../../Module06)
6. [Foundry Local integratsioon](../../../Module06)
7. [Parimad praktikad ja tõrkeotsing](../../../Module06)
8. [Täiustatud näited](../../../Module06)

## Mis on funktsioonide kutsumine?

Funktsioonide kutsumine on võimas võimekus, mis võimaldab väikestel keelemudelitel (SLM-id) suhelda väliste tööriistade, API-de ja teenustega. Selle asemel, et piirduda ainult treeningandmetega, saavad SLM-id nüüd:

- **Ühenduda väliste API-dega** (ilmateenused, andmebaasid, otsingumootorid)
- **Täita konkreetseid funktsioone** vastavalt kasutaja päringutele
- **Hankida reaalajas teavet** erinevatest allikatest
- **Teostada arvutusülesandeid** spetsiaalsete tööriistade abil
- **Siduda mitmeid operatsioone** keerukate töövoogude jaoks

See võimekus muudab SLM-id staatilistest tekstigeneraatoritest dünaamilisteks AI-agentideks, mis suudavad täita reaalseid ülesandeid.

## Kuidas funktsioonide kutsumine toimib

Funktsioonide kutsumise protsess järgib süstemaatilist töövoogu:

### 1. Tööriistade integreerimine
- **Välised tööriistad**: SLM-id saavad ühenduda ilmateenuste API-de, andmebaaside, veebiteenuste ja teiste süsteemidega
- **Funktsioonide määratlused**: Iga tööriist määratletakse konkreetsete parameetrite, sisend/väljundvormingute ja kirjeldustega
- **API ühilduvus**: Tööriistad integreeritakse standardiseeritud liideste kaudu (REST API-d, SDK-d jne)

### 2. Funktsiooni määratlemine
Funktsioonid määratletakse kolme põhikomponendiga:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. Kavatsuse tuvastamine
- **Loodusliku keele töötlemine**: SLM analüüsib kasutaja sisendit, et mõista kavatsust
- **Funktsiooni sobitamine**: Määrab, millist(eid) funktsiooni(e) on vaja päringu täitmiseks
- **Parameetrite eraldamine**: Tuvastab ja eraldab kasutaja sõnumist vajalikud parameetrid

### 4. JSON-väljundi genereerimine
SLM genereerib struktureeritud JSON-i, mis sisaldab:
- Kutsutava funktsiooni nime
- Vajalikke parameetreid koos sobivate väärtustega
- Täitmise konteksti ja metaandmeid

### 5. Väline täitmine
- **Parameetrite valideerimine**: Kontrollib, et kõik vajalikud parameetrid oleksid olemas ja õigesti vormindatud
- **Funktsiooni täitmine**: Rakendus täidab määratud funktsiooni antud parameetritega
- **Tõrkehaldus**: Haldab ebaõnnestumisi, ajapiiranguid ja valesid vastuseid

### 6. Vastuse integreerimine
- **Tulemuste töötlemine**: Funktsiooni väljund tagastatakse SLM-ile
- **Konteksti integreerimine**: SLM lisab tulemused oma vastusesse
- **Kasutajaga suhtlemine**: Esitab teabe loomulikus, vestluslikus vormis

## Rakenduse stsenaariumid

### Andmete hankimine
Muudab loodusliku keele päringud struktureeritud API-kõnedeks:
- **"Näita minu hiljutisi tellimusi"** → Andmebaasi päring kasutaja ID ja kuupäevafiltritega
- **"Mis on Tokyo ilm?"** → Ilmateenuse API-kõne asukoha parameetriga
- **"Leia e-kirjad Johnilt eelmisel nädalal"** → E-posti teenuse päring saatja ja kuupäevafiltritega

### Operatsioonide täitmine
Muudab kasutaja päringud konkreetseteks funktsioonikõnedeks:
- **"Planeeri kohtumine homseks kell 14:00"** → Kalendri API integratsioon
- **"Saada sõnum meeskonnale"** → Kommunikatsiooniplatvormi API
- **"Loo minu failidest varukoopia"** → Failisüsteemi operatsioon

### Arvutusülesanded
Teostab keerukaid matemaatilisi või loogilisi operatsioone:
- **"Arvuta liitintress $10,000-le 5% juures 10 aasta jooksul"** → Finantsarvutuse funktsioon
- **"Analüüsi seda andmekogumit trendide jaoks"** → Statistilise analüüsi tööriistad
- **"Optimeeri see marsruut kohaletoimetamiseks"** → Marsruudi optimeerimise algoritmid

### Andmetöötluse töövood
Siduda mitmeid funktsioonikõnesid keerukate operatsioonide jaoks:
1. **Hangi andmed** mitmest allikast
2. **Parsi ja valideeri** teave
3. **Transformeeri** andmed vajalikku vormingusse
4. **Salvesta tulemused** sobivatesse süsteemidesse
5. **Loo aruandeid** või visualisatsioone

### UI/UX integratsioon
Võimaldab dünaamilisi liidese uuendusi:
- **"Näita müügiandmeid armatuurlaual"** → Diagrammi genereerimine ja kuvamine
- **"Uuenda kaarti uute asukohtadega"** → Georuumiliste andmete integratsioon
- **"Värskenda inventari kuvamist"** → Reaalajas andmete sünkroniseerimine

## Funktsioonide kutsumise seadistamine Phi-4-mini ja Ollama abil

Microsofti Phi-4-mini toetab nii üksik- kui ka paralleelset funktsioonide kutsumist Ollama kaudu. Siin on, kuidas seda seadistada:

### Eeltingimused
- Ollama versioon 0.5.13 või uuem
- Phi-4-mini mudel (soovitatav: `phi4-mini:3.8b-fp16`)

### Paigaldamise sammud

#### 1. Paigalda ja käivita Phi-4-mini
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. Loo kohandatud ModelFile mall
Praeguste piirangute tõttu Ollama vaikemallides peate looma kohandatud ModelFile järgmise malliga:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. Loo kohandatud mudel
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### Ühe funktsiooni kutsumise näide

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### Paralleelse funktsiooni kutsumise näide

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## Töö Qwen3 funktsioonide kutsumisega

Qwen3 pakub täiustatud funktsioonide kutsumise võimalusi suurepärase jõudluse ja paindlikkusega. Siin on, kuidas seda rakendada:

### Qwen-Agent raamistikuga töötamine

Qwen-Agent pakub kõrgetasemelist raamistikku, mis lihtsustab funktsioonide kutsumise rakendamist:

#### Paigaldamine
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### Põhiseadistus

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### Kohandatud funktsiooni rakendamine

Samuti saate Qwen3 jaoks määratleda kohandatud funktsioone:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### Täiustatud Qwen3 funktsioonid

#### Mõtlemisrežiimi juhtimine
Qwen3 toetab dünaamilist vahetust mõtlemise ja mitte-mõtlemise režiimide vahel:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### Mitmeastmeline funktsioonide kutsumine
Qwen3 paistab silma mitme funktsiooni järjestikuse kutsumisega:

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## Foundry Local integratsioon

Microsofti Foundry Local pakub OpenAI-ga ühilduvat API-d mudelite lokaalseks käitamiseks, pakkudes paremat privaatsust ja jõudlust.

### Seadistamine ja paigaldamine

#### Windows
Laadige installer alla [Foundry Locali väljalaske lehelt](https://github.com/microsoft/Foundry-Local/releases) ja järgige paigaldusjuhiseid.

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### Põhikasutus

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### Täiustatud Foundry Local funktsioonid

#### Mudelite haldamine
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### Jõudluse optimeerimine
Foundry Local valib automaatselt teie riistvarale parima mudelivariandi:
- **CUDA GPU**: Laadib GPU jaoks optimeeritud mudelid
- **Qualcomm NPU**: Kasutab NPU-kiirendatud variante
- **Ainult CPU**: Valib CPU jaoks optimeeritud mudelid

## Parimad praktikad ja tõrkeotsing

### Funktsioonide määratlemise parimad praktikad

#### 1. Selge ja kirjeldav nimetamine
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. Põhjalikud parameetrite määratlused
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. Sisendi valideerimine ja tõrkehaldus
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### Levinud probleemid ja lahendused

#### Probleem 1: Funktsiooni ei kutsuta
**Sümptomid**: Mudel vastab tekstiga, selle asemel et kutsuda funktsiooni

**Lahendused**:
1. **Kontrollige funktsiooni kirjeldust**: Veenduge, et see vastaks selgelt kasutaja kavatsusele
2. **Kinnitage parameetrite määratlused**: Veenduge, et kõik vajalikud parameetrid oleksid õigesti määratletud
3. **Vaadake üle süsteemi käsk**: Lisage selged juhised, millal funktsioone kasutada
4. **Testige selgete päringutega**: Proovige "Palun kasutage ilmateenuse funktsiooni, et saada andmeid Londoni kohta"

#### Probleem 2: Valed parameetrid
**Sümptomid**: Funktsiooni kutsutakse valede või puuduvate parameetritega

**Lahendused**:
1. **Lisage parameetrite näited**: Kaasake näidisväärtused parameetrite kirjeldustesse
2. **Kasutage enum-piiranguid**: Piirake parameetrite väärtusi konkreetsete valikutega, kui võimalik
3. **Rakendage varuväärtusi**: Pakkuge mõistlikke vaikeväärtusi valikulistele parameetritele

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### Probleem 3: Paralleelse funktsiooni kutsumise ebaõnnestumised
**Sümptomid**: Täidetakse ainult üks funktsioon, kui mitu peaksid töötama

**Lahendused**:
1. **Kontrollige mudeli tuge**: Veenduge, et teie mudel toetab paralleelset funktsioonide kutsumist
2. **Uuendage süsteemi käsku**: Lisage "mõned tööriistad" või "mitu tööriista" süsteemi sõnumisse
3. **Kasutage sobivaid mudeliversioone**: Phi-4-mini:3.8b-fp16 on soovitatav Ollama jaoks

#### Probleem 4: Malliprobleemid Ollama puhul
**Sümptomid**: Funktsioonide kutsumine ei tööta Ollama vaikeseadistusega

**Lahendused**:
1. **Kasutage kohandatud ModelFile'i**: Rakendage selles juhendis pakutud parandatud malli
2. **Uuendage Ollama**: Veenduge, et kasutate versiooni 0.5.13 või uuemat
3. **Kontrollige mudeli kvantiseerimist**: Kõrgemad kvantiseerimistasemed (Q8_0, fp16) töötavad paremini kui tugevalt kvantiseeritud versioonid

### Jõudluse optimeerimine

#### 1. Tõhus funktsioonide disain
- **Hoidke funktsioonid keskendunud**: Iga funktsioon peaks omama ühte selget eesmärki
- **Minimeerige väliseid sõltuvusi**: Vähendage API-kõnesid ja võrgu päringuid, kui võimalik
- **Vahemälu tulemused**: Salvestage sageli nõutud andmed, et parandada vastuse kiirust

#### 2. Partii- ja asünkroonsed operatsioonid
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. Ressursside haldamine
- **Ühenduste jagamine**: Taaskasutage andmebaasi ja API-ühendusi
- **Kiiruse piiramine**: Rakendage väliste API-de jaoks sobivat kiiruse piirangut
- **Ajapiirangute haldamine**: Määrake kõigile välistele kõnedele mõistlikud ajapiirangud

## Täiustatud näited

### Mitme agendi koostöösüsteem

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### Dünaamiline tööriistade valiku süsteem

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```python
import asyncio
import json
from typing import Dict, List, Any
from dataclasses import dataclass
from datetime import datetime

@dataclass
class FunctionResult:
    """Standard result format for all function calls"""
    success: bool
    data: Any = None
    error: str = None
    execution_time: float = 0.0
    timestamp: datetime = None

class EnterpriseAIAgent:
    """Production-ready AI agent with comprehensive function calling capabilities"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.functions = {}
        self.audit_log = []
        self.rate_limiters = {}
        
        # Initialize core business functions
        self._register_core_functions()
    
    def _register_core_functions(self):
        """Register all available business functions"""
        
        # CRM Functions
        self.register_function(
            name="get_customer_info",
            description="Retrieve customer information from CRM",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "include_history": {"type": "boolean", "default": False}
            },
            handler=self._get_customer_info,
            rate_limit=100  # calls per minute
        )
        
        # Sales Functions
        self.register_function(
            name="create_sales_opportunity",
            description="Create a new sales opportunity",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "product_id": {"type": "string", "required": True},
                "estimated_value": {"type": "number", "required": True},
                "expected_close_date": {"type": "string", "required": True}
            },
            handler=self._create_sales_opportunity,
            rate_limit=50
        )
        
        # Analytics Functions
        self.register_function(
            name="generate_sales_report",
            description="Generate sales performance report",
            parameters={
                "period": {"type": "string", "enum": ["daily", "weekly", "monthly", "quarterly"]},
                "region": {"type": "string", "required": False},
                "product_category": {"type": "string", "required": False}
            },
            handler=self._generate_sales_report,
            rate_limit=10
        )
        
        # Notification Functions
        self.register_function(
            name="send_notification",
            description="Send notification to team members",
            parameters={
                "recipients": {"type": "array", "items": {"type": "string"}},
                "message": {"type": "string", "required": True},
                "priority": {"type": "string", "enum": ["low", "medium", "high"], "default": "medium"},
                "channel": {"type": "string", "enum": ["email", "slack", "teams"], "default": "email"}
            },
            handler=self._send_notification,
            rate_limit=200
        )
    
    def register_function(self, name: str, description: str, parameters: Dict, 
                         handler: callable, rate_limit: int = 60):
        """Register a new function with the agent"""
        self.functions[name] = {
            'description': description,
            'parameters': parameters,
            'handler': handler,
            'rate_limit': rate_limit,
            'call_count': 0,
            'last_reset': datetime.now()
        }
    
    async def execute_function(self, function_name: str, parameters: Dict) -> FunctionResult:
        """Execute a function with comprehensive error handling and logging"""
        start_time = datetime.now()
        
        try:
            # Validate function exists
            if function_name not in self.functions:
                return FunctionResult(
                    success=False,
                    error=f"Function '{function_name}' not found",
                    timestamp=start_time
                )
            
            # Check rate limits
            if not self._check_rate_limit(function_name):
                return FunctionResult(
                    success=False,
                    error=f"Rate limit exceeded for function '{function_name}'",
                    timestamp=start_time
                )
            
            # Validate parameters
            validation_result = self._validate_parameters(function_name, parameters)
            if not validation_result.success:
                return validation_result
            
            # Execute function
            func_info = self.functions[function_name]
            handler = func_info['handler']
            
            if asyncio.iscoroutinefunction(handler):
                result_data = await handler(**parameters)
            else:
                result_data = handler(**parameters)
            
            execution_time = (datetime.now() - start_time).total_seconds()
            
            result = FunctionResult(
                success=True,
                data=result_data,
                execution_time=execution_time,
                timestamp=start_time
            )
            
            # Log successful execution
            self._log_function_call(function_name, parameters, result)
            
            return result
            
        except Exception as e:
            execution_time = (datetime.now() - start_time).total_seconds()
            result = FunctionResult(
                success=False,
                error=str(e),
                execution_time=execution_time,
                timestamp=start_time
            )
            
            # Log failed execution
            self._log_function_call(function_name, parameters, result)
            
            return result
    
    def _check_rate_limit(self, function_name: str) -> bool:
        """Check if function call is within rate limits"""
        func_info = self.functions[function_name]
        now = datetime.now()
        
        # Reset counter if a minute has passed
        if (now - func_info['last_reset']).seconds >= 60:
            func_info['call_count'] = 0
            func_info['last_reset'] = now
        
        # Check if under limit
        if func_info['call_count'] >= func_info['rate_limit']:
            return False
        
        func_info['call_count'] += 1
        return True
    
    def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
        """Validate function parameters"""
        func_params = self.functions[function_name]['parameters']
        
        # Check required parameters
        for param_name, param_info in func_params.items():
            if param_info.get('required', False) and param_name not in parameters:
                return FunctionResult(
                    success=False,
                    error=f"Missing required parameter: {param_name}"
                )
        
        # Validate parameter types and constraints
        for param_name, value in parameters.items():
            if param_name in func_params:
                param_info = func_params[param_name]
                
                # Type validation
                expected_type = param_info.get('type')
                if expected_type == 'string' and not isinstance(value, str):
                    return FunctionResult(
                        success=False,
                        error=f"Parameter '{param_name}' must be a string"
                    )
                elif expected_type == 'number' and not isinstance(value, (int, float)):
                    return FunctionResult(
                        success=False,
                        error=f"Parameter '{param_name}' must be a number"
                    )
                elif expected_type == 'boolean' and not isinstance(value, bool):
                    return FunctionResult(
                        success=False,
                        error=f"Parameter '{param_name}' must be a boolean"
                    )
                
                # Enum validation
                if 'enum' in param_info and value not in param_info['enum']:
                    return FunctionResult(
                        success=False,
                        error=f"Parameter '{param_name}' must be one of: {param_info['enum']}"
                    )
        
        return FunctionResult(success=True)
    
    def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):
        """Log function call for audit purposes"""
        log_entry = {
            'timestamp': result.timestamp.isoformat(),
            'function_name': function_name,
            'parameters': parameters,
            'success': result.success,
            'execution_time': result.execution_time,
            'error': result.error if not result.success else None
        }
        
        self.audit_log.append(log_entry)
        
        # Optionally write to external logging system
        if self.config.get('enable_external_logging', False):
            self._write_to_external_log(log_entry)
    
    def _write_to_external_log(self, log_entry: Dict):
        """Write log entry to external logging system"""
        # Implementation would depend on your logging infrastructure
        # e.g., send to ELK stack, CloudWatch, etc.
        pass
    
    # Business Function Implementations
    async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
        """Retrieve customer information from CRM system"""
        # Simulate database/API call
        await asyncio.sleep(0.1)  # Simulate network delay
        
        customer_data = {
            'customer_id': customer_id,
            'name': 'John Doe',
            'email': 'john.doe@example.com',
            'phone': '+1-555-0123',
            'status': 'active',
            'tier': 'premium'
        }
        
        if include_history:
            customer_data['purchase_history'] = [
                {'date': '2024-01-15', 'product': 'Product A', 'amount': 1500},
                {'date': '2024-03-22', 'product': 'Product B', 'amount': 2300}
            ]
        
        return customer_data
    
    async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                      estimated_value: float, expected_close_date: str) -> Dict:
        """Create a new sales opportunity"""
        # Simulate CRM API call
        await asyncio.sleep(0.2)
        
        opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
        
        return {
            'opportunity_id': opportunity_id,
            'customer_id': customer_id,
            'product_id': product_id,
            'estimated_value': estimated_value,
            'expected_close_date': expected_close_date,
            'status': 'open',
            'created_date': datetime.now().isoformat()
        }
    
    async def _generate_sales_report(self, period: str, region: str = None, 
                                   product_category: str = None) -> Dict:
        """Generate comprehensive sales report"""
        # Simulate data aggregation
        await asyncio.sleep(0.5)
        
        return {
            'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
            'period': period,
            'region': region,
            'product_category': product_category,
            'total_sales': 125000.00,
            'total_opportunities': 45,
            'conversion_rate': 0.67,
            'top_products': [
                {'product_id': 'PROD-001', 'sales': 45000},
                {'product_id': 'PROD-002', 'sales': 32000}
            ],
            'generated_at': datetime.now().isoformat()
        }
    
    async def _send_notification(self, recipients: List[str], message: str, 
                               priority: str = 'medium', channel: str = 'email') -> Dict:
        """Send notification through specified channel"""
        # Simulate notification service call
        await asyncio.sleep(0.1)
        
        notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
        
        return {
            'notification_id': notification_id,
            'recipients': recipients,
            'channel': channel,
            'priority': priority,
            'status': 'sent',
            'sent_at': datetime.now().isoformat()
        }
    
    def get_function_definitions(self) -> List[Dict]:
        """Get OpenAI-compatible function definitions for all registered functions"""
        definitions = []
        
        for func_name, func_info in self.functions.items():
            definition = {
                'name': func_name,
                'description': func_info['description'],
                'parameters': {
                    'type': 'object',
                    'properties': {},
                    'required': []
                }
            }
            
            for param_name, param_info in func_info['parameters'].items():
                definition['parameters']['properties'][param_name] = {
                    'type': param_info['type'],
                    'description': param_info.get('description', '')
                }
                
                if 'enum' in param_info:
                    definition['parameters']['properties'][param_name]['enum'] = param_info['enum']
                
                if 'default' in param_info:
                    definition['parameters']['properties'][param_name]['default'] = param_info['default']
                
                if param_info.get('required', False):
                    definition['parameters']['required'].append(param_name)
            
            definitions.append(definition)
        
        return definitions

# Usage Example for Enterprise Integration
async def enterprise_demo():
    """Demonstrate enterprise AI agent capabilities"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # Example 1: Customer inquiry processing
    print("=== Customer Inquiry Processing ===")
    
    # Get customer information
    result = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    if result.success:
        print(f"Customer Info Retrieved: {result.data['name']}")
        print(f"Execution Time: {result.execution_time:.3f}s")
    
    # Example 2: Sales opportunity creation
    print("\n=== Sales Opportunity Creation ===")
    
    result = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    if result.success:
        print(f"Opportunity Created: {result.data['opportunity_id']}")
    
    # Example 3: Batch operations
    print("\n=== Batch Operations ===")
    
    tasks = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': 'New opportunity created',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    results = await asyncio.gather(*tasks)
    
    for i, result in enumerate(results):
        if result.success:
            print(f"Task {i+1} completed successfully")
        else:
            print(f"Task {i+1} failed: {result.error}")
    
    # Display audit log
    print(f"\n=== Audit Log ({len(agent.audit_log)} entries) ===")
    for entry in agent.audit_log[-3:]:  # Show last 3 entries
        print(f"{entry['timestamp']}: {entry['function_name']} - {'SUCCESS' if entry['success'] else 'FAILED'}")

# Run the enterprise demo
# asyncio.run(enterprise_demo())
```

## Kokkuvõte

Funktsioonide kutsumine väikestes keelemudelites tähistab paradigmanihet staatilistest AI-assistentidest dünaamilisteks, võimekateks agentideks, mis suudavad suhelda reaalse maailmaga. See juhend hõlmas:

### Põhijäreldused

1. **Põhialuste mõistmine**: Funktsioonide kutsumine võimaldab SLM-idel ulatuda kaugemale treeningandmetest, ühendudes väliste tööriistade ja teenustega.

2. **Rakendamise paindlikkus**: Olemas on mitmeid lähenemisviise, alates madala taseme rakendustest kohandatud mallidega kuni kõrgetasemeliste raamistikeni nagu Qwen-Agent ja Foundry Local.

3. **Tootmise kaalutlused**: Ettevõtte juurutused nõuavad tähelepanu tõrkehaldusele, kiiruse piirangutele, turvalisusele ja auditeerimise logimisele.

4. **Jõudluse optimeerimine**: Õige funktsioonide disain, tõhus täitmine ja nutikas vahemälu kasutamine võivad oluliselt parandada vastuse kiirust.

### Tuleviku suunad

SLM-tehnoloogia arenedes võime oodata:

- **Paranenud funktsioonide kutsumise täpsust**: Parem kavatsuse tuvastamine ja parameetrite eraldamine
- **Täiustatud paralleelne töötlemine**: Keerukam mitme funktsiooni orkestreerimine
- **Paremad integratsioonistandardid**: Standardiseeritud protokollid tööriistade integreerimiseks
- **Täiustatud turvafunktsioonid**: Täiustatud autentimise ja autoriseerimise mehhanismid
- **Laiendatud ökosüsteem**: Kasvav eelseadistatud funktsioonide ja integratsioonide raamatukogu

### Alustamine

Funktsioonide kutsumise rakendamiseks oma projektides:

1. **Alusta lihtsast**: Alusta põhiliste ühe funktsiooni stsenaariumidega
2. **Vali oma raamistik**: Vali otsese rakendamise (Ollama/Phi-4) või raamistikupõhise (Qwen-Agent) vahel
3. **Disaini funktsioonid hoolikalt**: Keskendu selgetele, hästi dokumenteeritud funktsioonide määratlustele
4. **Rakenda tõrkehaldus**: Ehita algusest peale tugev tõrkehaldus
5. **Skaaleeri järk-järgult**: Liigu lihtsatest keerukate stsenaariumideni, kui kogemusi koguneb

Funktsioonide kutsumine muudab SLM-id muljetavaldavatest tekstigeneraatoritest praktilisteks AI-agentideks, mis suudavad lahendada reaalseid probleeme. Järgides selles juhendis kirjeldatud mustreid ja praktikaid, saate luua võimsaid, usaldusväärseid AI-süsteeme, mis ulatuvad kaugemale traditsioonilistest vestlusliidestest.

### Ressursid ja viited

- **Phi-4 mudelid**: [Hugging Face Collection](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)
- **Qwen3 dokumentatsioon**: [Ametlik Qwen dokumentatsioon](https://qwen.readthedocs.io/)
- **Ollama**: [Ametlik veebisait](https://ollama.com/)
- **

---

**Lahtiütlus**:  
See dokument on tõlgitud AI tõlketeenuse [Co-op Translator](https://github.com/Azure/co-op-translator) abil. Kuigi püüame tagada täpsust, palume arvestada, et automaatsed tõlked võivad sisaldada vigu või ebatäpsusi. Algne dokument selle algses keeles tuleks pidada autoriteetseks allikaks. Olulise teabe puhul soovitame kasutada professionaalset inimtõlget. Me ei vastuta selle tõlke kasutamisest tulenevate arusaamatuste või valesti tõlgenduste eest.