<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-09-18T07:14:45+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "el"
}
-->
# Section02 : Κλήση Συναρτήσεων σε Μικρά Μοντέλα Γλώσσας (SLMs)

## Πίνακας Περιεχομένων
1. [Τι είναι η Κλήση Συναρτήσεων;](../../../Module06)
2. [Πώς Λειτουργεί η Κλήση Συναρτήσεων](../../../Module06)
3. [Σενάρια Εφαρμογής](../../../Module06)
4. [Ρύθμιση Κλήσης Συναρτήσεων με Phi-4-mini και Ollama](../../../Module06)
5. [Εργασία με Κλήση Συναρτήσεων Qwen3](../../../Module06)
6. [Τοπική Ενσωμάτωση Foundry](../../../Module06)
7. [Βέλτιστες Πρακτικές και Αντιμετώπιση Προβλημάτων](../../../Module06)
8. [Προχωρημένα Παραδείγματα](../../../Module06)

## Τι είναι η Κλήση Συναρτήσεων;

Η κλήση συναρτήσεων είναι μια ισχυρή δυνατότητα που επιτρέπει στα Μικρά Μοντέλα Γλώσσας (SLMs) να αλληλεπιδρούν με εξωτερικά εργαλεία, APIs και υπηρεσίες. Αντί να περιορίζονται στα δεδομένα εκπαίδευσής τους, τα SLMs μπορούν πλέον:

- **Να συνδέονται με εξωτερικά APIs** (υπηρεσίες καιρού, βάσεις δεδομένων, μηχανές αναζήτησης)
- **Να εκτελούν συγκεκριμένες συναρτήσεις** βάσει αιτημάτων χρηστών
- **Να ανακτούν πληροφορίες σε πραγματικό χρόνο** από διάφορες πηγές
- **Να εκτελούν υπολογιστικές εργασίες** μέσω εξειδικευμένων εργαλείων
- **Να συνδυάζουν πολλαπλές λειτουργίες** για σύνθετες ροές εργασίας

Αυτή η δυνατότητα μετατρέπει τα SLMs από στατικούς δημιουργούς κειμένου σε δυναμικούς πράκτορες AI που μπορούν να εκτελούν πραγματικές εργασίες.

## Πώς Λειτουργεί η Κλήση Συναρτήσεων

Η διαδικασία κλήσης συναρτήσεων ακολουθεί μια συστηματική ροή εργασίας:

### 1. Ενσωμάτωση Εργαλείων
- **Εξωτερικά Εργαλεία**: Τα SLMs μπορούν να συνδεθούν με APIs καιρού, βάσεις δεδομένων, διαδικτυακές υπηρεσίες και άλλα εξωτερικά συστήματα
- **Ορισμοί Συναρτήσεων**: Κάθε εργαλείο ορίζεται με συγκεκριμένες παραμέτρους, μορφές εισόδου/εξόδου και περιγραφές
- **Συμβατότητα API**: Τα εργαλεία ενσωματώνονται μέσω τυποποιημένων διεπαφών (REST APIs, SDKs κ.λπ.)

### 2. Ορισμός Συναρτήσεων
Οι συναρτήσεις ορίζονται με τρία βασικά στοιχεία:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. Ανίχνευση Πρόθεσης
- **Επεξεργασία Φυσικής Γλώσσας**: Το SLM αναλύει την είσοδο του χρήστη για να κατανοήσει την πρόθεση
- **Αντιστοίχιση Συναρτήσεων**: Καθορίζει ποιες συναρτήσεις χρειάζονται για την εκπλήρωση του αιτήματος
- **Εξαγωγή Παραμέτρων**: Εντοπίζει και εξάγει τις απαιτούμενες παραμέτρους από το μήνυμα του χρήστη

### 4. Δημιουργία JSON Εξόδου
Το SLM δημιουργεί δομημένο JSON που περιέχει:
- Το όνομα της συνάρτησης που θα κληθεί
- Τις απαιτούμενες παραμέτρους με κατάλληλες τιμές
- Το πλαίσιο εκτέλεσης και μεταδεδομένα

### 5. Εξωτερική Εκτέλεση
- **Επικύρωση Παραμέτρων**: Εξασφαλίζει ότι όλες οι απαιτούμενες παράμετροι είναι παρούσες και σωστά μορφοποιημένες
- **Εκτέλεση Συνάρτησης**: Η εφαρμογή εκτελεί τη συγκεκριμένη συνάρτηση με τις παρεχόμενες παραμέτρους
- **Διαχείριση Σφαλμάτων**: Αντιμετωπίζει αποτυχίες, χρονικά όρια και μη έγκυρες απαντήσεις

### 6. Ενσωμάτωση Απάντησης
- **Επεξεργασία Αποτελεσμάτων**: Η έξοδος της συνάρτησης επιστρέφεται στο SLM
- **Ενσωμάτωση Πλαισίου**: Το SLM ενσωματώνει τα αποτελέσματα στην απάντησή του
- **Επικοινωνία με τον Χρήστη**: Παρουσιάζει τις πληροφορίες σε φυσική, συνομιλητική μορφή

## Σενάρια Εφαρμογής

### Ανάκτηση Δεδομένων
Μετατροπή ερωτημάτων φυσικής γλώσσας σε δομημένες κλήσεις API:
- **"Δείξε μου τις πρόσφατες παραγγελίες μου"** → Ερώτημα βάσης δεδομένων με ID χρήστη και φίλτρα ημερομηνίας
- **"Ποιος είναι ο καιρός στο Τόκιο;"** → Κλήση API καιρού με παράμετρο τοποθεσίας
- **"Βρες email από τον John την περασμένη εβδομάδα"** → Ερώτημα υπηρεσίας email με αποστολέα και φίλτρα ημερομηνίας

### Εκτέλεση Λειτουργιών
Μετατροπή αιτημάτων χρηστών σε συγκεκριμένες κλήσεις συναρτήσεων:
- **"Προγραμμάτισε μια συνάντηση για αύριο στις 2 μ.μ."** → Ενσωμάτωση API ημερολογίου
- **"Στείλε ένα μήνυμα στην ομάδα"** → API πλατφόρμας επικοινωνίας
- **"Δημιούργησε αντίγραφο ασφαλείας των αρχείων μου"** → Λειτουργία συστήματος αρχείων

### Υπολογιστικές Εργασίες
Διαχείριση σύνθετων μαθηματικών ή λογικών λειτουργιών:
- **"Υπολόγισε τον σύνθετο τόκο για $10,000 με 5% για 10 χρόνια"** → Συνάρτηση χρηματοοικονομικών υπολογισμών
- **"Ανάλυσε αυτό το σύνολο δεδομένων για τάσεις"** → Εργαλεία στατιστικής ανάλυσης
- **"Βελτιστοποίησε αυτή τη διαδρομή για παράδοση"** → Αλγόριθμοι βελτιστοποίησης διαδρομής

### Ροές Επεξεργασίας Δεδομένων
Συνδυασμός πολλαπλών κλήσεων συναρτήσεων για σύνθετες λειτουργίες:
1. **Ανάκτηση δεδομένων** από πολλαπλές πηγές
2. **Ανάλυση και επικύρωση** των πληροφοριών
3. **Μετασχηματισμός** δεδομένων στη ζητούμενη μορφή
4. **Αποθήκευση αποτελεσμάτων** στα κατάλληλα συστήματα
5. **Δημιουργία αναφορών** ή οπτικοποιήσεων

### Ενσωμάτωση UI/UX
Ενεργοποίηση δυναμικών ενημερώσεων διεπαφής:
- **"Δείξε δεδομένα πωλήσεων στον πίνακα ελέγχου"** → Δημιουργία και εμφάνιση γραφήματος
- **"Ενημέρωσε τον χάρτη με νέες τοποθεσίες"** → Ενσωμάτωση γεωχωρικών δεδομένων
- **"Ανανέωσε την προβολή αποθέματος"** → Συγχρονισμός δεδομένων σε πραγματικό χρόνο

## Ρύθμιση Κλήσης Συναρτήσεων με Phi-4-mini και Ollama

Το Phi-4-mini της Microsoft υποστηρίζει τόσο μονοσήμαντη όσο και παράλληλη κλήση συναρτήσεων μέσω του Ollama. Δείτε πώς να το ρυθμίσετε:

### Προαπαιτούμενα
- Έκδοση Ollama 0.5.13 ή νεότερη
- Μοντέλο Phi-4-mini (συνιστάται: `phi4-mini:3.8b-fp16`)

### Βήματα Εγκατάστασης

#### 1. Εγκατάσταση και Εκτέλεση Phi-4-mini
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. Δημιουργία Προσαρμοσμένου Προτύπου ModelFile
Λόγω τρεχόντων περιορισμών στα προεπιλεγμένα πρότυπα του Ollama, πρέπει να δημιουργήσετε ένα προσαρμοσμένο ModelFile με το ακόλουθο πρότυπο:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. Δημιουργία Προσαρμοσμένου Μοντέλου
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### Παράδειγμα Μονοσήμαντης Κλήσης Συνάρτησης

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### Παράδειγμα Παράλληλης Κλήσης Συνάρτησης

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## Εργασία με Κλήση Συναρτήσεων Qwen3

Το Qwen3 προσφέρει προηγμένες δυνατότητες κλήσης συναρτήσεων με εξαιρετική απόδοση και ευελιξία. Δείτε πώς να το υλοποιήσετε:

### Χρήση Πλαισίου Qwen-Agent

Το Qwen-Agent παρέχει ένα υψηλού επιπέδου πλαίσιο που απλοποιεί την υλοποίηση κλήσης συναρτήσεων:

#### Εγκατάσταση
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### Βασική Ρύθμιση

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### Υλοποίηση Προσαρμοσμένων Συναρτήσεων

Μπορείτε επίσης να ορίσετε προσαρμοσμένες συναρτήσεις για το Qwen3:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### Προηγμένα Χαρακτηριστικά Qwen3

#### Έλεγχος Λειτουργίας Σκέψης
Το Qwen3 υποστηρίζει δυναμική εναλλαγή μεταξύ λειτουργίας σκέψης και μη σκέψης:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### Πολυβηματική Κλήση Συναρτήσεων
Το Qwen3 διαπρέπει στη σύνδεση πολλαπλών κλήσεων συναρτήσεων:

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## Τοπική Ενσωμάτωση Foundry

Το Foundry Local της Microsoft παρέχει ένα API συμβατό με OpenAI για την εκτέλεση μοντέλων τοπικά με βελτιωμένη ιδιωτικότητα και απόδοση.

### Ρύθμιση και Εγκατάσταση

#### Windows
Κατεβάστε το πρόγραμμα εγκατάστασης από τη [σελίδα εκδόσεων Foundry Local](https://github.com/microsoft/Foundry-Local/releases) και ακολουθήστε τις οδηγίες εγκατάστασης.

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### Βασική Χρήση

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### Προηγμένα Χαρακτηριστικά Foundry Local

#### Διαχείριση Μοντέλων
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### Βελτιστοποίηση Απόδοσης
Το Foundry Local επιλέγει αυτόματα την καλύτερη παραλλαγή μοντέλου για το υλικό σας:
- **CUDA GPU**: Κατεβάζει μοντέλα βελτιστοποιημένα για GPU
- **Qualcomm NPU**: Χρησιμοποιεί παραλλαγές επιταχυνόμενες από NPU
- **Μόνο CPU**: Επιλέγει μοντέλα βελτιστοποιημένα για CPU

## Βέλτιστες Πρακτικές και Αντιμετώπιση Προβλημάτων

### Βέλτιστες Πρακτικές Ορισμού Συναρτήσεων

#### 1. Καθαρή και Περιγραφική Ονομασία
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. Πλήρεις Ορισμοί Παραμέτρων
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. Επικύρωση Εισόδου και Διαχείριση Σφαλμάτων
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### Συνηθισμένα Προβλήματα και Λύσεις

#### Πρόβλημα 1: Η Συνάρτηση Δεν Καλείται
**Συμπτώματα**: Το μοντέλο απαντά με κείμενο αντί να καλεί τη συνάρτηση

**Λύσεις**:
1. **Ελέγξτε την περιγραφή της συνάρτησης**: Βεβαιωθείτε ότι ταιριάζει καθαρά με την πρόθεση του χρήστη
2. **Επικυρώστε τους ορισμούς παραμέτρων**: Βεβαιωθείτε ότι όλες οι απαιτούμενες παράμετροι είναι σωστά ορισμένες
3. **Αναθεωρήστε την προτροπή συστήματος**: Συμπεριλάβετε σαφείς οδηγίες για το πότε να χρησιμοποιούνται οι συναρτήσεις
4. **Δοκιμάστε με ρητά αιτήματα**: Δοκιμάστε "Παρακαλώ χρησιμοποιήστε τη συνάρτηση καιρού για να λάβετε δεδομένα για το Λονδίνο"

#### Πρόβλημα 2: Λανθασμένες Παράμετροι
**Συμπτώματα**: Η συνάρτηση καλείται με λάθος ή ελλιπείς παραμέτρους

**Λύσεις**:
1. **Προσθέστε παραδείγματα παραμέτρων**: Συμπεριλάβετε δείγματα τιμών στις περιγραφές παραμέτρων
2. **Χρησιμοποιήστε περιορισμούς enum**: Περιορίστε τις τιμές παραμέτρων σε συγκεκριμένες επιλογές όπου είναι δυνατόν
3. **Υλοποιήστε εφεδρικές τιμές**: Παρέχετε λογικές προεπιλογές για προαιρετικές παραμέτρους

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### Πρόβλημα 3: Αποτυχίες Παράλληλης Κλήσης Συναρτήσεων
**Συμπτώματα**: Εκτελείται μόνο μία συνάρτηση όταν πρέπει να εκτελεστούν πολλές

**Λύσεις**:
1. **Ελέγξτε την υποστήριξη του μοντέλου**: Βεβαιωθείτε ότι το μοντέλο σας υποστηρίζει παράλληλη κλήση συναρτήσεων
2. **Ενημερώστε την προτροπή συστήματος**: Συμπεριλάβετε "κάποια εργαλεία" ή "πολλαπλά εργαλεία" στο μήνυμα συστήματος
3. **Χρησιμοποιήστε κατάλληλες εκδόσεις μοντέλων**: Συνιστάται το Phi-4-mini:3.8b-fp16 για το Ollama

#### Πρόβλημα 4: Προβλήματα Προτύπου με το Ollama
**Συμπτώματα**: Η κλήση συναρτήσεων δεν λειτουργεί με την προεπιλεγμένη ρύθμιση του Ollama

**Λύσεις**:
1. **Χρησιμοποιήστε προσαρμοσμένο ModelFile**: Εφαρμόστε το διορθωμένο πρότυπο που παρέχεται σε αυτό το σεμινάριο
2. **Ενημερώστε το Ollama**: Βεβαιωθείτε ότι χρησιμοποιείτε την έκδοση 0.5.13 ή νεότερη
3. **Ελέγξτε την κβαντοποίηση του μοντέλου**: Υψηλότερα επίπεδα κβαντοποίησης (Q8_0, fp16) λειτουργούν καλύτερα από τις έντονα κβαντισμένες εκδόσεις

### Βελτιστοποίηση Απόδοσης

#### 1. Αποτελεσματικός Σχεδιασμός Συναρτήσεων
- **Διατηρήστε τις συναρτήσεις εστιασμένες**: Κάθε συνάρτηση πρέπει να έχει έναν μοναδικό, σαφή σκοπό
- **Ελαχιστοποιήστε τις εξωτερικές εξαρτήσεις**: Μειώστε τις κλήσεις API και τα αιτήματα δικτύου όπου είναι δυνατόν
- **Αποθηκεύστε αποτελέσματα**: Αποθηκεύστε συχνά ζητούμενα δεδομένα για τη βελτίωση των χρόνων απόκρισης

#### 2. Ομαδοποίηση και Ασύγχρονες Λειτουργίες
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. Διαχείριση Πόρων
- **Πισίνες συνδέσεων**: Επαναχρησιμοποιήστε συνδέσεις βάσεων δεδομένων και API
- **Περιορισμός ρυθμού**: Εφαρμόστε σωστό περιορισμό ρυθμού για εξωτερικά APIs
- **Διαχείριση χρονικών ορίων**: Ορίστε λογικά χρονικά όρια για όλες τις εξωτερικές κλήσεις

## Προχωρημένα Παραδείγματα

### Σύστημα Συνεργασίας Πολλαπλών Πρακτόρων

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### Σύστημα Δυναμικής Επιλογής Εργαλείων

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```
I'm sorry, but I need the content of the markdown file to proceed with the translation. Could you please provide the text you'd like me to translate?
"""Εκτέλεση μιας συνάρτησης με ολοκληρωμένο χειρισμό σφαλμάτων και καταγραφή"""
start_time = datetime.now()

try:
    # Επαλήθευση ότι η συνάρτηση υπάρχει
    if function_name not in self.functions:
        return FunctionResult(
            success=False,
            error=f"Η συνάρτηση '{function_name}' δεν βρέθηκε",
            timestamp=start_time
        )
    
    # Έλεγχος ορίων συχνότητας
    if not self._check_rate_limit(function_name):
        return FunctionResult(
            success=False,
            error=f"Υπέρβαση ορίου συχνότητας για τη συνάρτηση '{function_name}'",
            timestamp=start_time
        )
    
    # Επαλήθευση παραμέτρων
    validation_result = self._validate_parameters(function_name, parameters)
    if not validation_result.success:
        return validation_result
    
    # Εκτέλεση συνάρτησης
    func_info = self.functions[function_name]
    handler = func_info['handler']
    
    if asyncio.iscoroutinefunction(handler):
        result_data = await handler(**parameters)
    else:
        result_data = handler(**parameters)
    
    execution_time = (datetime.now() - start_time).total_seconds()
    
    result = FunctionResult(
        success=True,
        data=result_data,
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Καταγραφή επιτυχούς εκτέλεσης
    self._log_function_call(function_name, parameters, result)
    
    return result
    
except Exception as e:
    execution_time = (datetime.now() - start_time).total_seconds()
    result = FunctionResult(
        success=False,
        error=str(e),
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Καταγραφή αποτυχημένης εκτέλεσης
    self._log_function_call(function_name, parameters, result)
    
    return result

def _check_rate_limit(self, function_name: str) -> bool:
    """Έλεγχος αν η κλήση της συνάρτησης είναι εντός των ορίων συχνότητας"""
    func_info = self.functions[function_name]
    now = datetime.now()
    
    # Επαναφορά μετρητή αν έχει περάσει ένα λεπτό
    if (now - func_info['last_reset']).seconds >= 60:
        func_info['call_count'] = 0
        func_info['last_reset'] = now
    
    # Έλεγχος αν είναι εντός ορίου
    if func_info['call_count'] >= func_info['rate_limit']:
        return False
    
    func_info['call_count'] += 1
    return True

def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
    """Επαλήθευση παραμέτρων συνάρτησης"""
    func_params = self.functions[function_name]['parameters']
    
    # Έλεγχος απαιτούμενων παραμέτρων
    for param_name, param_info in func_params.items():
        if param_info.get('required', False) and param_name not in parameters:
            return FunctionResult(
                success=False,
                error=f"Λείπει η απαιτούμενη παράμετρος: {param_name}"
            )
    
    # Επαλήθευση τύπων και περιορισμών παραμέτρων
    for param_name, value in parameters.items():
        if param_name in func_params:
            param_info = func_params[param_name]
            
            # Επαλήθευση τύπου
            expected_type = param_info.get('type')
            if expected_type == 'string' and not isinstance(value, str):
                return FunctionResult(
                    success=False,
                    error=f"Η παράμετρος '{param_name}' πρέπει να είναι string"
                )
            elif expected_type == 'number' and not isinstance(value, (int, float)):
                return FunctionResult(
                    success=False,
                    error=f"Η παράμετρος '{param_name}' πρέπει να είναι αριθμός"
                )
            elif expected_type == 'boolean' and not isinstance(value, bool):
                return FunctionResult(
                    success=False,
                    error=f"Η παράμετρος '{param_name}' πρέπει να είναι boolean"
                )
            
            # Επαλήθευση enum
            if 'enum' in param_info and value not in param_info['enum']:
                return FunctionResult(
                    success=False,
                    error=f"Η παράμετρος '{param_name}' πρέπει να είναι μία από: {param_info['enum']}"
                )
    
    return FunctionResult(success=True)

def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):
    """Καταγραφή κλήσης συνάρτησης για σκοπούς ελέγχου"""
    log_entry = {
        'timestamp': result.timestamp.isoformat(),
        'function_name': function_name,
        'parameters': parameters,
        'success': result.success,
        'execution_time': result.execution_time,
        'error': result.error if not result.success else None
    }
    
    self.audit_log.append(log_entry)
    
    # Προαιρετική εγγραφή σε εξωτερικό σύστημα καταγραφής
    if self.config.get('enable_external_logging', False):
        self._write_to_external_log(log_entry)

def _write_to_external_log(self, log_entry: Dict):
    """Εγγραφή καταγραφής σε εξωτερικό σύστημα καταγραφής"""
    # Η υλοποίηση εξαρτάται από την υποδομή καταγραφής σας
    # π.χ., αποστολή σε ELK stack, CloudWatch, κλπ.
    pass

# Υλοποιήσεις επιχειρηματικών συναρτήσεων
async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
    """Ανάκτηση πληροφοριών πελάτη από το σύστημα CRM"""
    # Προσομοίωση κλήσης βάσης δεδομένων/API
    await asyncio.sleep(0.1)  # Προσομοίωση καθυστέρησης δικτύου
    
    customer_data = {
        'customer_id': customer_id,
        'name': 'John Doe',
        'email': 'john.doe@example.com',
        'phone': '+1-555-0123',
        'status': 'active',
        'tier': 'premium'
    }
    
    if include_history:
        customer_data['purchase_history'] = [
            {'date': '2024-01-15', 'product': 'Product A', 'amount': 1500},
            {'date': '2024-03-22', 'product': 'Product B', 'amount': 2300}
        ]
    
    return customer_data

async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                  estimated_value: float, expected_close_date: str) -> Dict:
    """Δημιουργία νέας ευκαιρίας πώλησης"""
    # Προσομοίωση κλήσης API CRM
    await asyncio.sleep(0.2)
    
    opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'opportunity_id': opportunity_id,
        'customer_id': customer_id,
        'product_id': product_id,
        'estimated_value': estimated_value,
        'expected_close_date': expected_close_date,
        'status': 'open',
        'created_date': datetime.now().isoformat()
    }

async def _generate_sales_report(self, period: str, region: str = None, 
                               product_category: str = None) -> Dict:
    """Δημιουργία ολοκληρωμένης αναφοράς πωλήσεων"""
    # Προσομοίωση συγκέντρωσης δεδομένων
    await asyncio.sleep(0.5)
    
    return {
        'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
        'period': period,
        'region': region,
        'product_category': product_category,
        'total_sales': 125000.00,
        'total_opportunities': 45,
        'conversion_rate': 0.67,
        'top_products': [
            {'product_id': 'PROD-001', 'sales': 45000},
            {'product_id': 'PROD-002', 'sales': 32000}
        ],
        'generated_at': datetime.now().isoformat()
    }

async def _send_notification(self, recipients: List[str], message: str, 
                           priority: str = 'medium', channel: str = 'email') -> Dict:
    """Αποστολή ειδοποίησης μέσω του καθορισμένου καναλιού"""
    # Προσομοίωση κλήσης υπηρεσίας ειδοποίησης
    await asyncio.sleep(0.1)
    
    notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'notification_id': notification_id,
        'recipients': recipients,
        'channel': channel,
        'priority': priority,
        'status': 'sent',
        'sent_at': datetime.now().isoformat()
    }

def get_function_definitions(self) -> List[Dict]:
    """Λήψη συμβατών ορισμών συναρτήσεων OpenAI για όλες τις εγγεγραμμένες συναρτήσεις"""
    definitions = []
    
    for func_name, func_info in self.functions.items():
        definition = {
            'name': func_name,
            'description': func_info['description'],
            'parameters': {
                'type': 'object',
                'properties': {},
                'required': []
            }
        }
        
        for param_name, param_info in func_info['parameters'].items():
            definition['parameters']['properties'][param_name] = {
                'type': param_info['type'],
                'description': param_info.get('description', '')
            }
            
            if 'enum' in param_info:
                definition['parameters']['properties'][param_name]['enum'] = param_info['enum']
            
            if 'default' in param_info:
                definition['parameters']['properties'][param_name]['default'] = param_info['default']
            
            if param_info.get('required', False):
                definition['parameters']['required'].append(param_name)
        
        definitions.append(definition)
    
    return definitions

# Παράδειγμα χρήσης για εταιρική ενσωμάτωση
async def enterprise_demo():
    """Επίδειξη δυνατοτήτων εταιρικού AI agent"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # Παράδειγμα 1: Επεξεργασία ερωτήσεων πελατών
    print("=== Επεξεργασία Ερωτήσεων Πελατών ===")
    
    # Λήψη πληροφοριών πελάτη
    result = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    if result.success:
        print(f"Πληροφορίες Πελάτη Ανακτήθηκαν: {result.data['name']}")
        print(f"Χρόνος Εκτέλεσης: {result.execution_time:.3f}s")
    
    # Παράδειγμα 2: Δημιουργία ευκαιρίας πώλησης
    print("\n=== Δημιουργία Ευκαιρίας Πώλησης ===")
    
    result = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    if result.success:
        print(f"Ευκαιρία Δημιουργήθηκε: {result.data['opportunity_id']}")
    
    # Παράδειγμα 3: Λειτουργίες παρτίδας
    print("\n=== Λειτουργίες Παρτίδας ===")
    
    tasks = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': 'Νέα ευκαιρία δημιουργήθηκε',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    results = await asyncio.gather(*tasks)
    
    for i, result in enumerate(results):
        if result.success:
            print(f"Εργασία {i+1} ολοκληρώθηκε επιτυχώς")
        else:
            print(f"Εργασία {i+1} απέτυχε: {result.error}")
    
    # Εμφάνιση καταγραφής ελέγχου
    print(f"\n=== Καταγραφή Ελέγχου ({len(agent.audit_log)} εγγραφές) ===")
    for entry in agent.audit_log[-3:]:  # Εμφάνιση τελευταίων 3 εγγραφών
        print(f"{entry['timestamp']}: {entry['function_name']} - {'ΕΠΙΤΥΧΙΑ' if entry['success'] else 'ΑΠΟΤΥΧΙΑ'}")

# Εκτέλεση της εταιρικής επίδειξης
# asyncio.run(enterprise_demo())
- **Μοντέλα Phi-4**: [Συλλογή Hugging Face](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)
- **Τεκμηρίωση Qwen3**: [Επίσημη Τεκμηρίωση Qwen](https://qwen.readthedocs.io/)
- **Ollama**: [Επίσημος Ιστότοπος](https://ollama.com/)
- **Foundry Local**: [Αποθετήριο GitHub](https://github.com/microsoft/Foundry-Local)
- **Βέλτιστες Πρακτικές Κλήσης Συναρτήσεων**: [Οδηγός Hugging Face](https://huggingface.co/docs/hugs/en/guides/function-calling)

Να θυμάστε ότι η κλήση συναρτήσεων είναι ένα εξελισσόμενο πεδίο, και η ενημέρωση με τις τελευταίες εξελίξεις στα επιλεγμένα σας πλαίσια και μοντέλα θα σας βοηθήσει να δημιουργήσετε πιο αποτελεσματικούς AI agents.


## ➡️ Τι ακολουθεί

- [03: Ενσωμάτωση Πρωτοκόλλου Πλαισίου Μοντέλου (MCP)](./03.IntroduceMCP.md)

---

**Αποποίηση ευθύνης**:  
Αυτό το έγγραφο έχει μεταφραστεί χρησιμοποιώντας την υπηρεσία αυτόματης μετάφρασης [Co-op Translator](https://github.com/Azure/co-op-translator). Παρόλο που καταβάλλουμε προσπάθειες για ακρίβεια, παρακαλούμε να έχετε υπόψη ότι οι αυτοματοποιημένες μεταφράσεις ενδέχεται να περιέχουν σφάλματα ή ανακρίβειες. Το πρωτότυπο έγγραφο στη μητρική του γλώσσα θα πρέπει να θεωρείται η αυθεντική πηγή. Για κρίσιμες πληροφορίες, συνιστάται επαγγελματική ανθρώπινη μετάφραση. Δεν φέρουμε ευθύνη για τυχόν παρεξηγήσεις ή εσφαλμένες ερμηνείες που προκύπτουν από τη χρήση αυτής της μετάφρασης.