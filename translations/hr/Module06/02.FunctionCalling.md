<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-09-18T23:26:48+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "hr"
}
-->
# Section02 : Pozivanje funkcija u malim jezičnim modelima (SLMs)

## Sadržaj
1. [Što je pozivanje funkcija?](../../../Module06)
2. [Kako funkcionira pozivanje funkcija](../../../Module06)
3. [Primjene](../../../Module06)
4. [Postavljanje pozivanja funkcija s Phi-4-mini i Ollama](../../../Module06)
5. [Rad s Qwen3 pozivanjem funkcija](../../../Module06)
6. [Lokalna integracija Foundryja](../../../Module06)
7. [Najbolje prakse i rješavanje problema](../../../Module06)
8. [Napredni primjeri](../../../Module06)

## Što je pozivanje funkcija?

Pozivanje funkcija je moćna sposobnost koja omogućuje malim jezičnim modelima (SLMs) interakciju s vanjskim alatima, API-jima i uslugama. Umjesto da budu ograničeni na podatke iz treninga, SLM-ovi sada mogu:

- **Povezati se s vanjskim API-jima** (usluge vremenske prognoze, baze podataka, tražilice)
- **Izvršiti specifične funkcije** na temelju korisničkih zahtjeva
- **Dobiti informacije u stvarnom vremenu** iz različitih izvora
- **Izvršiti računalne zadatke** putem specijaliziranih alata
- **Povezati više operacija** za složene radne procese

Ova sposobnost transformira SLM-ove iz statičnih generatora teksta u dinamične AI agente koji mogu obavljati stvarne zadatke.

## Kako funkcionira pozivanje funkcija

Proces pozivanja funkcija slijedi sustavni tijek rada:

### 1. Integracija alata
- **Vanjski alati**: SLM-ovi se mogu povezati s API-jima za vremensku prognozu, bazama podataka, web uslugama i drugim vanjskim sustavima
- **Definicije funkcija**: Svaki alat definiran je s određenim parametrima, formatima ulaza/izlaza i opisima
- **Kompatibilnost API-ja**: Alati se integriraju putem standardiziranih sučelja (REST API, SDK-ovi itd.)

### 2. Definicija funkcije
Funkcije se definiraju s tri ključne komponente:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. Detekcija namjere
- **Obrada prirodnog jezika**: SLM analizira korisnički unos kako bi razumio namjeru
- **Odabir funkcije**: Određuje koje funkcije su potrebne za ispunjenje zahtjeva
- **Ekstrakcija parametara**: Identificira i izvlači potrebne parametre iz korisničke poruke

### 4. Generiranje JSON izlaza
SLM generira strukturirani JSON koji sadrži:
- Naziv funkcije koju treba pozvati
- Potrebne parametre s odgovarajućim vrijednostima
- Kontekst izvršenja i metapodatke

### 5. Vanjsko izvršenje
- **Validacija parametara**: Provjerava jesu li svi potrebni parametri prisutni i ispravno formatirani
- **Izvršenje funkcije**: Aplikacija izvršava specificiranu funkciju s dostavljenim parametrima
- **Rukovanje greškama**: Upravljanje neuspjesima, istekom vremena i nevažećim odgovorima

### 6. Integracija odgovora
- **Obrada rezultata**: Izlaz funkcije vraća se SLM-u
- **Integracija konteksta**: SLM uključuje rezultate u svoj odgovor
- **Komunikacija s korisnikom**: Predstavlja informacije u prirodnom, razgovornom formatu

## Primjene

### Dohvaćanje podataka
Pretvaranje upita u prirodnom jeziku u strukturirane API pozive:
- **"Prikaži moje nedavne narudžbe"** → Upit bazi podataka s korisničkim ID-om i filtrima datuma
- **"Kakvo je vrijeme u Tokiju?"** → Poziv API-ja za vremensku prognozu s parametrima lokacije
- **"Pronađi e-mailove od Johna prošlog tjedna"** → Upit e-mail servisu s pošiljateljem i filtrima datuma

### Izvršenje operacija
Pretvaranje korisničkih zahtjeva u specifične pozive funkcija:
- **"Zakaži sastanak za sutra u 14 sati"** → Integracija s API-jem kalendara
- **"Pošalji poruku timu"** → API komunikacijske platforme
- **"Napravite sigurnosnu kopiju mojih datoteka"** → Operacija datotečnog sustava

### Računalni zadaci
Rješavanje složenih matematičkih ili logičkih operacija:
- **"Izračunaj složenu kamatu na 10.000 dolara po stopi od 5% za 10 godina"** → Funkcija financijskog izračuna
- **"Analiziraj ovaj skup podataka za trendove"** → Alati za statističku analizu
- **"Optimiziraj ovu rutu za dostavu"** → Algoritmi za optimizaciju ruta

### Radni procesi obrade podataka
Povezivanje više poziva funkcija za složene operacije:
1. **Dohvaćanje podataka** iz više izvora
2. **Parsiranje i validacija** informacija
3. **Transformacija** podataka u traženi format
4. **Pohrana rezultata** u odgovarajuće sustave
5. **Generiranje izvještaja** ili vizualizacija

### Integracija UI/UX-a
Omogućavanje dinamičkih ažuriranja sučelja:
- **"Prikaži podatke o prodaji na nadzornoj ploči"** → Generiranje i prikaz grafikona
- **"Ažuriraj kartu s novim lokacijama"** → Integracija geolokacijskih podataka
- **"Osvježi prikaz inventara"** → Sinkronizacija podataka u stvarnom vremenu

## Postavljanje pozivanja funkcija s Phi-4-mini i Ollama

Microsoftov Phi-4-mini podržava pozivanje funkcija pojedinačno i paralelno putem Ollama. Evo kako ga postaviti:

### Preduvjeti
- Ollama verzija 0.5.13 ili novija
- Phi-4-mini model (preporučeno: `phi4-mini:3.8b-fp16`)

### Koraci instalacije

#### 1. Instalirajte i pokrenite Phi-4-mini
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. Kreirajte prilagođeni ModelFile predložak
Zbog trenutnih ograničenja u zadanim predlošcima Ollame, potrebno je kreirati prilagođeni ModelFile s ovim predloškom:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. Kreirajte prilagođeni model
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### Primjer pozivanja jedne funkcije

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### Primjer paralelnog pozivanja funkcija

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## Rad s Qwen3 pozivanjem funkcija

Qwen3 nudi napredne mogućnosti pozivanja funkcija s izvrsnim performansama i fleksibilnošću. Evo kako ga implementirati:

### Korištenje Qwen-Agent okvira

Qwen-Agent pruža visokorazinski okvir koji pojednostavljuje implementaciju pozivanja funkcija:

#### Instalacija
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### Osnovno postavljanje

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### Prilagođena implementacija funkcija

Možete definirati i prilagođene funkcije za Qwen3:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### Napredne značajke Qwen3

#### Kontrola načina razmišljanja
Qwen3 podržava dinamičko prebacivanje između načina razmišljanja i ne-razmišljanja:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### Višekorakovno pozivanje funkcija
Qwen3 se ističe u povezivanju više poziva funkcija:

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## Lokalna integracija Foundryja

Microsoftov Foundry Local pruža API kompatibilan s OpenAI-jem za pokretanje modela lokalno uz poboljšanu privatnost i performanse.

### Postavljanje i instalacija

#### Windows
Preuzmite instalacijski program s [stranice za izdavanje Foundry Local](https://github.com/microsoft/Foundry-Local/releases) i slijedite upute za instalaciju.

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### Osnovna upotreba

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### Napredne značajke Foundry Local

#### Upravljanje modelima
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### Optimizacija performansi
Foundry Local automatski odabire najbolju varijantu modela za vaš hardver:
- **CUDA GPU**: Preuzima modele optimizirane za GPU
- **Qualcomm NPU**: Koristi varijante ubrzane NPU-om
- **Samo CPU**: Odabire modele optimizirane za CPU

## Najbolje prakse i rješavanje problema

### Najbolje prakse za definiciju funkcija

#### 1. Jasno i opisno imenovanje
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. Sveobuhvatne definicije parametara
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. Validacija ulaza i rukovanje greškama
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### Uobičajeni problemi i rješenja

#### Problem 1: Funkcija se ne poziva
**Simptomi**: Model odgovara tekstom umjesto pozivanjem funkcije

**Rješenja**:
1. **Provjerite opis funkcije**: Osigurajte da jasno odgovara korisničkoj namjeri
2. **Provjerite definicije parametara**: Provjerite jesu li svi potrebni parametri ispravno definirani
3. **Pregledajte sistemski prompt**: Uključite jasne upute o tome kada koristiti funkcije
4. **Testirajte s eksplicitnim zahtjevima**: Pokušajte "Molim vas koristite funkciju vremenske prognoze za podatke o Londonu"

#### Problem 2: Neispravni parametri
**Simptomi**: Funkcija se poziva s pogrešnim ili nedostajućim parametrima

**Rješenja**:
1. **Dodajte primjere parametara**: Uključite uzorke vrijednosti u opise parametara
2. **Koristite ograničenja enum**: Ograničite vrijednosti parametara na specifične opcije kad je moguće
3. **Implementirajte rezervne vrijednosti**: Osigurajte razumne zadane vrijednosti za opcionalne parametre

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### Problem 3: Neuspjesi paralelnog pozivanja funkcija
**Simptomi**: Izvršava se samo jedna funkcija kada bi trebalo više njih

**Rješenja**:
1. **Provjerite podršku modela**: Osigurajte da vaš model podržava paralelno pozivanje funkcija
2. **Ažurirajte sistemski prompt**: Uključite "neki alati" ili "više alata" u sistemsku poruku
3. **Koristite odgovarajuće verzije modela**: Preporučeno Phi-4-mini:3.8b-fp16 za Ollama

#### Problem 4: Problemi s predloškom u Ollama
**Simptomi**: Pozivanje funkcija ne radi s zadanim postavkama Ollame

**Rješenja**:
1. **Koristite prilagođeni ModelFile**: Primijenite ispravljeni predložak iz ovog vodiča
2. **Ažurirajte Ollama**: Osigurajte da koristite verziju 0.5.13 ili noviju
3. **Provjerite kvantizaciju modela**: Viši nivoi kvantizacije (Q8_0, fp16) rade bolje od jako kvantiziranih verzija

### Optimizacija performansi

#### 1. Učinkovit dizajn funkcija
- **Fokusirajte funkcije**: Svaka funkcija treba imati jednu, jasnu svrhu
- **Minimizirajte vanjske ovisnosti**: Smanjite API pozive i mrežne zahtjeve gdje je moguće
- **Keširajte rezultate**: Pohranite često tražene podatke za poboljšanje vremena odgovora

#### 2. Grupiranje i asinkrone operacije
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. Upravljanje resursima
- **Pooliranje konekcija**: Ponovno koristite konekcije baze podataka i API-ja
- **Ograničavanje brzine**: Implementirajte pravilno ograničavanje brzine za vanjske API-je
- **Rukovanje istekom vremena**: Postavite razumne vremenske limite za sve vanjske pozive

## Napredni primjeri

### Sustav suradnje više agenata

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### Sustav za dinamički odabir alata

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```python
import asyncio
import json
from typing import Dict, List, Any
from dataclasses import dataclass
from datetime import datetime

@dataclass
class FunctionResult:
    """Standardni format rezultata za sve pozive funkcija"""
    success: bool
    data: Any = None
    error: str = None
    execution_time: float = 0.0
    timestamp: datetime = None

class EnterpriseAIAgent:
    """AI agent spreman za produkciju s opsežnim mogućnostima pozivanja funkcija"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.functions = {}
        self.audit_log = []
        self.rate_limiters = {}
        
        # Inicijalizacija osnovnih poslovnih funkcija
        self._register_core_functions()
    
    def _register_core_functions(self):
        """Registracija svih dostupnih poslovnih funkcija"""
        
        # CRM funkcije
        self.register_function(
            name="get_customer_info",
            description="Dohvati informacije o korisniku iz CRM-a",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "include_history": {"type": "boolean", "default": False}
            },
            handler=self._get_customer_info,
            rate_limit=100  # poziva po minuti
        )
        
        # Funkcije prodaje
        self.register_function(
            name="create_sales_opportunity",
            description="Kreiraj novu prodajnu priliku",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "product_id": {"type": "string", "required": True},
                "estimated_value": {"type": "number", "required": True},
                "expected_close_date": {"type": "string", "required": True}
            },
            handler=self._create_sales_opportunity,
            rate_limit=50
        )
        
        # Analitičke funkcije
        self.register_function(
            name="generate_sales_report",
            description="Generiraj izvještaj o prodajnim performansama",
            parameters={
                "period": {"type": "string", "enum": ["daily", "weekly", "monthly", "quarterly"]},
                "region": {"type": "string", "required": False},
                "product_category": {"type": "string", "required": False}
            },
            handler=self._generate_sales_report,
            rate_limit=10
        )
        
        # Funkcije obavijesti
        self.register_function(
            name="send_notification",
            description="Pošalji obavijest članovima tima",
            parameters={
                "recipients": {"type": "array", "items": {"type": "string"}},
                "message": {"type": "string", "required": True},
                "priority": {"type": "string", "enum": ["low", "medium", "high"], "default": "medium"},
                "channel": {"type": "string", "enum": ["email", "slack", "teams"], "default": "email"}
            },
            handler=self._send_notification,
            rate_limit=200
        )
    
    def register_function(self, name: str, description: str, parameters: Dict, 
                         handler: callable, rate_limit: int = 60):
        """Registracija nove funkcije s agentom"""
        self.functions[name] = {
            'description': description,
            'parameters': parameters,
            'handler': handler,
            'rate_limit': rate_limit,
            'call_count': 0,
            'last_reset': datetime.now()
        }
    
    async def execute_function(self, function_name: str, parameters: Dict) -
I understand the instructions. Please provide the markdown file you'd like me to translate.
"""Izvršavanje funkcije s detaljnim rukovanjem greškama i zapisivanjem"""
start_time = datetime.now()

try:
    # Provjeri postoji li funkcija
    if function_name not in self.functions:
        return FunctionResult(
            success=False,
            error=f"Funkcija '{function_name}' nije pronađena",
            timestamp=start_time
        )
    
    # Provjeri ograničenja učestalosti poziva
    if not self._check_rate_limit(function_name):
        return FunctionResult(
            success=False,
            error=f"Prekoračeno ograničenje učestalosti za funkciju '{function_name}'",
            timestamp=start_time
        )
    
    # Validiraj parametre
    validation_result = self._validate_parameters(function_name, parameters)
    if not validation_result.success:
        return validation_result
    
    # Izvrši funkciju
    func_info = self.functions[function_name]
    handler = func_info['handler']
    
    if asyncio.iscoroutinefunction(handler):
        result_data = await handler(**parameters)
    else:
        result_data = handler(**parameters)
    
    execution_time = (datetime.now() - start_time).total_seconds()
    
    result = FunctionResult(
        success=True,
        data=result_data,
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Zapiši uspješno izvršenje
    self._log_function_call(function_name, parameters, result)
    
    return result
    
except Exception as e:
    execution_time = (datetime.now() - start_time).total_seconds()
    result = FunctionResult(
        success=False,
        error=str(e),
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Zapiši neuspješno izvršenje
    self._log_function_call(function_name, parameters, result)
    
    return result

def _check_rate_limit(self, function_name: str) -> bool:
    """Provjeri je li poziv funkcije unutar ograničenja učestalosti"""
    func_info = self.functions[function_name]
    now = datetime.now()
    
    # Resetiraj brojač ako je prošla minuta
    if (now - func_info['last_reset']).seconds >= 60:
        func_info['call_count'] = 0
        func_info['last_reset'] = now
    
    # Provjeri je li unutar ograničenja
    if func_info['call_count'] >= func_info['rate_limit']:
        return False
    
    func_info['call_count'] += 1
    return True

def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
    """Validiraj parametre funkcije"""
    func_params = self.functions[function_name]['parameters']
    
    # Provjeri obavezne parametre
    for param_name, param_info in func_params.items():
        if param_info.get('required', False) and param_name not in parameters:
            return FunctionResult(
                success=False,
                error=f"Nedostaje obavezni parametar: {param_name}"
            )
    
    # Validiraj tipove parametara i ograničenja
    for param_name, value in parameters.items():
        if param_name in func_params:
            param_info = func_params[param_name]
            
            # Validacija tipa
            expected_type = param_info.get('type')
            if expected_type == 'string' and not isinstance(value, str):
                return FunctionResult(
                    success=False,
                    error=f"Parametar '{param_name}' mora biti string"
                )
            elif expected_type == 'number' and not isinstance(value, (int, float)):
                return FunctionResult(
                    success=False,
                    error=f"Parametar '{param_name}' mora biti broj"
                )
            elif expected_type == 'boolean' and not isinstance(value, bool):
                return FunctionResult(
                    success=False,
                    error=f"Parametar '{param_name}' mora biti boolean"
                )
            
            # Validacija enum vrijednosti
            if 'enum' in param_info and value not in param_info['enum']:
                return FunctionResult(
                    success=False,
                    error=f"Parametar '{param_name}' mora biti jedna od vrijednosti: {param_info['enum']}"
                )
    
    return FunctionResult(success=True)

def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):
    """Zapiši poziv funkcije za potrebe revizije"""
    log_entry = {
        'timestamp': result.timestamp.isoformat(),
        'function_name': function_name,
        'parameters': parameters,
        'success': result.success,
        'execution_time': result.execution_time,
        'error': result.error if not result.success else None
    }
    
    self.audit_log.append(log_entry)
    
    # Opcionalno zapisivanje u vanjski sustav za zapisivanje
    if self.config.get('enable_external_logging', False):
        self._write_to_external_log(log_entry)

def _write_to_external_log(self, log_entry: Dict):
    """Zapiši unos u vanjski sustav za zapisivanje"""
    # Implementacija ovisi o vašoj infrastrukturi za zapisivanje
    # npr. slanje u ELK stack, CloudWatch, itd.
    pass

# Implementacije poslovnih funkcija
async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
    """Dohvati informacije o korisniku iz CRM sustava"""
    # Simuliraj poziv baze podataka/API-ja
    await asyncio.sleep(0.1)  # Simulacija mrežnog kašnjenja
    
    customer_data = {
        'customer_id': customer_id,
        'name': 'John Doe',
        'email': 'john.doe@example.com',
        'phone': '+1-555-0123',
        'status': 'active',
        'tier': 'premium'
    }
    
    if include_history:
        customer_data['purchase_history'] = [
            {'date': '2024-01-15', 'product': 'Proizvod A', 'amount': 1500},
            {'date': '2024-03-22', 'product': 'Proizvod B', 'amount': 2300}
        ]
    
    return customer_data

async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                  estimated_value: float, expected_close_date: str) -> Dict:
    """Kreiraj novu prodajnu priliku"""
    # Simuliraj poziv CRM API-ja
    await asyncio.sleep(0.2)
    
    opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'opportunity_id': opportunity_id,
        'customer_id': customer_id,
        'product_id': product_id,
        'estimated_value': estimated_value,
        'expected_close_date': expected_close_date,
        'status': 'open',
        'created_date': datetime.now().isoformat()
    }

async def _generate_sales_report(self, period: str, region: str = None, 
                               product_category: str = None) -> Dict:
    """Generiraj sveobuhvatno izvješće o prodaji"""
    # Simuliraj agregaciju podataka
    await asyncio.sleep(0.5)
    
    return {
        'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
        'period': period,
        'region': region,
        'product_category': product_category,
        'total_sales': 125000.00,
        'total_opportunities': 45,
        'conversion_rate': 0.67,
        'top_products': [
            {'product_id': 'PROD-001', 'sales': 45000},
            {'product_id': 'PROD-002', 'sales': 32000}
        ],
        'generated_at': datetime.now().isoformat()
    }

async def _send_notification(self, recipients: List[str], message: str, 
                           priority: str = 'medium', channel: str = 'email') -> Dict:
    """Pošalji obavijest putem odabranog kanala"""
    # Simuliraj poziv servisa za obavijesti
    await asyncio.sleep(0.1)
    
    notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'notification_id': notification_id,
        'recipients': recipients,
        'channel': channel,
        'priority': priority,
        'status': 'sent',
        'sent_at': datetime.now().isoformat()
    }

def get_function_definitions(self) -> List[Dict]:
    """Dohvati definicije funkcija kompatibilne s OpenAI za sve registrirane funkcije"""
    definitions = []
    
    for func_name, func_info in self.functions.items():
        definition = {
            'name': func_name,
            'description': func_info['description'],
            'parameters': {
                'type': 'object',
                'properties': {},
                'required': []
            }
        }
        
        for param_name, param_info in func_info['parameters'].items():
            definition['parameters']['properties'][param_name] = {
                'type': param_info['type'],
                'description': param_info.get('description', '')
            }
            
            if 'enum' in param_info:
                definition['parameters']['properties'][param_name]['enum'] = param_info['enum']
            
            if 'default' in param_info:
                definition['parameters']['properties'][param_name]['default'] = param_info['default']
            
            if param_info.get('required', False):
                definition['parameters']['required'].append(param_name)
        
        definitions.append(definition)
    
    return definitions

# Primjer korištenja za integraciju u poduzeću
async def enterprise_demo():
    """Demonstracija sposobnosti AI agenta za poduzeća"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # Primjer 1: Obrada upita korisnika
    print("=== Obrada upita korisnika ===")
    
    # Dohvati informacije o korisniku
    result = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    if result.success:
        print(f"Informacije o korisniku dohvaćene: {result.data['name']}")
        print(f"Vrijeme izvršenja: {result.execution_time:.3f}s")
    
    # Primjer 2: Kreiranje prodajne prilike
    print("\n=== Kreiranje prodajne prilike ===")
    
    result = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    if result.success:
        print(f"Prilika kreirana: {result.data['opportunity_id']}")
    
    # Primjer 3: Grupne operacije
    print("\n=== Grupne operacije ===")
    
    tasks = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': 'Nova prilika kreirana',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    results = await asyncio.gather(*tasks)
    
    for i, result in enumerate(results):
        if result.success:
            print(f"Zadatak {i+1} uspješno dovršen")
        else:
            print(f"Zadatak {i+1} nije uspio: {result.error}")
    
    # Prikaz zapisnika revizije
    print(f"\n=== Zapisnik revizije ({len(agent.audit_log)} unosa) ===")
    for entry in agent.audit_log[-3:]:  # Prikaži zadnja 3 unosa
        print(f"{entry['timestamp']}: {entry['function_name']} - {'USPJEH' if entry['success'] else 'NEUSPJEH'}")

# Pokreni demonstraciju za poduzeće
# asyncio.run(enterprise_demo())
- **Phi-4 modeli**: [Hugging Face kolekcija](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)
- **Qwen3 dokumentacija**: [Službena Qwen dokumentacija](https://qwen.readthedocs.io/)
- **Ollama**: [Službena web stranica](https://ollama.com/)
- **Foundry Local**: [GitHub repozitorij](https://github.com/microsoft/Foundry-Local)
- **Najbolje prakse za pozivanje funkcija**: [Hugging Face vodič](https://huggingface.co/docs/hugs/en/guides/function-calling)

Zapamtite da je pozivanje funkcija područje koje se stalno razvija, a praćenje najnovijih dostignuća u odabranim okvirima i modelima pomoći će vam u izgradnji učinkovitijih AI agenata.


## ➡️ Što slijedi

- [03: Integracija Model Context Protocol (MCP)](./03.IntroduceMCP.md)

---

**Odricanje od odgovornosti**:  
Ovaj dokument je preveden pomoću AI usluge za prevođenje [Co-op Translator](https://github.com/Azure/co-op-translator). Iako nastojimo osigurati točnost, imajte na umu da automatski prijevodi mogu sadržavati pogreške ili netočnosti. Izvorni dokument na izvornom jeziku treba smatrati autoritativnim izvorom. Za ključne informacije preporučuje se profesionalni prijevod od strane čovjeka. Ne preuzimamo odgovornost za bilo kakva nesporazuma ili pogrešna tumačenja koja proizlaze iz korištenja ovog prijevoda.