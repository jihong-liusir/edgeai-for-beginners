<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8ccc4f76611daedf918e34460128fc21",
  "translation_date": "2025-09-30T23:33:31+00:00",
  "source_file": "Module08/04.CuttingEdgeModels.md",
  "language_code": "ja"
}
-->
# セッション 4: Chainlit を使った本番チャットアプリケーションの構築

## 概要

このセッションでは、Chainlit と Microsoft Foundry Local を使用して本番対応のチャットアプリケーションを構築する方法に焦点を当てます。AI会話のための最新のウェブインターフェースを作成し、ストリーミング応答を実装し、エラー処理やユーザー体験設計を備えた堅牢なチャットアプリケーションを展開する方法を学びます。

**構築する内容:**
- **Chainlit チャットアプリ**: ストリーミング応答を備えた最新のウェブUI
- **WebGPU デモ**: プライバシー重視のブラウザベース推論
- **Open WebUI 統合**: Foundry Local を使用したプロフェッショナルなチャットインターフェース
- **本番パターン**: エラー処理、監視、展開戦略

## 学習目標

- Chainlit を使用して本番対応のチャットアプリケーションを構築する
- ユーザー体験を向上させるストリーミング応答を実装する
- Foundry Local SDK の統合パターンを習得する
- 適切なエラー処理と優雅な劣化を適用する
- 異なる環境向けにチャットアプリケーションを展開および構成する
- 会話型AIのための最新ウェブUIパターンを理解する

## 前提条件

- **Foundry Local**: インストール済みで稼働中 ([インストールガイド](https://learn.microsoft.com/azure/ai-foundry/foundry-local/))
- **Python**: 3.10以降、仮想環境機能付き
- **モデル**: 少なくとも1つのモデルがロードされている (`foundry model run phi-4-mini`)
- **ブラウザ**: WebGPU対応の最新ウェブブラウザ (Chrome/Edge)
- **Docker**: Open WebUI 統合用 (オプション)

## パート 1: 最新チャットアプリケーションの理解

### アーキテクチャ概要

```
User Browser ←→ Chainlit UI ←→ Python Backend ←→ Foundry Local ←→ AI Model
      ↓              ↓              ↓              ↓            ↓
   Web UI      Event Handlers   OpenAI Client   HTTP API    Local GPU
```

### 主要技術

**Foundry Local SDK パターン:**
- `FoundryLocalManager(alias)`: 自動サービス管理
- `manager.endpoint` と `manager.api_key`: 接続詳細
- `manager.get_model_info(alias).id`: モデル識別

**Chainlit フレームワーク:**
- `@cl.on_chat_start`: チャットセッションの初期化
- `@cl.on_message`: ユーザーからのメッセージを処理
- `cl.Message().stream_token()`: リアルタイムストリーミング
- 自動UI生成とWebSocket管理

## パート 2: ローカル vs クラウドの意思決定マトリックス

### パフォーマンス特性

| 項目 | ローカル (Foundry) | クラウド (Azure OpenAI) |
|------|-------------------|-----------------------|
| **レイテンシ** | 🚀 50-200ms (ネットワーク不要) | ⏱️ 200-2000ms (ネットワーク依存) |
| **プライバシー** | 🔒 データがデバイスを離れない | ⚠️ データがクラウドに送信される |
| **コスト** | 💰 ハードウェア以外無料 | 💸 トークンごとに課金 |
| **オフライン** | ✅ インターネット不要で動作 | ❌ インターネット必須 |
| **モデルサイズ** | ⚠️ ハードウェア制限あり | ✅ 最大モデルにアクセス可能 |
| **スケーリング** | ⚠️ ハードウェア依存 | ✅ 無制限スケーリング |

### ハイブリッド戦略パターン

**ローカル優先のフォールバック:**
```python
async def hybrid_completion(prompt: str, complexity_threshold: int = 100):
    if len(prompt.split()) < complexity_threshold:
        return await local_completion(prompt)  # Fast, private
    else:
        return await cloud_completion(prompt)   # Complex reasoning
```

**タスクベースのルーティング:**
```python
async def smart_routing(prompt: str, task_type: str):
    routing_rules = {
        "code_generation": "local",     # Privacy-sensitive
        "creative_writing": "cloud",    # Benefits from larger models
        "data_analysis": "local",       # Fast iteration needed
        "research": "cloud"             # Requires broad knowledge
    }
    
    if routing_rules.get(task_type) == "local":
        return await foundry_completion(prompt)
    else:
        return await azure_completion(prompt)
```

## パート 3: サンプル 04 - Chainlit チャットアプリケーション

### クイックスタート

```cmd
# Navigate to Module08 directory  
cd Module08

# Start your preferred model
foundry model run phi-4-mini

# Run the Chainlit application (avoiding port conflicts)
chainlit run samples\04\app.py -w --port 8080
```

アプリケーションは自動的に `http://localhost:8080` で最新のチャットインターフェースを開きます。

### コア実装

サンプル 04 アプリケーションは本番対応のパターンを示します:

**自動サービス検出:**
```python
import chainlit as cl
from openai import OpenAI
from foundry_local import FoundryLocalManager

# Global variables for client and model
client = None
model_name = None

async def initialize_client():
    global client, model_name
    alias = os.environ.get("MODEL", "phi-4-mini")
    
    try:
        # Use FoundryLocalManager for proper service management
        manager = FoundryLocalManager(alias)
        model_info = manager.get_model_info(alias)
        
        client = OpenAI(
            base_url=manager.endpoint,
            api_key=manager.api_key or "not-required"
        )
        model_name = model_info.id if model_info else alias
        return True
    except Exception as e:
        # Fallback to manual configuration
        base_url = os.environ.get("BASE_URL", "http://localhost:51211")
        client = OpenAI(base_url=f"{base_url}/v1", api_key="not-required")
        model_name = alias
        return True
```

**ストリーミングチャットハンドラー:**
```python
@cl.on_message
async def main(message: cl.Message):
    # Create streaming response
    msg = cl.Message(content="")
    await msg.send()
    
    stream = client.chat.completions.create(
        model=model_name,
        messages=[
            {"role": "system", "content": "You are a helpful AI assistant."},
            {"role": "user", "content": message.content}
        ],
        stream=True
    )
    
    # Stream tokens in real-time
    for chunk in stream:
        if chunk.choices[0].delta.content:
            await msg.stream_token(chunk.choices[0].delta.content)
    
    await msg.update()
```

### 構成オプション

**環境変数:**

| 変数 | 説明 | デフォルト | 例 |
|------|------|-----------|----|
| `MODEL` | 使用するモデルのエイリアス | `phi-4-mini` | `qwen2.5-7b` |
| `BASE_URL` | Foundry Local エンドポイント | 自動検出 | `http://localhost:51211` |
| `API_KEY` | APIキー (ローカルではオプション) | `""` | `your-api-key` |

**高度な使用法:**
```cmd
# Use different model
set MODEL=qwen2.5-7b
chainlit run samples\04\app.py -w --port 8080

# Use different ports (avoid 51211 which is used by Foundry Local)
chainlit run samples\04\app.py -w --port 3000
chainlit run samples\04\app.py -w --port 5000
```

## パート 4: Jupyter ノートブックの作成と使用

### ノートブックサポートの概要

サンプル 04 には包括的な Jupyter ノートブック (`chainlit_app.ipynb`) が含まれています。これにより以下が可能です:

- **📚 教育コンテンツ**: ステップバイステップの学習資料
- **🔬 インタラクティブな探索**: コードセルを実行して実験
- **📊 視覚的デモ**: チャート、図、出力の視覚化
- **🛠️ 開発ツール**: テストとデバッグ機能

### 独自のノートブックを作成する

#### ステップ 1: Jupyter 環境のセットアップ

```cmd
# Ensure you're in the Module08 directory
cd Module08

# Activate your virtual environment
.venv\Scripts\activate

# Install Jupyter and dependencies
pip install jupyter notebook jupyterlab ipykernel
pip install -r requirements.txt

# Register the kernel for VS Code
python -m ipykernel install --user --name=foundry-local --display-name="Foundry Local"
```

#### ステップ 2: 新しいノートブックを作成

**VS Code を使用:**
1. Module08 ディレクトリで VS Code を開く
2. `.ipynb` 拡張子の新しいファイルを作成
3. プロンプトが表示されたら「Foundry Local」カーネルを選択
4. コンテンツを追加するセルを作成

**Jupyter Lab を使用:**
```cmd
# Start Jupyter Lab
jupyter lab

# Navigate to samples/04/ and create new notebook
# Choose Python 3 kernel
```

### ノートブック構造のベストプラクティス

#### セルの整理

```python
# Cell 1: Imports and Setup
import os
import sys
import chainlit as cl
from openai import OpenAI
from foundry_local import FoundryLocalManager

print("✅ Libraries imported successfully")
```

```python
# Cell 2: Configuration and Client Setup
class FoundryClientManager:
    def __init__(self, model_name="phi-4-mini"):
        self.model_name = model_name
        self.client = None
        
    def initialize_client(self):
        # Client initialization logic
        pass

# Initialize and test
client_manager = FoundryClientManager()
result = client_manager.initialize_client()
print(f"Client initialized: {result}")
```

### インタラクティブな例と演習

#### 演習 1: クライアント構成テスト

```python
# Test different configuration methods
configurations = [
    {"method": "foundry_sdk", "model": "phi-4-mini"},
    {"method": "manual", "base_url": "http://localhost:51211", "model": "qwen2.5-7b"},
]

for config in configurations:
    print(f"\n🧪 Testing {config['method']} configuration...")
    # Implementation here
    result = test_configuration(config)
    print(f"Result: {'✅ Success' if result['status'] == 'ok' else '❌ Failed'}")
```

#### 演習 2: ストリーミング応答シミュレーション

```python
import asyncio

async def simulate_streaming_response(text, delay=0.1):
    """Simulate how streaming works in Chainlit."""
    print("🌊 Simulating streaming response...")
    
    for char in text:
        print(char, end='', flush=True)
        await asyncio.sleep(delay)
    
    print("\n✅ Streaming complete!")

# Test the simulation
sample_text = "This is how streaming responses work in Chainlit applications!"
await simulate_streaming_response(sample_text)
```

## パート 5: WebGPU ブラウザ推論デモ

### 概要

WebGPU を使用すると、AIモデルをブラウザ内で直接実行でき、最大限のプライバシーとゼロインストール体験を提供します。このサンプルでは ONNX Runtime Web を使用した WebGPU 実行を示します。

### ステップ 1: WebGPU サポートを確認

**ブラウザ要件:**
- WebGPU が有効な Chrome/Edge 113+
- 確認: `chrome://gpu` → 「WebGPU」ステータスを確認
- プログラムによる確認: `if (!('gpu' in navigator)) { /* no WebGPU */ }`

### ステップ 2: WebGPU デモを作成

ディレクトリを作成: `samples/04/webgpu-demo/`

**index.html:**
```html
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>WebGPU + ONNX Runtime Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.webgpu.min.js"></script>
    <style>
        body { font-family: system-ui, sans-serif; margin: 2rem; }
        pre { background: #f5f5f5; padding: 1rem; overflow: auto; }
        .status { padding: 1rem; background: #e3f2fd; border-radius: 4px; }
    </style>
</head>
<body>
    <h1>🚀 WebGPU + Foundry Local Integration</h1>
    <div id="status" class="status">Initializing...</div>
    <pre id="output"></pre>
    <script type="module" src="./main.js"></script>
</body>
</html>
```

**main.js:**
```javascript
const statusEl = document.getElementById('status');
const outputEl = document.getElementById('output');

function log(msg) {
    outputEl.textContent += `${msg}\n`;
    console.log(msg);
}

(async () => {
    try {
        if (!('gpu' in navigator)) {
            statusEl.textContent = '❌ WebGPU not available';
            return;
        }
        
        statusEl.textContent = '🔍 WebGPU detected. Loading model...';
        
        // Use a small ONNX model for demo
        const modelUrl = 'https://huggingface.co/onnx/models/resolve/main/vision/classification/mnist-12/mnist-12.onnx';
        
        const session = await ort.InferenceSession.create(modelUrl, {
            executionProviders: ['webgpu']
        });
        
        log('✅ ONNX Runtime session created with WebGPU');
        log(`📊 Input names: ${session.inputNames.join(', ')}`);
        log(`📊 Output names: ${session.outputNames.join(', ')}`);
        
        // Create dummy input (MNIST expects 1x1x28x28)
        const inputData = new Float32Array(1 * 1 * 28 * 28).fill(0.1);
        const input = new ort.Tensor('float32', inputData, [1, 1, 28, 28]);
        
        const feeds = {};
        feeds[session.inputNames[0]] = input;
        
        const results = await session.run(feeds);
        const output = results[session.outputNames[0]];
        
        // Find prediction (argmax)
        let maxIdx = 0;
        for (let i = 1; i < output.data.length; i++) {
            if (output.data[i] > output.data[maxIdx]) maxIdx = i;
        }
        
        statusEl.textContent = '✅ WebGPU inference complete!';
        log(`🎯 Predicted class: ${maxIdx}`);
        log(`📈 Confidence scores: [${Array.from(output.data).map(x => x.toFixed(3)).join(', ')}]`);
        
    } catch (error) {
        statusEl.textContent = `❌ Error: ${error.message}`;
        log(`Error: ${error.message}`);
        console.error(error);
    }
})();
```

### ステップ 3: デモを実行

```cmd
# Create demo directory
mkdir samples\04\webgpu-demo
cd samples\04\webgpu-demo

# Save HTML and JS files, then serve
python -m http.server 5173

# Open browser to http://localhost:5173
```

## パート 6: Open WebUI 統合

### 概要

Open WebUI は、Foundry Local の OpenAI 互換 API に接続するプロフェッショナルな ChatGPT ライクなインターフェースを提供します。

### ステップ 1: 前提条件

```cmd
# Verify Foundry Local is running
foundry service status

# Start a model
foundry model run phi-4-mini

# Confirm API endpoint is accessible
curl http://localhost:51211/v1/models
```

### ステップ 2: Docker セットアップ (推奨)

```cmd
# Pull Open WebUI image
docker pull ghcr.io/open-webui/open-webui:main

# Run with Foundry Local connection
docker run -d --name open-webui -p 3000:8080 ^
  -e OPENAI_API_BASE_URL=http://host.docker.internal:51211/v1 ^
  -e OPENAI_API_KEY=foundry-local-key ^
  -v open-webui-data:/app/backend/data ^
  ghcr.io/open-webui/open-webui:main
```

**注意:** `host.docker.internal` を使用すると、Windows 上の Docker コンテナがホストマシンにアクセスできます。

### ステップ 3: 構成

1. **ブラウザを開く:** `http://localhost:3000` に移動
2. **初期セットアップ:** 管理者アカウントを作成
3. **モデル構成:**
   - 設定 → モデル → OpenAI API  
   - ベースURL: `http://host.docker.internal:51211/v1`
   - APIキー: `foundry-local-key` (任意の値で可)
4. **接続テスト:** モデルがドロップダウンに表示されるはずです

### トラブルシューティング

**一般的な問題:**

1. **接続拒否:**
   ```cmd
   # Check Foundry Local status
   foundry service ps
   netstat -ano | findstr :51211
   ```

2. **モデルが表示されない:**
   - モデルがロードされていることを確認: `foundry model list`
   - API応答を確認: `curl http://localhost:51211/v1/models`
   - Open WebUI コンテナを再起動

## パート 7: 本番展開の考慮事項

### 環境構成

**開発セットアップ:**
```cmd
# Development with auto-reload and debugging
chainlit run samples\04\app.py -w --port 8080 --debug
```

**本番展開:**
```cmd
# Production mode with optimizations
chainlit run samples\04\app.py --host 0.0.0.0 --port 8080 --no-cache
```

### 一般的なポート問題と解決策

**ポート 51211 の競合防止:**
```cmd
# Check what's using Foundry Local port
netstat -ano | findstr :51211

# Use different port for Chainlit
chainlit run samples\04\app.py -w --port 8080
```

### パフォーマンス監視

**ヘルスチェックの実装:**
```python
@cl.on_chat_start
async def health_check():
    try:
        # Test model availability
        response = client.chat.completions.create(
            model=model_name,
            messages=[{"role": "user", "content": "test"}],
            max_tokens=1
        )
        return {"status": "healthy", "model": model_name}
    except Exception as e:
        return {"status": "unhealthy", "error": str(e)}
```

## まとめ

セッション 4 では、会話型AIのための本番対応 Chainlit アプリケーションの構築について学びました。以下を習得しました:

- ✅ **Chainlit フレームワーク**: チャットアプリケーション向けの最新UIとストリーミングサポート
- ✅ **Foundry Local 統合**: SDK の使用法と構成パターン
- ✅ **WebGPU 推論**: 最大限のプライバシーを実現するブラウザベースAI
- ✅ **Open WebUI セットアップ**: プロフェッショナルなチャットインターフェースの展開
- ✅ **本番パターン**: エラー処理、監視、スケーリング

サンプル 04 アプリケーションは、Microsoft Foundry Local を通じてローカルAIモデルを活用しながら、優れたユーザー体験を提供する堅牢なチャットインターフェースを構築するためのベストプラクティスを示しています。

## 参考資料

- **[サンプル 04: Chainlit アプリケーション](samples/04/README.md)**: 完全なアプリケーションとドキュメント
- **[Chainlit 教育用ノートブック](samples/04/chainlit_app.ipynb)**: インタラクティブな学習資料
- **[Foundry Local ドキュメント](https://learn.microsoft.com/azure/ai-foundry/foundry-local/)**: プラットフォームの完全なドキュメント
- **[Chainlit ドキュメント](https://docs.chainlit.io/)**: 公式フレームワークドキュメント
- **[Open WebUI 統合ガイド](https://github.com/microsoft/foundry-local/blob/main/docs/tutorials/chat-application-with-open-web-ui.md)**: 公式チュートリアル

---

**免責事項**:  
この文書は、AI翻訳サービス [Co-op Translator](https://github.com/Azure/co-op-translator) を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があります。元の言語で記載された文書を正式な情報源としてお考えください。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解について、当方は責任を負いません。