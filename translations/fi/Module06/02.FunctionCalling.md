<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-09-18T09:53:57+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "fi"
}
-->
# Section02 : Funktiokutsut pienissä kielimalleissa (SLM)

## Sisällysluettelo
1. [Mitä funktiokutsu tarkoittaa?](../../../Module06)
2. [Miten funktiokutsut toimivat](../../../Module06)
3. [Sovelluskohteet](../../../Module06)
4. [Funktiokutsujen käyttöönotto Phi-4-mini- ja Ollama-malleilla](../../../Module06)
5. [Qwen3-funktiokutsujen käyttö](../../../Module06)
6. [Foundry Local -integraatio](../../../Module06)
7. [Parhaat käytännöt ja vianetsintä](../../../Module06)
8. [Edistyneet esimerkit](../../../Module06)

## Mitä funktiokutsu tarkoittaa?

Funktiokutsu on tehokas ominaisuus, joka mahdollistaa pienten kielimallien (SLM) vuorovaikutuksen ulkoisten työkalujen, API:iden ja palveluiden kanssa. Sen sijaan, että SLM:t rajoittuisivat vain koulutusdataansa, ne voivat nyt:

- **Yhdistää ulkoisiin API:ihin** (sääpalvelut, tietokannat, hakukoneet)
- **Suorittaa tiettyjä toimintoja** käyttäjän pyyntöjen perusteella
- **Hakea reaaliaikaista tietoa** eri lähteistä
- **Toteuttaa laskennallisia tehtäviä** erikoistyökalujen avulla
- **Ketjuttaa useita toimintoja** monimutkaisia työnkulkuja varten

Tämä ominaisuus muuttaa SLM:t staattisista tekstigeneraattoreista dynaamisiksi tekoälyagenteiksi, jotka voivat suorittaa todellisia tehtäviä.

## Miten funktiokutsut toimivat

Funktiokutsuprosessi etenee järjestelmällisen työnkulun mukaisesti:

### 1. Työkalujen integrointi
- **Ulkoiset työkalut**: SLM:t voivat yhdistyä sää-API:ihin, tietokantoihin, verkkopalveluihin ja muihin ulkoisiin järjestelmiin
- **Funktioiden määrittely**: Jokainen työkalu määritellään tietyillä parametreilla, syöte-/tulostusmuodoilla ja kuvauksilla
- **API-yhteensopivuus**: Työkalut integroidaan standardoitujen rajapintojen kautta (REST API:t, SDK:t jne.)

### 2. Funktion määrittely
Funktiot määritellään kolmen keskeisen osan avulla:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. Aikomuksen tunnistus
- **Luonnollisen kielen käsittely**: SLM analysoi käyttäjän syötteen ymmärtääkseen aikomuksen
- **Funktion valinta**: Määrittää, mitkä funktiot tarvitaan pyynnön täyttämiseksi
- **Parametrien poiminta**: Tunnistaa ja poimii tarvittavat parametrit käyttäjän viestistä

### 4. JSON-tulosteen luonti
SLM tuottaa jäsennellyn JSON-tiedoston, joka sisältää:
- Kutsuttavan funktion nimen
- Tarvittavat parametrit ja niiden arvot
- Suoritusympäristön ja metatiedot

### 5. Ulkoinen suoritus
- **Parametrien validointi**: Varmistaa, että kaikki tarvittavat parametrit ovat mukana ja oikein muotoiltuja
- **Funktion suoritus**: Sovellus suorittaa määritellyn funktion annetuilla parametreilla
- **Virheenkäsittely**: Hallitsee epäonnistumiset, aikakatkaisut ja virheelliset vastaukset

### 6. Vastausten integrointi
- **Tulosten käsittely**: Funktion tuotos palautetaan SLM:lle
- **Kontekstin integrointi**: SLM sisällyttää tulokset vastaukseensa
- **Käyttäjän viestintä**: Esittää tiedot luonnollisessa, keskustelunomaisessa muodossa

## Sovelluskohteet

### Tiedonhaku
Muunna luonnollisen kielen kyselyt jäsennellyiksi API-kutsuiksi:
- **"Näytä viimeisimmät tilaukseni"** → Tietokantakysely käyttäjän ID:llä ja päivämääräsuodattimilla
- **"Millainen sää on Tokiossa?"** → Sää-API-kutsu sijaintiparametrilla
- **"Etsi Johnin lähettämät sähköpostit viime viikolta"** → Sähköpostipalvelun kysely lähettäjän ja päivämääräsuodattimilla

### Toimintojen suoritus
Muunna käyttäjän pyynnöt tietyiksi funktiokutsuiksi:
- **"Aikatauluta kokous huomiselle klo 14"** → Kalenteri-API-integraatio
- **"Lähetä viesti tiimille"** → Viestintäalustan API
- **"Luo varmuuskopio tiedostoistani"** → Tiedostojärjestelmäoperaatio

### Laskennalliset tehtävät
Käsittele monimutkaisia matemaattisia tai loogisia operaatioita:
- **"Laske korkoa korolle $10,000 summalle 5 % korolla 10 vuodeksi"** → Rahoituslaskentafunktio
- **"Analysoi tämä datasetti trendien osalta"** → Tilastolliset analyysityökalut
- **"Optimoi tämä reitti toimitusta varten"** → Reittioptimointialgoritmit

### Tiedonkäsittelyn työnkulut
Ketjuta useita funktiokutsuja monimutkaisia operaatioita varten:
1. **Hae tietoa** useista lähteistä
2. **Jäsennä ja validoi** tiedot
3. **Muunna** tiedot vaadittuun muotoon
4. **Tallenna tulokset** sopiviin järjestelmiin
5. **Luo raportteja** tai visualisointeja

### UI/UX-integraatio
Mahdollista dynaamiset käyttöliittymäpäivitykset:
- **"Näytä myyntidata kojelaudalla"** → Kaavion luonti ja näyttö
- **"Päivitä kartta uusilla sijainneilla"** → Paikkatietojen integrointi
- **"Päivitä varastonäkymä"** → Reaaliaikainen datan synkronointi

## Funktiokutsujen käyttöönotto Phi-4-mini- ja Ollama-malleilla

Microsoftin Phi-4-mini tukee sekä yksittäisiä että rinnakkaisia funktiokutsuja Ollaman kautta. Näin voit ottaa sen käyttöön:

### Esivaatimukset
- Ollama versio 0.5.13 tai uudempi
- Phi-4-mini-malli (suositus: `phi4-mini:3.8b-fp16`)

### Asennusvaiheet

#### 1. Asenna ja käynnistä Phi-4-mini
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. Luo mukautettu ModelFile-malli
Ollaman oletusmallien rajoitusten vuoksi sinun on luotava mukautettu ModelFile seuraavalla mallilla:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. Luo mukautettu malli
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### Esimerkki yksittäisestä funktiokutsusta

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### Esimerkki rinnakkaisista funktiokutsuista

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## Qwen3-funktiokutsujen käyttö

Qwen3 tarjoaa edistyneitä funktiokutsutoimintoja erinomaisella suorituskyvyllä ja joustavuudella. Näin voit toteuttaa sen:

### Qwen-Agent-kehyksen käyttö

Qwen-Agent tarjoaa korkean tason kehyksen, joka yksinkertaistaa funktiokutsujen toteutusta:

#### Asennus
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### Perusasetukset

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### Mukautettujen funktioiden toteutus

Voit myös määritellä mukautettuja funktioita Qwen3:lle:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### Qwen3:n edistyneet ominaisuudet

#### Ajattelutilan hallinta
Qwen3 tukee dynaamista vaihtamista ajattelu- ja ei-ajattelutilojen välillä:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### Monivaiheiset funktiokutsut
Qwen3 on erinomainen useiden funktiokutsujen ketjuttamisessa:

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## Foundry Local -integraatio

Microsoftin Foundry Local tarjoaa OpenAI-yhteensopivan API:n mallien paikalliseen suorittamiseen parannetulla yksityisyydellä ja suorituskyvyllä.

### Asennus ja käyttöönotto

#### Windows
Lataa asennusohjelma [Foundry Local -julkaisusivulta](https://github.com/microsoft/Foundry-Local/releases) ja seuraa asennusohjeita.

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### Peruskäyttö

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### Foundry Localin edistyneet ominaisuudet

#### Mallien hallinta
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### Suorituskyvyn optimointi
Foundry Local valitsee automaattisesti laitteistolle parhaiten sopivan mallivaihtoehdon:
- **CUDA GPU**: Lataa GPU-optimoidut mallit
- **Qualcomm NPU**: Käyttää NPU-kiihdytettyjä versioita
- **Vain CPU**: Valitsee CPU-optimoidut mallit

## Parhaat käytännöt ja vianetsintä

### Funktiomäärittelyn parhaat käytännöt

#### 1. Selkeät ja kuvaavat nimet
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. Kattavat parametrimäärittelyt
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. Syötteen validointi ja virheenkäsittely
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### Yleiset ongelmat ja ratkaisut

#### Ongelma 1: Funktiota ei kutsuta
**Oireet**: Malli vastaa tekstillä sen sijaan, että kutsuisi funktiota

**Ratkaisut**:
1. **Tarkista funktion kuvaus**: Varmista, että se vastaa selkeästi käyttäjän aikomusta
2. **Varmista parametrimäärittelyt**: Tarkista, että kaikki tarvittavat parametrit on määritelty oikein
3. **Tarkista järjestelmäkehotus**: Sisällytä selkeät ohjeet siitä, milloin käyttää funktioita
4. **Testaa eksplisiittisillä pyynnöillä**: Kokeile "Käytä sääfunktiota saadaksesi tiedot Lontoosta"

#### Ongelma 2: Parametrit ovat virheellisiä
**Oireet**: Funktiota kutsutaan väärillä tai puuttuvilla parametreilla

**Ratkaisut**:
1. **Lisää parametriesimerkkejä**: Sisällytä esimerkkiarvoja parametrikuvauksiin
2. **Käytä enum-rajoituksia**: Rajoita parametrien arvot tiettyihin vaihtoehtoihin, jos mahdollista
3. **Toteuta oletusarvot**: Tarjoa järkevät oletusarvot valinnaisille parametreille

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### Ongelma 3: Rinnakkaiset funktiokutsut epäonnistuvat
**Oireet**: Vain yksi funktio suoritetaan, vaikka useiden pitäisi toimia

**Ratkaisut**:
1. **Tarkista mallin tuki**: Varmista, että mallisi tukee rinnakkaisia funktiokutsuja
2. **Päivitä järjestelmäkehotus**: Sisällytä "joitakin työkaluja" tai "useita työkaluja" järjestelmäviestiin
3. **Käytä sopivia malliversioita**: Phi-4-mini:3.8b-fp16 suositellaan Ollamalle

#### Ongelma 4: Mallipohjaongelmat Ollaman kanssa
**Oireet**: Funktiokutsut eivät toimi Ollaman oletusasetuksilla

**Ratkaisut**:
1. **Käytä mukautettua ModelFile-mallia**: Käytä tässä oppaassa annettua korjattua mallia
2. **Päivitä Ollama**: Varmista, että käytössäsi on versio 0.5.13 tai uudempi
3. **Tarkista mallin kvantisointi**: Korkeammat kvantisointitasot (Q8_0, fp16) toimivat paremmin kuin voimakkaasti kvantisoidut versiot

### Suorituskyvyn optimointi

#### 1. Tehokas funktiosuunnittelu
- **Pidä funktiot keskittyneinä**: Jokaisella funktiolla tulisi olla yksi selkeä tarkoitus
- **Minimoi ulkoiset riippuvuudet**: Vähennä API-kutsuja ja verkkopyyntöjä mahdollisuuksien mukaan
- **Välimuista tulokset**: Tallenna usein pyydetyt tiedot parantaaksesi vasteaikoja

#### 2. Eräajot ja asynkroniset operaatiot
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. Resurssien hallinta
- **Yhteyksien uudelleenkäyttö**: Hyödynnä tietokanta- ja API-yhteyksiä uudelleen
- **Nopeusrajoitukset**: Toteuta asianmukaiset nopeusrajoitukset ulkoisille API:ille
- **Aikakatkaisujen hallinta**: Aseta kohtuulliset aikakatkaisut kaikille ulkoisille kutsuille

## Edistyneet esimerkit

### Moniagenttinen yhteistyöjärjestelmä

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### Dynaaminen työkalujen valintajärjestelmä

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```python
import asyncio
import json
from typing import Dict, List, Any
from dataclasses import dataclass
from datetime import datetime

@dataclass
class FunctionResult:
    """Vakioformaatti kaikille funktiokutsujen tuloksille"""
    success: bool
    data: Any = None
    error: str = None
    execution_time: float = 0.0
    timestamp: datetime = None

class EnterpriseAIAgent:
    """Tuotantovalmius tekoälyagentti kattavilla funktiokutsutoiminnoilla"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.functions = {}
        self.audit_log = []
        self.rate_limiters = {}
        
        # Rekisteröi ydintoiminnot
        self._register_core_functions()
    
    def _register_core_functions(self):
        """Rekisteröi kaikki saatavilla olevat ydintoiminnot"""
        
        # CRM-toiminnot
        self.register_function(
            name="get_customer_info",
            description="Hae asiakastiedot CRM:stä",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "include_history": {"type": "boolean", "default": False}
            },
            handler=self._get_customer_info,
            rate_limit=100  # kutsua minuutissa
        )
        
        # Myyntitoiminnot
        self.register_function(
            name="create_sales_opportunity",
            description="Luo uusi myyntimahdollisuus",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "product_id": {"type": "string", "required": True},
                "estimated_value": {"type": "number", "required": True},
                "expected_close_date": {"type": "string", "required": True}
            },
            handler=self._create_sales_opportunity,
            rate_limit=50
        )
        
        # Analytiikkatoiminnot
        self.register_function(
            name="generate_sales_report",
            description="Luo myynnin suorituskykyraportti",
            parameters={
                "period": {"type": "string", "enum": ["daily", "weekly", "monthly", "quarterly"]},
                "region": {"type": "string", "required": False},
                "product_category": {"type": "string", "required": False}
            },
            handler=self._generate_sales_report,
            rate_limit=10
        )
        
        # Ilmoitustoiminnot
        self.register_function(
            name="send_notification",
            description="Lähetä ilmoitus tiimin jäsenille",
            parameters={
                "recipients": {"type": "array", "items": {"type": "string"}},
                "message": {"type": "string", "required": True},
                "priority": {"type": "string", "enum": ["low", "medium", "high"], "default": "medium"},
                "channel": {"type": "string", "enum": ["email", "slack", "teams"], "default": "email"}
            },
            handler=self._send_notification,
            rate_limit=200
        )
    
    def register_function(self, name: str, description: str, parameters: Dict, 
                         handler: callable, rate_limit: int = 60):
        """Rekisteröi uusi funktio agentille"""
        self.functions[name] = {
            'description': description,
            'parameters': parameters,
            'handler': handler,
            'rate_limit': rate_limit,
            'call_count': 0,
            'last_reset': datetime.now()
        }
    
    async def execute_function(self, function_name: str, parameters: Dict) -
Sure! Please provide the markdown file content you'd like me to translate.
"""Suorita funktio kattavalla virheenkäsittelyllä ja lokituksella"""
start_time = datetime.now()

try:
    # Tarkista, että funktio on olemassa
    if function_name not in self.functions:
        return FunctionResult(
            success=False,
            error=f"Funktiota '{function_name}' ei löytynyt",
            timestamp=start_time
        )
    
    # Tarkista nopeusrajoitukset
    if not self._check_rate_limit(function_name):
        return FunctionResult(
            success=False,
            error=f"Nopeusrajoitus ylitetty funktiolle '{function_name}'",
            timestamp=start_time
        )
    
    # Tarkista parametrit
    validation_result = self._validate_parameters(function_name, parameters)
    if not validation_result.success:
        return validation_result
    
    # Suorita funktio
    func_info = self.functions[function_name]
    handler = func_info['handler']
    
    if asyncio.iscoroutinefunction(handler):
        result_data = await handler(**parameters)
    else:
        result_data = handler(**parameters)
    
    execution_time = (datetime.now() - start_time).total_seconds()
    
    result = FunctionResult(
        success=True,
        data=result_data,
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Kirjaa onnistunut suoritus
    self._log_function_call(function_name, parameters, result)
    
    return result
    
except Exception as e:
    execution_time = (datetime.now() - start_time).total_seconds()
    result = FunctionResult(
        success=False,
        error=str(e),
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Kirjaa epäonnistunut suoritus
    self._log_function_call(function_name, parameters, result)
    
    return result

def _check_rate_limit(self, function_name: str) -> bool:
    """Tarkista, onko funktiokutsu nopeusrajoitusten puitteissa"""
    func_info = self.functions[function_name]
    now = datetime.now()
    
    # Nollaa laskuri, jos minuutti on kulunut
    if (now - func_info['last_reset']).seconds >= 60:
        func_info['call_count'] = 0
        func_info['last_reset'] = now
    
    # Tarkista, onko rajoituksen alapuolella
    if func_info['call_count'] >= func_info['rate_limit']:
        return False
    
    func_info['call_count'] += 1
    return True

def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
    """Tarkista funktion parametrit"""
    func_params = self.functions[function_name]['parameters']
    
    # Tarkista pakolliset parametrit
    for param_name, param_info in func_params.items():
        if param_info.get('required', False) and param_name not in parameters:
            return FunctionResult(
                success=False,
                error=f"Pakollinen parametri puuttuu: {param_name}"
            )
    
    # Tarkista parametrien tyypit ja rajoitukset
    for param_name, value in parameters.items():
        if param_name in func_params:
            param_info = func_params[param_name]
            
            # Tyyppitarkistus
            expected_type = param_info.get('type')
            if expected_type == 'string' and not isinstance(value, str):
                return FunctionResult(
                    success=False,
                    error=f"Parametrin '{param_name}' tulee olla merkkijono"
                )
            elif expected_type == 'number' and not isinstance(value, (int, float)):
                return FunctionResult(
                    success=False,
                    error=f"Parametrin '{param_name}' tulee olla numero"
                )
            elif expected_type == 'boolean' and not isinstance(value, bool):
                return FunctionResult(
                    success=False,
                    error=f"Parametrin '{param_name}' tulee olla totuusarvo"
                )
            
            # Enum-tarkistus
            if 'enum' in param_info and value not in param_info['enum']:
                return FunctionResult(
                    success=False,
                    error=f"Parametrin '{param_name}' tulee olla yksi seuraavista: {param_info['enum']}"
                )
    
    return FunctionResult(success=True)

def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):
    """Kirjaa funktiokutsu auditointia varten"""
    log_entry = {
        'timestamp': result.timestamp.isoformat(),
        'function_name': function_name,
        'parameters': parameters,
        'success': result.success,
        'execution_time': result.execution_time,
        'error': result.error if not result.success else None
    }
    
    self.audit_log.append(log_entry)
    
    # Kirjoita tarvittaessa ulkoiseen lokijärjestelmään
    if self.config.get('enable_external_logging', False):
        self._write_to_external_log(log_entry)

def _write_to_external_log(self, log_entry: Dict):
    """Kirjoita lokimerkintä ulkoiseen lokijärjestelmään"""
    # Toteutus riippuu käytetystä lokitusinfrastruktuurista
    # Esim. lähetys ELK-järjestelmään, CloudWatchiin jne.
    pass

# Liiketoimintafunktioiden toteutukset
async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
    """Hae asiakastiedot CRM-järjestelmästä"""
    # Simuloi tietokanta-/API-kutsu
    await asyncio.sleep(0.1)  # Simuloi verkkoviivettä
    
    customer_data = {
        'customer_id': customer_id,
        'name': 'John Doe',
        'email': 'john.doe@example.com',
        'phone': '+1-555-0123',
        'status': 'active',
        'tier': 'premium'
    }
    
    if include_history:
        customer_data['purchase_history'] = [
            {'date': '2024-01-15', 'product': 'Product A', 'amount': 1500},
            {'date': '2024-03-22', 'product': 'Product B', 'amount': 2300}
        ]
    
    return customer_data

async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                  estimated_value: float, expected_close_date: str) -> Dict:
    """Luo uusi myyntimahdollisuus"""
    # Simuloi CRM-API-kutsu
    await asyncio.sleep(0.2)
    
    opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'opportunity_id': opportunity_id,
        'customer_id': customer_id,
        'product_id': product_id,
        'estimated_value': estimated_value,
        'expected_close_date': expected_close_date,
        'status': 'open',
        'created_date': datetime.now().isoformat()
    }

async def _generate_sales_report(self, period: str, region: str = None, 
                               product_category: str = None) -> Dict:
    """Luo kattava myyntiraportti"""
    # Simuloi datan aggregointia
    await asyncio.sleep(0.5)
    
    return {
        'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
        'period': period,
        'region': region,
        'product_category': product_category,
        'total_sales': 125000.00,
        'total_opportunities': 45,
        'conversion_rate': 0.67,
        'top_products': [
            {'product_id': 'PROD-001', 'sales': 45000},
            {'product_id': 'PROD-002', 'sales': 32000}
        ],
        'generated_at': datetime.now().isoformat()
    }

async def _send_notification(self, recipients: List[str], message: str, 
                           priority: str = 'medium', channel: str = 'email') -> Dict:
    """Lähetä ilmoitus valitun kanavan kautta"""
    # Simuloi ilmoituspalvelun kutsua
    await asyncio.sleep(0.1)
    
    notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'notification_id': notification_id,
        'recipients': recipients,
        'channel': channel,
        'priority': priority,
        'status': 'sent',
        'sent_at': datetime.now().isoformat()
    }

def get_function_definitions(self) -> List[Dict]:
    """Hae OpenAI-yhteensopivat funktiomääritelmät kaikille rekisteröidyille funktioille"""
    definitions = []
    
    for func_name, func_info in self.functions.items():
        definition = {
            'name': func_name,
            'description': func_info['description'],
            'parameters': {
                'type': 'object',
                'properties': {},
                'required': []
            }
        }
        
        for param_name, param_info in func_info['parameters'].items():
            definition['parameters']['properties'][param_name] = {
                'type': param_info['type'],
                'description': param_info.get('description', '')
            }
            
            if 'enum' in param_info:
                definition['parameters']['properties'][param_name]['enum'] = param_info['enum']
            
            if 'default' in param_info:
                definition['parameters']['properties'][param_name]['default'] = param_info['default']
            
            if param_info.get('required', False):
                definition['parameters']['required'].append(param_name)
        
        definitions.append(definition)
    
    return definitions

# Käyttöesimerkki yritysintegraatiota varten
async def enterprise_demo():
    """Esittele yritystason tekoälyagentin kyvykkyyksiä"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # Esimerkki 1: Asiakaskyselyn käsittely
    print("=== Asiakaskyselyn käsittely ===")
    
    # Hae asiakastiedot
    result = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    if result.success:
        print(f"Asiakastiedot haettu: {result.data['name']}")
        print(f"Suoritusaika: {result.execution_time:.3f}s")
    
    # Esimerkki 2: Myyntimahdollisuuden luonti
    print("\n=== Myyntimahdollisuuden luonti ===")
    
    result = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    if result.success:
        print(f"Myyntimahdollisuus luotu: {result.data['opportunity_id']}")
    
    # Esimerkki 3: Eräajot
    print("\n=== Eräajot ===")
    
    tasks = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': 'Uusi mahdollisuus luotu',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    results = await asyncio.gather(*tasks)
    
    for i, result in enumerate(results):
        if result.success:
            print(f"Tehtävä {i+1} suoritettu onnistuneesti")
        else:
            print(f"Tehtävä {i+1} epäonnistui: {result.error}")
    
    # Näytä audit-loki
    print(f"\n=== Audit-loki ({len(agent.audit_log)} merkintää) ===")
    for entry in agent.audit_log[-3:]:  # Näytä viimeiset 3 merkintää
        print(f"{entry['timestamp']}: {entry['function_name']} - {'ONNISTUI' if entry['success'] else 'EPÄONNISTUI'}")

# Suorita yritysesimerkki
# asyncio.run(enterprise_demo())
- **Phi-4-mallit**: [Hugging Face -kokoelma](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)
- **Qwen3-dokumentaatio**: [Virallinen Qwen-dokumentaatio](https://qwen.readthedocs.io/)
- **Ollama**: [Virallinen verkkosivusto](https://ollama.com/)
- **Foundry Local**: [GitHub-repositorio](https://github.com/microsoft/Foundry-Local)
- **Parhaat käytännöt funktiokutsuille**: [Hugging Face -opas](https://huggingface.co/docs/hugs/en/guides/function-calling)

Muista, että funktiokutsut ovat jatkuvasti kehittyvä ala, ja pysymällä ajan tasalla valitsemiesi kehysten ja mallien uusimmista kehityksistä voit rakentaa tehokkaampia tekoälyagentteja.


## ➡️ Mitä seuraavaksi

- [03: Mallin kontekstiprotokollan (MCP) integrointi](./03.IntroduceMCP.md)

---

**Vastuuvapauslauseke**:  
Tämä asiakirja on käännetty käyttämällä tekoälypohjaista käännöspalvelua [Co-op Translator](https://github.com/Azure/co-op-translator). Vaikka pyrimme tarkkuuteen, huomioithan, että automaattiset käännökset voivat sisältää virheitä tai epätarkkuuksia. Alkuperäistä asiakirjaa sen alkuperäisellä kielellä tulisi pitää ensisijaisena lähteenä. Kriittisen tiedon osalta suositellaan ammattimaista ihmiskäännöstä. Emme ole vastuussa väärinkäsityksistä tai virhetulkinnoista, jotka johtuvat tämän käännöksen käytöstä.