<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-09-18T16:26:16+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "hu"
}
-->
# Section02 : Funkcióhívás kis nyelvi modellekben (SLM-ek)

## Tartalomjegyzék
1. [Mi az a funkcióhívás?](../../../Module06)
2. [Hogyan működik a funkcióhívás](../../../Module06)
3. [Alkalmazási forgatókönyvek](../../../Module06)
4. [Funkcióhívás beállítása Phi-4-mini és Ollama segítségével](../../../Module06)
5. [Qwen3 funkcióhívás használata](../../../Module06)
6. [Foundry Local integráció](../../../Module06)
7. [Legjobb gyakorlatok és hibaelhárítás](../../../Module06)
8. [Haladó példák](../../../Module06)

## Mi az a funkcióhívás?

A funkcióhívás egy erőteljes képesség, amely lehetővé teszi a kis nyelvi modellek (SLM-ek) számára, hogy külső eszközökkel, API-kkal és szolgáltatásokkal kommunikáljanak. Az SLM-ek így nem korlátozódnak kizárólag a tanítási adataikra, hanem képesek:

- **Kapcsolódni külső API-khoz** (időjárási szolgáltatások, adatbázisok, keresőmotorok)
- **Felhasználói kérések alapján specifikus funkciókat végrehajtani**
- **Valós idejű információkat lekérni** különböző forrásokból
- **Számítási feladatokat végrehajtani** speciális eszközök segítségével
- **Több műveletet összekapcsolni** komplex munkafolyamatokhoz

Ez a képesség átalakítja az SLM-eket statikus szöveg-generátorokból dinamikus AI ügynökökké, amelyek valós feladatokat tudnak végrehajtani.

## Hogyan működik a funkcióhívás

A funkcióhívás folyamata egy rendszerezett munkafolyamatot követ:

### 1. Eszközök integrációja
- **Külső eszközök**: Az SLM-ek képesek kapcsolódni időjárási API-khoz, adatbázisokhoz, webes szolgáltatásokhoz és más külső rendszerekhez.
- **Funkciódefiníciók**: Minden eszköz specifikus paraméterekkel, bemeneti/kimeneti formátumokkal és leírásokkal van definiálva.
- **API-kompatibilitás**: Az eszközök szabványos interfészeken keresztül integrálódnak (REST API-k, SDK-k stb.).

### 2. Funkciódefiníció
A funkciók három kulcselem alapján vannak definiálva:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. Szándékfelismerés
- **Természetes nyelvi feldolgozás**: Az SLM elemzi a felhasználói bemenetet, hogy megértse a szándékot.
- **Funkciók egyeztetése**: Meghatározza, mely funkció(k) szükségesek a kérés teljesítéséhez.
- **Paraméterek kinyerése**: Azonosítja és kinyeri a szükséges paramétereket a felhasználói üzenetből.

### 4. JSON kimenet generálása
Az SLM strukturált JSON-t generál, amely tartalmazza:
- A hívandó funkció nevét
- A szükséges paramétereket megfelelő értékekkel
- Végrehajtási kontextust és metaadatokat

### 5. Külső végrehajtás
- **Paraméterek validálása**: Ellenőrzi, hogy minden szükséges paraméter jelen van és megfelelően van formázva.
- **Funkció végrehajtása**: Az alkalmazás végrehajtja a megadott funkciót a biztosított paraméterekkel.
- **Hibakezelés**: Kezeli a hibákat, időtúllépéseket és érvénytelen válaszokat.

### 6. Válasz integrációja
- **Eredmények feldolgozása**: A funkció kimenete visszakerül az SLM-hez.
- **Kontextus integrációja**: Az SLM beépíti az eredményeket a válaszába.
- **Felhasználói kommunikáció**: Természetes, beszélgetés-szerű formában mutatja be az információt.

## Alkalmazási forgatókönyvek

### Adatlekérés
Természetes nyelvi lekérdezések átalakítása strukturált API-hívásokká:
- **"Mutasd a legutóbbi rendeléseimet"** → Adatbázis-lekérdezés felhasználói azonosítóval és dátumszűrőkkel
- **"Milyen az időjárás Tokióban?"** → Időjárási API-hívás helyszín paraméterrel
- **"Keress e-maileket Johntól múlt héten"** → E-mail szolgáltatás lekérdezése küldő és dátumszűrőkkel

### Műveletek végrehajtása
Felhasználói kérések átalakítása specifikus funkcióhívásokká:
- **"Ütemezz egy találkozót holnap 14 órára"** → Naptár API integráció
- **"Küldj üzenetet a csapatnak"** → Kommunikációs platform API
- **"Készíts biztonsági mentést a fájljaimról"** → Fájlrendszer művelet

### Számítási feladatok
Komplex matematikai vagy logikai műveletek kezelése:
- **"Számítsd ki a kamatos kamatot 10 000 dollárra 5%-os kamattal 10 évre"** → Pénzügyi számítási funkció
- **"Elemezd ezt az adatállományt trendekre"** → Statisztikai elemző eszközök
- **"Optimalizáld ezt az útvonalat kiszállításhoz"** → Útvonal-optimalizáló algoritmusok

### Adatfeldolgozási munkafolyamatok
Több funkcióhívás összekapcsolása komplex műveletekhez:
1. **Adatok lekérése** több forrásból
2. **Információk elemzése és validálása**
3. **Adatok átalakítása** a szükséges formátumba
4. **Eredmények tárolása** megfelelő rendszerekben
5. **Jelentések vagy vizualizációk generálása**

### UI/UX integráció
Dinamikus felületfrissítések engedélyezése:
- **"Mutasd az értékesítési adatokat a műszerfalon"** → Diagram generálás és megjelenítés
- **"Frissítsd a térképet új helyszínekkel"** → Térinformatikai adat integráció
- **"Frissítsd a készlet megjelenítését"** → Valós idejű adat szinkronizáció

## Funkcióhívás beállítása Phi-4-mini és Ollama segítségével

A Microsoft Phi-4-mini modellje támogatja az egyedi és párhuzamos funkcióhívásokat Ollama segítségével. Így állítható be:

### Előfeltételek
- Ollama 0.5.13 vagy újabb verzió
- Phi-4-mini modell (ajánlott: `phi4-mini:3.8b-fp16`)

### Telepítési lépések

#### 1. Phi-4-mini telepítése és futtatása
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. Egyedi ModelFile sablon létrehozása
Az Ollama alapértelmezett sablonjainak jelenlegi korlátai miatt egy egyedi ModelFile sablont kell létrehozni az alábbi sablonnal:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. Egyedi modell létrehozása
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### Egyedi funkcióhívás példa

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### Párhuzamos funkcióhívás példa

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## Qwen3 funkcióhívás használata

A Qwen3 fejlett funkcióhívási képességeket kínál kiváló teljesítménnyel és rugalmassággal. Így valósítható meg:

### Qwen-Agent keretrendszer használata

A Qwen-Agent egy magas szintű keretrendszert biztosít, amely egyszerűsíti a funkcióhívás megvalósítását:

#### Telepítés
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### Alapbeállítás

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### Egyedi funkciók megvalósítása

Egyedi funkciókat is definiálhat a Qwen3 számára:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### Haladó Qwen3 funkciók

#### Gondolkodási mód vezérlése
A Qwen3 támogatja a dinamikus váltást gondolkodási és nem gondolkodási módok között:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### Többlépcsős funkcióhívás
A Qwen3 kiválóan alkalmas több funkcióhívás összekapcsolására:

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## Foundry Local integráció

A Microsoft Foundry Local egy OpenAI-kompatibilis API-t biztosít, amely lehetővé teszi modellek helyi futtatását fokozott adatvédelemmel és teljesítménnyel.

### Beállítás és telepítés

#### Windows
Töltse le a telepítőt a [Foundry Local releases oldalról](https://github.com/microsoft/Foundry-Local/releases), és kövesse a telepítési utasításokat.

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### Alapvető használat

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### Haladó Foundry Local funkciók

#### Modellkezelés
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### Teljesítményoptimalizálás
A Foundry Local automatikusan kiválasztja a legjobb modellváltozatot a hardveréhez:
- **CUDA GPU**: GPU-optimalizált modelleket tölt le
- **Qualcomm NPU**: NPU-gyorsított változatokat használ
- **Csak CPU**: CPU-optimalizált modelleket választ

## Legjobb gyakorlatok és hibaelhárítás

### Funkciódefiníció legjobb gyakorlatai

#### 1. Egyértelmű és leíró elnevezés
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. Átfogó paraméterdefiníciók
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. Bemenet validálása és hibakezelés
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### Gyakori problémák és megoldások

#### Probléma 1: Funkció nem kerül meghívásra
**Tünetek**: A modell szöveggel válaszol a funkcióhívás helyett

**Megoldások**:
1. **Ellenőrizze a funkció leírását**: Győződjön meg róla, hogy egyértelműen illeszkedik a felhasználói szándékhoz.
2. **Ellenőrizze a paraméterdefiníciókat**: Győződjön meg róla, hogy minden szükséges paraméter megfelelően van definiálva.
3. **Rendszerprompt felülvizsgálata**: Tartalmazzon egyértelmű utasításokat arról, mikor kell funkciókat használni.
4. **Tesztelje explicit kérésekkel**: Próbálja ki: "Kérlek, használd az időjárás funkciót, hogy adatokat kapj Londonról."

#### Probléma 2: Hibás paraméterek
**Tünetek**: Funkció hibás vagy hiányzó paraméterekkel kerül meghívásra

**Megoldások**:
1. **Adjon példákat a paraméterekhez**: Tartalmazzon mintaváltozatokat a paraméterleírásokban.
2. **Használjon enum korlátozásokat**: Korlátozza a paraméterértékeket specifikus opciókra, ahol lehetséges.
3. **Alapértelmezett értékek megadása**: Biztosítson ésszerű alapértelmezett értékeket az opcionális paraméterekhez.

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### Probléma 3: Párhuzamos funkcióhívási hibák
**Tünetek**: Csak egy funkció kerül végrehajtásra, amikor többnek kellene

**Megoldások**:
1. **Ellenőrizze a modell támogatását**: Győződjön meg róla, hogy a modell támogatja a párhuzamos funkcióhívást.
2. **Rendszerprompt frissítése**: Tartalmazza a "néhány eszköz" vagy "több eszköz" kifejezést a rendszerüzenetben.
3. **Használjon megfelelő modellverziókat**: Phi-4-mini:3.8b-fp16 ajánlott Ollama esetén.

#### Probléma 4: Sablon problémák Ollama-val
**Tünetek**: A funkcióhívás nem működik az alapértelmezett Ollama beállítással

**Megoldások**:
1. **Használjon egyedi ModelFile-t**: Alkalmazza az ebben az útmutatóban megadott javított sablont.
2. **Frissítse Ollama-t**: Győződjön meg róla, hogy 0.5.13 vagy újabb verziót használ.
3. **Ellenőrizze a modell kvantálását**: Magasabb kvantálási szintek (Q8_0, fp16) jobban működnek, mint a túlzottan kvantált változatok.

### Teljesítményoptimalizálás

#### 1. Hatékony funkciótervezés
- **Tartsa a funkciókat fókuszáltan**: Minden funkciónak egyetlen, egyértelmű célja legyen.
- **Minimalizálja a külső függőségeket**: Csökkentse az API-hívásokat és hálózati kéréseket, ahol lehetséges.
- **Eredmények gyorsítótárazása**: Tárolja a gyakran kért adatokat a válaszidők javítása érdekében.

#### 2. Csoportosítás és aszinkron műveletek
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. Erőforrás-kezelés
- **Kapcsolat pooling**: Újrahasználja az adatbázis- és API-kapcsolatokat.
- **Sebességkorlátozás**: Valósítson meg megfelelő sebességkorlátozást a külső API-khoz.
- **Időtúllépés kezelése**: Állítson be ésszerű időtúllépéseket minden külső hívásra.

## Haladó példák

### Több ügynök együttműködési rendszere

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### Dinamikus eszközválasztó rendszer

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```
Please provide the markdown file content you'd like me to translate, and I'll assist you accordingly!
"""Futtass egy függvényt átfogó hibakezeléssel és naplózással"""
start_time = datetime.now()

try:
    # Ellenőrizd, hogy létezik-e a függvény
    if function_name not in self.functions:
        return FunctionResult(
            success=False,
            error=f"A '{function_name}' függvény nem található",
            timestamp=start_time
        )
    
    # Ellenőrizd a hívási korlátokat
    if not self._check_rate_limit(function_name):
        return FunctionResult(
            success=False,
            error=f"A '{function_name}' függvény hívási korlátja túllépve",
            timestamp=start_time
        )
    
    # Paraméterek ellenőrzése
    validation_result = self._validate_parameters(function_name, parameters)
    if not validation_result.success:
        return validation_result
    
    # Függvény végrehajtása
    func_info = self.functions[function_name]
    handler = func_info['handler']
    
    if asyncio.iscoroutinefunction(handler):
        result_data = await handler(**parameters)
    else:
        result_data = handler(**parameters)
    
    execution_time = (datetime.now() - start_time).total_seconds()
    
    result = FunctionResult(
        success=True,
        data=result_data,
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Sikeres végrehajtás naplózása
    self._log_function_call(function_name, parameters, result)
    
    return result
    
except Exception as e:
    execution_time = (datetime.now() - start_time).total_seconds()
    result = FunctionResult(
        success=False,
        error=str(e),
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Sikertelen végrehajtás naplózása
    self._log_function_call(function_name, parameters, result)
    
    return result

def _check_rate_limit(self, function_name: str) -> bool:
    """Ellenőrizd, hogy a függvényhívás a korlátokon belül van-e"""
    func_info = self.functions[function_name]
    now = datetime.now()
    
    # Számláló visszaállítása, ha eltelt egy perc
    if (now - func_info['last_reset']).seconds >= 60:
        func_info['call_count'] = 0
        func_info['last_reset'] = now
    
    # Ellenőrizd, hogy a korláton belül van-e
    if func_info['call_count'] >= func_info['rate_limit']:
        return False
    
    func_info['call_count'] += 1
    return True

def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
    """Függvény paraméterek ellenőrzése"""
    func_params = self.functions[function_name]['parameters']
    
    # Kötelező paraméterek ellenőrzése
    for param_name, param_info in func_params.items():
        if param_info.get('required', False) and param_name not in parameters:
            return FunctionResult(
                success=False,
                error=f"Hiányzó kötelező paraméter: {param_name}"
            )
    
    # Paraméter típusok és korlátozások ellenőrzése
    for param_name, value in parameters.items():
        if param_name in func_params:
            param_info = func_params[param_name]
            
            # Típus ellenőrzés
            expected_type = param_info.get('type')
            if expected_type == 'string' and not isinstance(value, str):
                return FunctionResult(
                    success=False,
                    error=f"A '{param_name}' paraméternek szövegnek kell lennie"
                )
            elif expected_type == 'number' and not isinstance(value, (int, float)):
                return FunctionResult(
                    success=False,
                    error=f"A '{param_name}' paraméternek számnak kell lennie"
                )
            elif expected_type == 'boolean' and not isinstance(value, bool):
                return FunctionResult(
                    success=False,
                    error=f"A '{param_name}' paraméternek logikai értéknek kell lennie"
                )
            
            # Enum ellenőrzés
            if 'enum' in param_info and value not in param_info['enum']:
                return FunctionResult(
                    success=False,
                    error=f"A '{param_name}' paraméternek az alábbiak egyikének kell lennie: {param_info['enum']}"
                )
    
    return FunctionResult(success=True)

def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):
    """Függvényhívás naplózása audit célokra"""
    log_entry = {
        'timestamp': result.timestamp.isoformat(),
        'function_name': function_name,
        'parameters': parameters,
        'success': result.success,
        'execution_time': result.execution_time,
        'error': result.error if not result.success else None
    }
    
    self.audit_log.append(log_entry)
    
    # Opcionálisan külső naplózási rendszerbe írás
    if self.config.get('enable_external_logging', False):
        self._write_to_external_log(log_entry)

def _write_to_external_log(self, log_entry: Dict):
    """Naplóbejegyzés írása külső naplózási rendszerbe"""
    # A megvalósítás a naplózási infrastruktúrától függ
    # pl. ELK stack, CloudWatch stb.
    pass

# Üzleti függvények megvalósítása
async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
    """Ügyféladatok lekérése CRM rendszerből"""
    # Adatbázis/API hívás szimulálása
    await asyncio.sleep(0.1)  # Hálózati késleltetés szimulálása
    
    customer_data = {
        'customer_id': customer_id,
        'name': 'John Doe',
        'email': 'john.doe@example.com',
        'phone': '+1-555-0123',
        'status': 'active',
        'tier': 'premium'
    }
    
    if include_history:
        customer_data['purchase_history'] = [
            {'date': '2024-01-15', 'product': 'Product A', 'amount': 1500},
            {'date': '2024-03-22', 'product': 'Product B', 'amount': 2300}
        ]
    
    return customer_data

async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                  estimated_value: float, expected_close_date: str) -> Dict:
    """Új értékesítési lehetőség létrehozása"""
    # CRM API hívás szimulálása
    await asyncio.sleep(0.2)
    
    opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'opportunity_id': opportunity_id,
        'customer_id': customer_id,
        'product_id': product_id,
        'estimated_value': estimated_value,
        'expected_close_date': expected_close_date,
        'status': 'open',
        'created_date': datetime.now().isoformat()
    }

async def _generate_sales_report(self, period: str, region: str = None, 
                               product_category: str = None) -> Dict:
    """Átfogó értékesítési jelentés generálása"""
    # Adataggregáció szimulálása
    await asyncio.sleep(0.5)
    
    return {
        'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
        'period': period,
        'region': region,
        'product_category': product_category,
        'total_sales': 125000.00,
        'total_opportunities': 45,
        'conversion_rate': 0.67,
        'top_products': [
            {'product_id': 'PROD-001', 'sales': 45000},
            {'product_id': 'PROD-002', 'sales': 32000}
        ],
        'generated_at': datetime.now().isoformat()
    }

async def _send_notification(self, recipients: List[str], message: str, 
                           priority: str = 'medium', channel: str = 'email') -> Dict:
    """Értesítés küldése a megadott csatornán keresztül"""
    # Értesítési szolgáltatás hívás szimulálása
    await asyncio.sleep(0.1)
    
    notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'notification_id': notification_id,
        'recipients': recipients,
        'channel': channel,
        'priority': priority,
        'status': 'sent',
        'sent_at': datetime.now().isoformat()
    }

def get_function_definitions(self) -> List[Dict]:
    """OpenAI-kompatibilis függvénydefiníciók lekérése az összes regisztrált függvényhez"""
    definitions = []
    
    for func_name, func_info in self.functions.items():
        definition = {
            'name': func_name,
            'description': func_info['description'],
            'parameters': {
                'type': 'object',
                'properties': {},
                'required': []
            }
        }
        
        for param_name, param_info in func_info['parameters'].items():
            definition['parameters']['properties'][param_name] = {
                'type': param_info['type'],
                'description': param_info.get('description', '')
            }
            
            if 'enum' in param_info:
                definition['parameters']['properties'][param_name]['enum'] = param_info['enum']
            
            if 'default' in param_info:
                definition['parameters']['properties'][param_name]['default'] = param_info['default']
            
            if param_info.get('required', False):
                definition['parameters']['required'].append(param_name)
        
        definitions.append(definition)
    
    return definitions

# Vállalati integráció használati példa
async def enterprise_demo():
    """Vállalati AI ügynök képességeinek bemutatása"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # Példa 1: Ügyfélmegkeresés feldolgozása
    print("=== Ügyfélmegkeresés feldolgozása ===")
    
    # Ügyféladatok lekérése
    result = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    if result.success:
        print(f"Ügyféladatok lekérve: {result.data['name']}")
        print(f"Végrehajtási idő: {result.execution_time:.3f}s")
    
    # Példa 2: Értékesítési lehetőség létrehozása
    print("\n=== Értékesítési lehetőség létrehozása ===")
    
    result = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    if result.success:
        print(f"Lehetőség létrehozva: {result.data['opportunity_id']}")
    
    # Példa 3: Csoportos műveletek
    print("\n=== Csoportos műveletek ===")
    
    tasks = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': 'Új lehetőség létrehozva',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    results = await asyncio.gather(*tasks)
    
    for i, result in enumerate(results):
        if result.success:
            print(f"{i+1}. feladat sikeresen befejezve")
        else:
            print(f"{i+1}. feladat sikertelen: {result.error}")
    
    # Audit napló megjelenítése
    print(f"\n=== Audit napló ({len(agent.audit_log)} bejegyzés) ===")
    for entry in agent.audit_log[-3:]:  # Utolsó 3 bejegyzés megjelenítése
        print(f"{entry['timestamp']}: {entry['function_name']} - {'SIKER' if entry['success'] else 'SIKERTELEN'}")

# Vállalati bemutató futtatása
# asyncio.run(enterprise_demo())

## Következtetés

A függvényhívás a Kis Nyelvi Modellekben paradigmaváltást jelent, amely lehetővé teszi, hogy a statikus AI asszisztensek dinamikus, képes ügynökökké váljanak, amelyek kapcsolatba léphetnek a valós világgal. Ez az útmutató az alábbiakat tárgyalta:

### Fő tanulságok

1. **Alapok megértése**: A függvényhívás lehetővé teszi, hogy a Kis Nyelvi Modellek túllépjenek a tanítási adatokon, és külső eszközökhöz és szolgáltatásokhoz kapcsolódjanak.

2. **Rugalmasság a megvalósításban**: Számos megközelítés létezik, az alacsony szintű egyedi sablonoktól a magas szintű keretrendszerekig, mint például a Qwen-Agent és a Foundry Local.

3. **Gyártási szempontok**: A vállalati telepítések megkövetelik a hibakezelés, hívási korlátok, biztonság és audit naplózás figyelembevételét.

4. **Teljesítmény optimalizálása**: A megfelelő függvénytervezés, hatékony végrehajtás és okos gyorsítótárazás jelentősen javíthatja a válaszidőt.

### Jövőbeli irányok

Ahogy a Kis Nyelvi Modellek technológiája tovább fejlődik, várható:

- **Pontosság javítása a függvényhívásban**: Jobb szándékfelismerés és paraméterek kinyerése
- **Fejlettebb párhuzamos feldolgozás**: Összetettebb többfüggvényes koordináció
- **Jobb integrációs szabványok**: Szabványosított protokollok az eszközök integrációjához
- **Fejlett biztonsági funkciók**: Továbbfejlesztett hitelesítési és jogosultsági mechanizmusok
- **Bővülő ökoszisztéma**: Növekvő előre elkészített függvények és integrációk könyvtára

### Kezdés

A függvényhívás megvalósításának elkezdéséhez:

1. **Kezdj egyszerűen**: Indíts alapvető, egyfüggvényes forgatókönyvekkel
2. **Válassz keretrendszert**: Dönts a közvetlen megvalósítás (Ollama/Phi-4) vagy keretrendszer-támogatott (Qwen-Agent) között
3. **Tervezd meg a függvényeket gondosan**: Koncentrálj világos, jól dokumentált függvénydefiníciókra
4. **Valósíts meg hibakezelést**: Építs robusztus hibakezelést már az elején
5. **Fokozatosan skálázd**: Haladj az egyszerűtől a komplex forgatókönyvek felé, ahogy tapasztalatot szerzel

A függvényhívás átalakítja a Kis Nyelvi Modelleket lenyűgöző szövegalkotókból gyakorlati AI ügynökökké, amelyek képesek valós problémák megoldására. Az ebben az útmutatóban bemutatott minták és gyakorlatok követésével erőteljes, megbízható AI rendszereket építhetsz, amelyek messze túlmutatnak a hagyományos chatfelületeken.

### Források és hivatkozások
- **Phi-4 modellek**: [Hugging Face gyűjtemény](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)
- **Qwen3 dokumentáció**: [Hivatalos Qwen dokumentáció](https://qwen.readthedocs.io/)
- **Ollama**: [Hivatalos weboldal](https://ollama.com/)
- **Foundry Local**: [GitHub tároló](https://github.com/microsoft/Foundry-Local)
- **Funkcióhívási legjobb gyakorlatok**: [Hugging Face útmutató](https://huggingface.co/docs/hugs/en/guides/function-calling)

Ne feledd, hogy a funkcióhívás egy folyamatosan fejlődő terület, és ha naprakész maradsz a választott keretrendszerek és modellek legújabb fejlesztéseivel, hatékonyabb AI-ügynököket építhetsz.


## ➡️ Mi következik?

- [03: Modell Kontextus Protokoll (MCP) integráció](./03.IntroduceMCP.md)

---

**Felelősség kizárása**:  
Ez a dokumentum az AI fordítási szolgáltatás [Co-op Translator](https://github.com/Azure/co-op-translator) segítségével lett lefordítva. Bár törekszünk a pontosságra, kérjük, vegye figyelembe, hogy az automatikus fordítások hibákat vagy pontatlanságokat tartalmazhatnak. Az eredeti dokumentum az eredeti nyelvén tekintendő hiteles forrásnak. Fontos információk esetén javasolt professzionális emberi fordítást igénybe venni. Nem vállalunk felelősséget semmilyen félreértésért vagy téves értelmezésért, amely a fordítás használatából eredhet.