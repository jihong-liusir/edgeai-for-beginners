<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-09-18T14:14:29+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "ms"
}
-->
# Section02 : Panggilan Fungsi dalam Model Bahasa Kecil (SLMs)

## Kandungan
1. [Apa itu Panggilan Fungsi?](../../../Module06)
2. [Bagaimana Panggilan Fungsi Berfungsi](../../../Module06)
3. [Senario Aplikasi](../../../Module06)
4. [Menyiapkan Panggilan Fungsi dengan Phi-4-mini dan Ollama](../../../Module06)
5. [Bekerja dengan Panggilan Fungsi Qwen3](../../../Module06)
6. [Integrasi Tempatan Foundry](../../../Module06)
7. [Amalan Terbaik dan Penyelesaian Masalah](../../../Module06)
8. [Contoh Lanjutan](../../../Module06)

## Apa itu Panggilan Fungsi?

Panggilan fungsi adalah keupayaan yang kuat yang membolehkan Model Bahasa Kecil (SLMs) berinteraksi dengan alat luaran, API, dan perkhidmatan. Daripada terhad kepada data latihan mereka, SLM kini boleh:

- **Berhubung dengan API luaran** (perkhidmatan cuaca, pangkalan data, enjin carian)
- **Melaksanakan fungsi tertentu** berdasarkan permintaan pengguna
- **Mengambil maklumat masa nyata** dari pelbagai sumber
- **Melakukan tugas pengiraan** melalui alat khusus
- **Menggabungkan pelbagai operasi** untuk aliran kerja yang kompleks

Keupayaan ini mengubah SLM daripada penjana teks statik kepada agen AI dinamik yang boleh melaksanakan tugas dunia nyata.

## Bagaimana Panggilan Fungsi Berfungsi

Proses panggilan fungsi mengikuti aliran kerja yang sistematik:

### 1. Integrasi Alat
- **Alat Luaran**: SLM boleh berhubung dengan API cuaca, pangkalan data, perkhidmatan web, dan sistem luaran lain
- **Definisi Fungsi**: Setiap alat ditakrifkan dengan parameter tertentu, format input/output, dan penerangan
- **Keserasian API**: Alat diintegrasikan melalui antara muka standard (REST API, SDK, dll.)

### 2. Definisi Fungsi
Fungsi ditakrifkan dengan tiga komponen utama:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. Pengesanan Niat
- **Pemprosesan Bahasa Semula Jadi**: SLM menganalisis input pengguna untuk memahami niat
- **Pencocokan Fungsi**: Menentukan fungsi mana yang diperlukan untuk memenuhi permintaan
- **Ekstraksi Parameter**: Mengenal pasti dan mengekstrak parameter yang diperlukan daripada mesej pengguna

### 4. Penjanaan Output JSON
SLM menghasilkan JSON berstruktur yang mengandungi:
- Nama fungsi untuk dipanggil
- Parameter yang diperlukan dengan nilai yang sesuai
- Konteks pelaksanaan dan metadata

### 5. Pelaksanaan Luaran
- **Pengesahan Parameter**: Memastikan semua parameter yang diperlukan hadir dan diformat dengan betul
- **Pelaksanaan Fungsi**: Aplikasi melaksanakan fungsi yang ditentukan dengan parameter yang disediakan
- **Pengendalian Ralat**: Mengurus kegagalan, tamat masa, dan respons tidak sah

### 6. Integrasi Respons
- **Pemprosesan Hasil**: Output fungsi dikembalikan kepada SLM
- **Integrasi Konteks**: SLM menggabungkan hasil ke dalam responsnya
- **Komunikasi Pengguna**: Menyampaikan maklumat dalam format perbualan yang semula jadi

## Senario Aplikasi

### Pengambilan Data
Menukar pertanyaan bahasa semula jadi kepada panggilan API berstruktur:
- **"Tunjukkan pesanan saya yang terkini"** → Pertanyaan pangkalan data dengan ID pengguna dan penapis tarikh
- **"Bagaimana cuaca di Tokyo?"** → Panggilan API cuaca dengan parameter lokasi
- **"Cari e-mel daripada John minggu lepas"** → Pertanyaan perkhidmatan e-mel dengan pengirim dan penapis tarikh

### Pelaksanaan Operasi
Menukar permintaan pengguna kepada panggilan fungsi tertentu:
- **"Jadualkan mesyuarat untuk esok jam 2 petang"** → Integrasi API kalendar
- **"Hantar mesej kepada pasukan"** → API platform komunikasi
- **"Buat sandaran fail saya"** → Operasi sistem fail

### Tugas Pengiraan
Mengendalikan operasi matematik atau logik yang kompleks:
- **"Kira faedah kompaun untuk $10,000 pada kadar 5% selama 10 tahun"** → Fungsi pengiraan kewangan
- **"Analisis dataset ini untuk trend"** → Alat analisis statistik
- **"Optimalkan laluan ini untuk penghantaran"** → Algoritma pengoptimuman laluan

### Aliran Kerja Pemprosesan Data
Menggabungkan pelbagai panggilan fungsi untuk operasi kompleks:
1. **Mengambil data** dari pelbagai sumber
2. **Memproses dan mengesahkan** maklumat
3. **Menukar** data ke format yang diperlukan
4. **Menyimpan hasil** dalam sistem yang sesuai
5. **Menjana laporan** atau visualisasi

### Integrasi UI/UX
Membolehkan kemas kini antara muka yang dinamik:
- **"Tunjukkan data jualan di papan pemuka"** → Penjanaan carta dan paparan
- **"Kemas kini peta dengan lokasi baru"** → Integrasi data geospatial
- **"Segarkan paparan inventori"** → Penyelarasan data masa nyata

## Menyiapkan Panggilan Fungsi dengan Phi-4-mini dan Ollama

Phi-4-mini Microsoft menyokong panggilan fungsi tunggal dan selari melalui Ollama. Berikut adalah cara untuk menyiapkannya:

### Prasyarat
- Ollama versi 0.5.13 atau lebih tinggi
- Model Phi-4-mini (disyorkan: `phi4-mini:3.8b-fp16`)

### Langkah Pemasangan

#### 1. Pasang dan Jalankan Phi-4-mini
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. Buat Templat ModelFile Tersuai
Disebabkan batasan semasa dalam templat lalai Ollama, anda perlu membuat ModelFile tersuai dengan templat berikut:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. Buat Model Tersuai
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### Contoh Panggilan Fungsi Tunggal

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### Contoh Panggilan Fungsi Selari

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## Bekerja dengan Panggilan Fungsi Qwen3

Qwen3 menawarkan keupayaan panggilan fungsi lanjutan dengan prestasi dan fleksibiliti yang sangat baik. Berikut adalah cara untuk melaksanakannya:

### Menggunakan Kerangka Qwen-Agent

Qwen-Agent menyediakan kerangka peringkat tinggi yang mempermudah pelaksanaan panggilan fungsi:

#### Pemasangan
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### Persediaan Asas

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### Pelaksanaan Fungsi Tersuai

Anda juga boleh mentakrifkan fungsi tersuai untuk Qwen3:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### Ciri Lanjutan Qwen3

#### Kawalan Mod Pemikiran
Qwen3 menyokong penukaran dinamik antara mod pemikiran dan bukan pemikiran:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### Panggilan Fungsi Berbilang Langkah
Qwen3 cemerlang dalam menggabungkan pelbagai panggilan fungsi:

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## Integrasi Tempatan Foundry

Foundry Tempatan Microsoft menyediakan API serasi OpenAI untuk menjalankan model secara tempatan dengan privasi dan prestasi yang dipertingkatkan.

### Persediaan dan Pemasangan

#### Windows
Muat turun pemasang dari [halaman pelepasan Foundry Tempatan](https://github.com/microsoft/Foundry-Local/releases) dan ikuti arahan pemasangan.

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### Penggunaan Asas

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### Ciri Lanjutan Foundry Tempatan

#### Pengurusan Model
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### Pengoptimuman Prestasi
Foundry Tempatan secara automatik memilih varian model terbaik untuk perkakasan anda:
- **CUDA GPU**: Memuat turun model yang dioptimumkan GPU
- **Qualcomm NPU**: Menggunakan varian yang dipercepatkan NPU
- **CPU sahaja**: Memilih model yang dioptimumkan CPU

## Amalan Terbaik dan Penyelesaian Masalah

### Amalan Terbaik Definisi Fungsi

#### 1. Penamaan yang Jelas dan Deskriptif
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. Definisi Parameter yang Komprehensif
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. Pengesahan Input dan Pengendalian Ralat
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### Isu Biasa dan Penyelesaian

#### Isu 1: Fungsi Tidak Dipanggil
**Gejala**: Model memberi respons dengan teks dan bukannya memanggil fungsi

**Penyelesaian**:
1. **Periksa penerangan fungsi**: Pastikan ia jelas sepadan dengan niat pengguna
2. **Sahkan definisi parameter**: Pastikan semua parameter yang diperlukan ditakrifkan dengan betul
3. **Semak prompt sistem**: Sertakan arahan yang jelas tentang bila menggunakan fungsi
4. **Uji dengan permintaan eksplisit**: Cuba "Sila gunakan fungsi cuaca untuk mendapatkan data untuk London"

#### Isu 2: Parameter Tidak Betul
**Gejala**: Fungsi dipanggil dengan parameter yang salah atau hilang

**Penyelesaian**:
1. **Tambah contoh parameter**: Sertakan nilai sampel dalam penerangan parameter
2. **Gunakan kekangan enum**: Hadkan nilai parameter kepada pilihan tertentu jika boleh
3. **Laksanakan nilai sandaran**: Sediakan nilai lalai yang masuk akal untuk parameter pilihan

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### Isu 3: Kegagalan Panggilan Fungsi Selari
**Gejala**: Hanya satu fungsi dilaksanakan apabila beberapa fungsi sepatutnya dijalankan

**Penyelesaian**:
1. **Periksa sokongan model**: Pastikan model anda menyokong panggilan fungsi selari
2. **Kemas kini prompt sistem**: Sertakan "beberapa alat" atau "pelbagai alat" dalam mesej sistem
3. **Gunakan versi model yang sesuai**: Phi-4-mini:3.8b-fp16 disyorkan untuk Ollama

#### Isu 4: Isu Templat dengan Ollama
**Gejala**: Panggilan fungsi tidak berfungsi dengan persediaan lalai Ollama

**Penyelesaian**:
1. **Gunakan ModelFile tersuai**: Gunakan templat yang diperbetulkan yang disediakan dalam tutorial ini
2. **Kemas kini Ollama**: Pastikan anda menggunakan versi 0.5.13 atau lebih tinggi
3. **Periksa kuantisasi model**: Tahap kuantisasi yang lebih tinggi (Q8_0, fp16) berfungsi lebih baik daripada versi yang sangat dikuantisasi

### Pengoptimuman Prestasi

#### 1. Reka Bentuk Fungsi yang Efisien
- **Pastikan fungsi fokus**: Setiap fungsi harus mempunyai tujuan tunggal yang jelas
- **Kurangkan kebergantungan luaran**: Kurangkan panggilan API dan permintaan rangkaian jika boleh
- **Cache hasil**: Simpan data yang sering diminta untuk meningkatkan masa respons

#### 2. Operasi Batching dan Async
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. Pengurusan Sumber
- **Pengumpulan sambungan**: Gunakan semula sambungan pangkalan data dan API
- **Had kadar**: Laksanakan had kadar yang sesuai untuk API luaran
- **Pengendalian tamat masa**: Tetapkan tamat masa yang munasabah untuk semua panggilan luaran

## Contoh Lanjutan

### Sistem Kolaborasi Multi-Agen

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### Sistem Pemilihan Alat Dinamik

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```python
import asyncio
import json
from typing import Dict, List, Any
from dataclasses import dataclass
from datetime import datetime

@dataclass
class FunctionResult:
    """Format hasil standard untuk semua panggilan fungsi"""
    success: bool
    data: Any = None
    error: str = None
    execution_time: float = 0.0
    timestamp: datetime = None

class EnterpriseAIAgent:
    """Agen AI siap produksi dengan keupayaan panggilan fungsi yang komprehensif"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.functions = {}
        self.audit_log = []
        self.rate_limiters = {}
        
        # Inisialisasi fungsi perniagaan teras
        self._register_core_functions()
    
    def _register_core_functions(self):
        """Daftar semua fungsi perniagaan yang tersedia"""
        
        # Fungsi CRM
        self.register_function(
            name="get_customer_info",
            description="Mengambil maklumat pelanggan dari CRM",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "include_history": {"type": "boolean", "default": False}
            },
            handler=self._get_customer_info,
            rate_limit=100  # panggilan per minit
        )
        
        # Fungsi Jualan
        self.register_function(
            name="create_sales_opportunity",
            description="Buat peluang jualan baru",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "product_id": {"type": "string", "required": True},
                "estimated_value": {"type": "number", "required": True},
                "expected_close_date": {"type": "string", "required": True}
            },
            handler=self._create_sales_opportunity,
            rate_limit=50
        )
        
        # Fungsi Analitik
        self.register_function(
            name="generate_sales_report",
            description="Menjana laporan prestasi jualan",
            parameters={
                "period": {"type": "string", "enum": ["daily", "weekly", "monthly", "quarterly"]},
                "region": {"type": "string", "required": False},
                "product_category": {"type": "string", "required": False}
            },
            handler=self._generate_sales_report,
            rate_limit=10
        )
        
        # Fungsi Pemberitahuan
        self.register_function(
            name="send_notification",
            description="Hantar pemberitahuan kepada ahli pasukan",
            parameters={
                "recipients": {"type": "array", "items": {"type": "string"}},
                "message": {"type": "string", "required": True},
                "priority": {"type": "string", "enum": ["low", "medium", "high"], "default": "medium"},
                "channel": {"type": "string", "enum": ["email", "slack", "teams"], "default": "email"}
            },
            handler=self._send_notification,
            rate_limit=200
        )
    
    def register_function(self, name: str, description: str, parameters: Dict, 
                         handler: callable, rate_limit: int = 60):
        """Daftar fungsi baru dengan agen"""
        self.functions[name] = {
            'description': description,
            'parameters': parameters,
            'handler': handler,
            'rate_limit': rate_limit,
            'call_count': 0,
            'last_reset': datetime.now()
        }
    
    async def execute_function(self, function_name: str, parameters: Dict) -
Peraturan Penting:
1. Jangan tambahkan '''markdown atau sebarang tag lain di sekitar terjemahan
2. Pastikan terjemahan tidak kedengaran terlalu literal
3. Terjemahkan komen juga
4. Fail ini ditulis dalam format Markdown - jangan anggap ia sebagai XML atau HTML
5. Jangan terjemahkan:
   - [!NOTE], [!WARNING], [!TIP], [!IMPORTANT], [!CAUTION]
   - Nama pemboleh ubah, nama fungsi, nama kelas
   - Placeholder seperti @@INLINE_CODE_x@@ atau @@CODE_BLOCK_x@@
   - URL atau laluan
6. Kekalkan semua format markdown asal
7. Hanya kembalikan kandungan yang diterjemahkan tanpa sebarang tag atau markup tambahan


"""Laksanakan fungsi dengan pengendalian ralat dan log yang menyeluruh"""
masa_mula = datetime.now()

try:
    # Sahkan fungsi wujud
    if function_name not in self.functions:
        return FunctionResult(
            success=False,
            error=f"Fungsi '{function_name}' tidak dijumpai",
            timestamp=masa_mula
        )
    
    # Periksa had kadar
    if not self._check_rate_limit(function_name):
        return FunctionResult(
            success=False,
            error=f"Had kadar melebihi untuk fungsi '{function_name}'",
            timestamp=masa_mula
        )
    
    # Sahkan parameter
    validation_result = self._validate_parameters(function_name, parameters)
    if not validation_result.success:
        return validation_result
    
    # Laksanakan fungsi
    func_info = self.functions[function_name]
    handler = func_info['handler']
    
    if asyncio.iscoroutinefunction(handler):
        result_data = await handler(**parameters)
    else:
        result_data = handler(**parameters)
    
    masa_pelaksanaan = (datetime.now() - masa_mula).total_seconds()
    
    result = FunctionResult(
        success=True,
        data=result_data,
        execution_time=masa_pelaksanaan,
        timestamp=masa_mula
    )
    
    # Log pelaksanaan berjaya
    self._log_function_call(function_name, parameters, result)
    
    return result
    
except Exception as e:
    masa_pelaksanaan = (datetime.now() - masa_mula).total_seconds()
    result = FunctionResult(
        success=False,
        error=str(e),
        execution_time=masa_pelaksanaan,
        timestamp=masa_mula
    )
    
    # Log pelaksanaan gagal
    self._log_function_call(function_name, parameters, result)
    
    return result

def _check_rate_limit(self, function_name: str) -> bool:
    """Periksa jika panggilan fungsi berada dalam had kadar"""
    func_info = self.functions[function_name]
    sekarang = datetime.now()
    
    # Tetapkan semula kaunter jika satu minit telah berlalu
    if (sekarang - func_info['last_reset']).seconds >= 60:
        func_info['call_count'] = 0
        func_info['last_reset'] = sekarang
    
    # Periksa jika di bawah had
    if func_info['call_count'] >= func_info['rate_limit']:
        return False
    
    func_info['call_count'] += 1
    return True

def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
    """Sahkan parameter fungsi"""
    func_params = self.functions[function_name]['parameters']
    
    # Periksa parameter yang diperlukan
    for param_name, param_info in func_params.items():
        if param_info.get('required', False) and param_name not in parameters:
            return FunctionResult(
                success=False,
                error=f"Parameter yang diperlukan hilang: {param_name}"
            )
    
    # Sahkan jenis parameter dan kekangan
    for param_name, value in parameters.items():
        if param_name in func_params:
            param_info = func_params[param_name]
            
            # Pengesahan jenis
            expected_type = param_info.get('type')
            if expected_type == 'string' and not isinstance(value, str):
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' mesti jenis string"
                )
            elif expected_type == 'number' and not isinstance(value, (int, float)):
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' mesti jenis nombor"
                )
            elif expected_type == 'boolean' and not isinstance(value, bool):
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' mesti jenis boolean"
                )
            
            # Pengesahan enum
            if 'enum' in param_info and value not in param_info['enum']:
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' mesti salah satu daripada: {param_info['enum']}"
                )
    
    return FunctionResult(success=True)

def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):
    """Log panggilan fungsi untuk tujuan audit"""
    log_entry = {
        'timestamp': result.timestamp.isoformat(),
        'function_name': function_name,
        'parameters': parameters,
        'success': result.success,
        'execution_time': result.execution_time,
        'error': result.error if not result.success else None
    }
    
    self.audit_log.append(log_entry)
    
    # Pilihan untuk menulis ke sistem log luaran
    if self.config.get('enable_external_logging', False):
        self._write_to_external_log(log_entry)

def _write_to_external_log(self, log_entry: Dict):
    """Tulis entri log ke sistem log luaran"""
    # Pelaksanaan bergantung pada infrastruktur log anda
    # contohnya, hantar ke ELK stack, CloudWatch, dll.
    pass

# Pelaksanaan Fungsi Perniagaan
async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
    """Dapatkan maklumat pelanggan dari sistem CRM"""
    # Simulasi panggilan pangkalan data/API
    await asyncio.sleep(0.1)  # Simulasi kelewatan rangkaian
    
    customer_data = {
        'customer_id': customer_id,
        'name': 'John Doe',
        'email': 'john.doe@example.com',
        'phone': '+1-555-0123',
        'status': 'active',
        'tier': 'premium'
    }
    
    if include_history:
        customer_data['purchase_history'] = [
            {'date': '2024-01-15', 'product': 'Product A', 'amount': 1500},
            {'date': '2024-03-22', 'product': 'Product B', 'amount': 2300}
        ]
    
    return customer_data

async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                  estimated_value: float, expected_close_date: str) -> Dict:
    """Cipta peluang jualan baru"""
    # Simulasi panggilan API CRM
    await asyncio.sleep(0.2)
    
    opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'opportunity_id': opportunity_id,
        'customer_id': customer_id,
        'product_id': product_id,
        'estimated_value': estimated_value,
        'expected_close_date': expected_close_date,
        'status': 'open',
        'created_date': datetime.now().isoformat()
    }

async def _generate_sales_report(self, period: str, region: str = None, 
                               product_category: str = None) -> Dict:
    """Hasilkan laporan jualan yang komprehensif"""
    # Simulasi pengagregatan data
    await asyncio.sleep(0.5)
    
    return {
        'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
        'period': period,
        'region': region,
        'product_category': product_category,
        'total_sales': 125000.00,
        'total_opportunities': 45,
        'conversion_rate': 0.67,
        'top_products': [
            {'product_id': 'PROD-001', 'sales': 45000},
            {'product_id': 'PROD-002', 'sales': 32000}
        ],
        'generated_at': datetime.now().isoformat()
    }

async def _send_notification(self, recipients: List[str], message: str, 
                           priority: str = 'medium', channel: str = 'email') -> Dict:
    """Hantar notifikasi melalui saluran yang ditentukan"""
    # Simulasi panggilan perkhidmatan notifikasi
    await asyncio.sleep(0.1)
    
    notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'notification_id': notification_id,
        'recipients': recipients,
        'channel': channel,
        'priority': priority,
        'status': 'sent',
        'sent_at': datetime.now().isoformat()
    }

def get_function_definitions(self) -> List[Dict]:
    """Dapatkan definisi fungsi yang serasi dengan OpenAI untuk semua fungsi yang didaftarkan"""
    definitions = []
    
    for func_name, func_info in self.functions.items():
        definition = {
            'name': func_name,
            'description': func_info['description'],
            'parameters': {
                'type': 'object',
                'properties': {},
                'required': []
            }
        }
        
        for param_name, param_info in func_info['parameters'].items():
            definition['parameters']['properties'][param_name] = {
                'type': param_info['type'],
                'description': param_info.get('description', '')
            }
            
            if 'enum' in param_info:
                definition['parameters']['properties'][param_name]['enum'] = param_info['enum']
            
            if 'default' in param_info:
                definition['parameters']['properties'][param_name]['default'] = param_info['default']
            
            if param_info.get('required', False):
                definition['parameters']['required'].append(param_name)
        
        definitions.append(definition)
    
    return definitions

# Contoh Penggunaan untuk Integrasi Enterprise
async def enterprise_demo():
    """Demonstrasi keupayaan agen AI enterprise"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # Contoh 1: Pemprosesan pertanyaan pelanggan
    print("=== Pemprosesan Pertanyaan Pelanggan ===")
    
    # Dapatkan maklumat pelanggan
    result = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    if result.success:
        print(f"Maklumat Pelanggan Diperoleh: {result.data['name']}")
        print(f"Masa Pelaksanaan: {result.execution_time:.3f}s")
    
    # Contoh 2: Penciptaan peluang jualan
    print("\n=== Penciptaan Peluang Jualan ===")
    
    result = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    if result.success:
        print(f"Peluang Dicipta: {result.data['opportunity_id']}")
    
    # Contoh 3: Operasi batch
    print("\n=== Operasi Batch ===")
    
    tasks = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': 'Peluang baru dicipta',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    results = await asyncio.gather(*tasks)
    
    for i, result in enumerate(results):
        if result.success:
            print(f"Tugas {i+1} selesai dengan berjaya")
        else:
            print(f"Tugas {i+1} gagal: {result.error}")
    
    # Paparkan log audit
    print(f"\n=== Log Audit ({len(agent.audit_log)} entri) ===")
    for entry in agent.audit_log[-3:]:  # Paparkan 3 entri terakhir
        print(f"{entry['timestamp']}: {entry['function_name']} - {'BERJAYA' if entry['success'] else 'GAGAL'}")

# Jalankan demonstrasi enterprise
# asyncio.run(enterprise_demo())

## Kesimpulan

Panggilan fungsi dalam Small Language Models mewakili perubahan paradigma daripada pembantu AI statik kepada agen dinamik yang mampu berinteraksi dengan dunia sebenar. Tutorial ini telah merangkumi:

### Poin Penting

1. **Pemahaman Asas**: Panggilan fungsi membolehkan SLM melangkaui data latihan mereka dengan menyambung kepada alat dan perkhidmatan luaran.

2. **Fleksibiliti Pelaksanaan**: Terdapat pelbagai pendekatan, daripada pelaksanaan tahap rendah dengan templat tersuai kepada rangka kerja tahap tinggi seperti Qwen-Agent dan Foundry Local.

3. **Pertimbangan Pengeluaran**: Penggunaan enterprise memerlukan perhatian kepada pengendalian ralat, had kadar, keselamatan, dan log audit.

4. **Pengoptimuman Prestasi**: Reka bentuk fungsi yang betul, pelaksanaan yang cekap, dan caching pintar boleh meningkatkan masa tindak balas dengan ketara.

### Arah Masa Depan

Dengan teknologi SLM yang terus berkembang, kita boleh menjangkakan:

- **Ketepatan Panggilan Fungsi yang Lebih Baik**: Pengesanan niat dan pengekstrakan parameter yang lebih baik
- **Pemprosesan Selari yang Dipertingkatkan**: Orkestrasi pelbagai fungsi yang lebih canggih
- **Piawaian Integrasi yang Lebih Baik**: Protokol yang diseragamkan untuk integrasi alat
- **Ciri Keselamatan Lanjutan**: Mekanisme pengesahan dan kebenaran yang dipertingkatkan
- **Ekosistem yang Diperluas**: Perpustakaan fungsi dan integrasi pra-bina yang semakin berkembang

### Memulakan

Untuk mula melaksanakan panggilan fungsi dalam projek anda:

1. **Mulakan dengan Mudah**: Bermula dengan senario fungsi tunggal asas
2. **Pilih Rangka Kerja Anda**: Pilih antara pelaksanaan langsung (Ollama/Phi-4) atau bantuan rangka kerja (Qwen-Agent)
3. **Reka Bentuk Fungsi dengan Teliti**: Fokus pada definisi fungsi yang jelas dan didokumentasikan dengan baik
4. **Laksanakan Pengendalian Ralat**: Bina pengendalian ralat yang kukuh dari awal
5. **Skala Secara Beransur-ansur**: Beralih daripada senario mudah kepada kompleks apabila anda mendapat pengalaman

Panggilan fungsi mengubah SLM daripada penjana teks yang mengagumkan kepada agen AI praktikal yang mampu menyelesaikan masalah dunia sebenar. Dengan mengikuti corak dan amalan yang digariskan dalam tutorial ini, anda boleh membina sistem AI yang kuat dan boleh dipercayai yang melangkaui antara muka sembang tradisional.

### Sumber dan Rujukan
- **Model Phi-4**: [Koleksi Hugging Face](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)
- **Dokumentasi Qwen3**: [Dokumentasi Rasmi Qwen](https://qwen.readthedocs.io/)
- **Ollama**: [Laman Web Rasmi](https://ollama.com/)
- **Foundry Local**: [Repositori GitHub](https://github.com/microsoft/Foundry-Local)
- **Amalan Terbaik Pemanggilan Fungsi**: [Panduan Hugging Face](https://huggingface.co/docs/hugs/en/guides/function-calling)

Ingat bahawa pemanggilan fungsi adalah bidang yang sentiasa berkembang, dan mengikuti perkembangan terkini dalam rangka kerja dan model pilihan anda akan membantu anda membina agen AI yang lebih berkesan.


## ➡️ Apa yang seterusnya

- [03: Integrasi Protokol Konteks Model (MCP)](./03.IntroduceMCP.md)

---

**Penafian**:  
Dokumen ini telah diterjemahkan menggunakan perkhidmatan terjemahan AI [Co-op Translator](https://github.com/Azure/co-op-translator). Walaupun kami berusaha untuk memastikan ketepatan, sila ambil perhatian bahawa terjemahan automatik mungkin mengandungi kesilapan atau ketidaktepatan. Dokumen asal dalam bahasa asalnya harus dianggap sebagai sumber yang berwibawa. Untuk maklumat yang kritikal, terjemahan manusia profesional adalah disyorkan. Kami tidak bertanggungjawab atas sebarang salah faham atau salah tafsir yang timbul daripada penggunaan terjemahan ini.