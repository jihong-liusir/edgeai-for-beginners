<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "875ceb3a2e681fba8d521e86e8cf7286",
  "translation_date": "2025-09-19T00:40:51+00:00",
  "source_file": "Module04/03.MicrosoftOlive.md",
  "language_code": "en"
}
-->
# Section 3: Microsoft Olive Optimization Suite

## Table of Contents
1. [Introduction](../../../Module04)
2. [What is Microsoft Olive?](../../../Module04)
3. [Installation](../../../Module04)
4. [Quick Start Guide](../../../Module04)
5. [Example: Converting Qwen3 to ONNX INT4](../../../Module04)
6. [Advanced Usage](../../../Module04)
7. [Best Practices](../../../Module04)
8. [Troubleshooting](../../../Module04)
9. [Additional Resources](../../../Module04)

## Introduction

Microsoft Olive is a robust and user-friendly toolkit designed for hardware-aware model optimization. It streamlines the process of preparing machine learning models for deployment across various hardware platforms. Whether you're working with CPUs, GPUs, or specialized AI accelerators, Olive helps you achieve peak performance while preserving model accuracy.

## What is Microsoft Olive?

Olive is a hardware-aware model optimization tool that integrates industry-leading techniques for model compression, optimization, and compilation. It works seamlessly with ONNX Runtime as an end-to-end inference optimization solution.

### Key Features

- **Hardware-Aware Optimization**: Automatically identifies the best optimization techniques for your target hardware.
- **40+ Built-in Optimization Components**: Includes tools for model compression, quantization, graph optimization, and more.
- **Simple CLI Interface**: Easy-to-use commands for common optimization tasks.
- **Multi-Framework Support**: Compatible with PyTorch, Hugging Face models, and ONNX.
- **Support for Popular Models**: Olive can optimize widely-used architectures like Llama, Phi, Qwen, Gemma, and others out-of-the-box.

### Benefits

- **Reduced Development Time**: Eliminates the need for manual experimentation with optimization techniques.
- **Performance Improvements**: Achieves significant speed gains (up to 6x in some cases).
- **Cross-Platform Deployment**: Optimized models can run on various hardware and operating systems.
- **Preserved Accuracy**: Ensures model quality is maintained while enhancing performance.

## Installation

### Prerequisites

- Python 3.8 or higher
- pip package manager
- Virtual environment (recommended)

### Basic Installation

Create and activate a virtual environment:

```bash
# Create virtual environment
python -m venv olive-env

# Activate virtual environment
# On Windows:
olive-env\Scripts\activate
# On macOS/Linux:
source olive-env/bin/activate
```

Install Olive with auto-optimization features:

```bash
pip install olive-ai[auto-opt]
pip install transformers onnxruntime-genai
```

### Optional Dependencies

Olive provides optional dependencies for additional functionality:

```bash
# For Azure ML integration
pip install olive-ai[azureml]

# For DirectML (Windows GPU acceleration)
pip install olive-ai[directml]

# For CPU optimization
pip install olive-ai[cpu]

# For all features
pip install olive-ai[all]
```

### Verify Installation

```bash
olive --help
```

If successful, the Olive CLI help message should appear.

## Quick Start Guide

### Your First Optimization

Optimize a small language model using Olive's auto-optimization feature:

```bash
olive auto-opt \
  --model_name_or_path HuggingFaceTB/SmolLM2-135M-Instruct \
  --output_path models/smolm2-optimized \
  --device cpu \
  --provider CPUExecutionProvider \
  --use_ort_genai \
  --precision int4 \
  --log_level 1
```

### What This Command Does

The optimization process includes: retrieving the model from the local cache, capturing the ONNX graph and storing weights in an ONNX data file, optimizing the ONNX graph, and quantizing the model to int4 using the RTN method.

### Command Parameters Explained

- `--model_name_or_path`: Hugging Face model identifier or local path.
- `--output_path`: Directory to save the optimized model.
- `--device`: Target device (cpu, gpu).
- `--provider`: Execution provider (CPUExecutionProvider, CUDAExecutionProvider, DmlExecutionProvider).
- `--use_ort_genai`: Use ONNX Runtime Generate AI for inference.
- `--precision`: Quantization precision (int4, int8, fp16).
- `--log_level`: Logging verbosity (0=minimal, 1=verbose).

## Example: Converting Qwen3 to ONNX INT4

Using the Hugging Face example at [lokinfey/Qwen3-8B-ONNX-INT4-CPU](https://huggingface.co/lokinfey/Qwen3-8B-ONNX-INT4-CPU), here's how to optimize a Qwen3 model:

### Step 1: Download Model (Optional)

To reduce download time, cache only the necessary files:

```bash
huggingface-cli download Qwen/Qwen2.5-0.5B-Instruct *.json *.safetensors *.txt
```

### Step 2: Optimize Qwen3 Model

```bash
olive auto-opt \
  --model_name_or_path Qwen/Qwen2.5-0.5B-Instruct \
  --output_path models/qwen3-onnx-int4 \
  --device cpu \
  --provider CPUExecutionProvider \
  --use_ort_genai \
  --precision int4 \
  --log_level 1
```

### Step 3: Test the Optimized Model

Use a simple Python script to test your optimized model:

```python
import onnxruntime_genai as og

# Load the optimized model
model = og.Model('models/qwen3-onnx-int4')
tokenizer = og.Tokenizer(model)

# Create a chat template
chat_template = '<|im_start|>user\n{input}<|im_end|>\n<|im_start|>assistant\n'

# Generate text
prompt = "What is machine learning?"
input_tokens = tokenizer.encode(chat_template.format(input=prompt))

params = og.GeneratorParams(model)
params.set_search_options(max_length=200)
params.input_ids = input_tokens

generator = og.Generator(model, params)

print("Generated response:")
while not generator.is_done():
    generator.compute_logits()
    generator.generate_next_token()
    
    new_token = generator.get_next_tokens()[0]
    print(tokenizer.decode([new_token]), end='', flush=True)

print()
```

### Output Structure

After optimization, the output directory will contain:

```
models/qwen3-onnx-int4/
├── model.onnx              # Optimized ONNX model
├── model.onnx.data         # Model weights
├── genai_config.json       # Generation configuration
├── tokenizer.json          # Tokenizer files
├── tokenizer_config.json
└── special_tokens_map.json
```

## Advanced Usage

### Configuration Files

For more complex optimization workflows, use JSON configuration files:

```json
{
  "input_model": {
    "type": "PyTorchModel",
    "config": {
      "hf_config": {
        "model_name": "Qwen/Qwen2.5-0.5B-Instruct",
        "task": "text-generation"
      }
    }
  },
  "systems": {
    "local_system": {
      "type": "LocalSystem",
      "config": {
        "accelerators": [
          {
            "device": "cpu",
            "execution_providers": ["CPUExecutionProvider"]
          }
        ]
      }
    }
  },
  "evaluators": {
    "common_evaluator": {
      "metrics": [
        {
          "name": "latency",
          "type": "latency",
          "sub_types": [{"name": "avg"}]
        }
      ]
    }
  },
  "passes": {
    "conversion": {
      "type": "ModelBuilder",
      "config": {
        "precision": "int4"
      }
    },
    "optimization": {
      "type": "OrtTransformersOptimization",
      "config": {
        "model_type": "gpt2"
      }
    }
  },
  "engine": {
    "search_strategy": {
      "execution_order": "joint",
      "search_algorithm": "tpe"
    },
    "evaluator": "common_evaluator",
    "host": "local_system",
    "target": "local_system",
    "cache_dir": "cache",
    "output_dir": "models/optimized"
  }
}
```

Run with configuration:

```bash
olive run --config config.json
```

### GPU Optimization

For CUDA GPU optimization:

```bash
olive auto-opt \
  --model_name_or_path Qwen/Qwen2.5-0.5B-Instruct \
  --output_path models/qwen3-gpu-int4 \
  --device gpu \
  --provider CUDAExecutionProvider \
  --use_ort_genai \
  --precision int4 \
  --log_level 1
```

For DirectML (Windows):

```bash
olive auto-opt \
  --model_name_or_path Qwen/Qwen2.5-0.5B-Instruct \
  --output_path models/qwen3-directml-int4 \
  --device gpu \
  --provider DmlExecutionProvider \
  --use_ort_genai \
  --precision int4 \
  --log_level 1
```

### Fine-tuning with Olive

Olive also supports model fine-tuning:

```bash
olive finetune \
  --model_name_or_path meta-llama/Llama-3.2-1B-Instruct \
  --data_name microsoft/dolly-15k \
  --text_template "### Question: {instruction}\n### Answer: {response}" \
  --max_steps 100 \
  --output_path models/llama-finetuned
```

## Best Practices

### 1. Model Selection
- Begin with smaller models for testing (e.g., 0.5B-7B parameters).
- Ensure your target model architecture is supported by Olive.

### 2. Hardware Considerations
- Align your optimization target with your deployment hardware.
- Use GPU optimization if you have CUDA-compatible hardware.
- Consider DirectML for Windows systems with integrated graphics.

### 3. Precision Selection
- **INT4**: Maximum compression, slight accuracy loss.
- **INT8**: Balanced size and accuracy.
- **FP16**: Minimal accuracy loss, moderate size reduction.

### 4. Testing and Validation
- Test optimized models with your specific use cases.
- Compare performance metrics (latency, throughput, accuracy).
- Use representative input data for evaluation.

### 5. Iterative Optimization
- Start with auto-optimization for quick results.
- Use configuration files for detailed control.
- Experiment with different optimization passes.

## Troubleshooting

### Common Issues

#### 1. Installation Problems
```bash
# If you encounter dependency conflicts:
pip install --upgrade pip
pip install olive-ai[auto-opt] --force-reinstall
```

#### 2. CUDA/GPU Issues
```bash
# Verify CUDA installation:
nvidia-smi

# Install correct ONNX Runtime GPU package:
pip install onnxruntime-gpu
```

#### 3. Memory Issues
- Use smaller batch sizes during optimization.
- Try higher precision quantization first (int8 instead of int4).
- Ensure sufficient disk space for model caching.

#### 4. Model Loading Errors
- Verify the model path and access permissions.
- Check if the model requires `trust_remote_code=True`.
- Ensure all necessary model files are downloaded.

### Getting Help

- **Documentation**: [microsoft.github.io/Olive](https://microsoft.github.io/Olive/)
- **GitHub Issues**: [github.com/microsoft/Olive/issues](https://github.com/microsoft/Olive/issues)
- **Examples**: [microsoft.github.io/Olive/examples.html](https://microsoft.github.io/Olive/examples.html)

## Additional Resources

### Official Links
- **GitHub Repository**: [github.com/microsoft/Olive](https://github.com/microsoft/Olive)
- **ONNX Runtime Documentation**: [onnxruntime.ai/docs/performance/olive.html](https://onnxruntime.ai/docs/performance/olive.html)
- **Hugging Face Example**: [huggingface.co/lokinfey/Qwen3-8B-ONNX-INT4-CPU](https://huggingface.co/lokinfey/Qwen3-8B-ONNX-INT4-CPU)

### Community Examples
- **Jupyter Notebooks**: Available in the Olive GitHub repository.
- **VS Code Extension**: AI Toolkit extension integrates Olive for model optimization.
- **Blog Posts**: Microsoft Open Source Blog features detailed Olive tutorials.

### Related Tools
- **ONNX Runtime**: High-performance inference engine.
- **Hugging Face Transformers**: Source of many compatible models.
- **Azure Machine Learning**: Cloud-based optimization workflows.

## ➡️ What's next

- [04: OpenVINO Toolkit Optimization Suite](./04.openvino.md)

---

**Disclaimer**:  
This document has been translated using the AI translation service [Co-op Translator](https://github.com/Azure/co-op-translator). While we aim for accuracy, please note that automated translations may include errors or inaccuracies. The original document in its native language should be regarded as the authoritative source. For critical information, professional human translation is advised. We are not responsible for any misunderstandings or misinterpretations resulting from the use of this translation.