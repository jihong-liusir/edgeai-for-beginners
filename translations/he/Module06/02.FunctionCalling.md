<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-09-18T12:23:56+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "he"
}
-->
# Section02 : קריאה לפונקציות במודלים שפתיים קטנים (SLMs)

## תוכן עניינים
1. [מהי קריאה לפונקציות?](../../../Module06)
2. [איך קריאה לפונקציות עובדת](../../../Module06)
3. [תסריטי יישום](../../../Module06)
4. [הגדרת קריאה לפונקציות עם Phi-4-mini ו-Ollama](../../../Module06)
5. [עבודה עם קריאה לפונקציות ב-Qwen3](../../../Module06)
6. [אינטגרציה מקומית עם Foundry](../../../Module06)
7. [שיטות עבודה מומלצות ופתרון תקלות](../../../Module06)
8. [דוגמאות מתקדמות](../../../Module06)

## מהי קריאה לפונקציות?

קריאה לפונקציות היא יכולת עוצמתית שמאפשרת למודלים שפתיים קטנים (SLMs) לתקשר עם כלים חיצוניים, APIs ושירותים. במקום להיות מוגבלים לנתוני האימון שלהם, SLMs יכולים כעת:

- **להתחבר ל-APIs חיצוניים** (שירותי מזג אוויר, מסדי נתונים, מנועי חיפוש)
- **לבצע פונקציות ספציפיות** בהתאם לבקשות המשתמש
- **לשלוף מידע בזמן אמת** ממקורות שונים
- **לבצע משימות חישוביות** באמצעות כלים מתמחים
- **לשרשר פעולות מרובות** ליצירת זרימות עבודה מורכבות

יכולת זו הופכת את SLMs מסתם מחוללי טקסט סטטיים לסוכני AI דינמיים שיכולים לבצע משימות בעולם האמיתי.

## איך קריאה לפונקציות עובדת

תהליך הקריאה לפונקציות פועל לפי זרימת עבודה שיטתית:

### 1. אינטגרציה עם כלים
- **כלים חיצוניים**: SLMs יכולים להתחבר ל-APIs של מזג אוויר, מסדי נתונים, שירותי רשת ומערכות חיצוניות אחרות
- **הגדרת פונקציות**: כל כלי מוגדר עם פרמטרים ספציפיים, פורמטים של קלט/פלט ותיאורים
- **תאימות ל-API**: כלים משולבים דרך ממשקים סטנדרטיים (REST APIs, SDKs וכו')

### 2. הגדרת פונקציות
פונקציות מוגדרות עם שלושה מרכיבים עיקריים:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. זיהוי כוונה
- **עיבוד שפה טבעית**: ה-SLM מנתח את קלט המשתמש כדי להבין את הכוונה
- **התאמת פונקציות**: קובע אילו פונקציות נדרשות כדי למלא את הבקשה
- **שליפת פרמטרים**: מזהה ומוציא את הפרמטרים הנדרשים מהודעת המשתמש

### 4. יצירת פלט JSON
ה-SLM מייצר JSON מובנה המכיל:
- שם הפונקציה שיש לקרוא לה
- פרמטרים נדרשים עם ערכים מתאימים
- הקשר ביצוע ומטא-נתונים

### 5. ביצוע חיצוני
- **אימות פרמטרים**: מוודא שכל הפרמטרים הנדרשים קיימים ומעוצבים נכון
- **ביצוע פונקציה**: האפליקציה מבצעת את הפונקציה שצוינה עם הפרמטרים שסופקו
- **טיפול בשגיאות**: מנהלת כשלונות, פסקי זמן ותשובות לא תקינות

### 6. שילוב תגובה
- **עיבוד תוצאות**: פלט הפונקציה מוחזר ל-SLM
- **שילוב הקשר**: ה-SLM משלב את התוצאות בתשובתו
- **תקשורת עם המשתמש**: מציג את המידע בפורמט טבעי ושיחתי

## תסריטי יישום

### שליפת נתונים
המרת שאילתות בשפה טבעית לקריאות API מובנות:
- **"הראה לי את ההזמנות האחרונות שלי"** → שאילתת מסד נתונים עם מזהה משתמש ומסנני תאריכים
- **"מה מזג האוויר בטוקיו?"** → קריאת API למזג אוויר עם פרמטר מיקום
- **"מצא אימיילים מג'ון בשבוע שעבר"** → שאילתת שירות אימייל עם שולח ומסנני תאריכים

### ביצוע פעולות
המרת בקשות משתמש לקריאות פונקציה ספציפיות:
- **"קבע פגישה למחר בשעה 14:00"** → אינטגרציה עם API של לוח שנה
- **"שלח הודעה לצוות"** → API של פלטפורמת תקשורת
- **"צור גיבוי לקבצים שלי"** → פעולה במערכת קבצים

### משימות חישוביות
טיפול בפעולות מתמטיות או לוגיות מורכבות:
- **"חשב ריבית דריבית על $10,000 ב-5% ל-10 שנים"** → פונקציית חישוב פיננסי
- **"נתח את מערך הנתונים הזה למגמות"** → כלים לניתוח סטטיסטי
- **"אופטימיזציה למסלול הזה למשלוח"** → אלגוריתמים לאופטימיזציה של מסלול

### זרימות עבודה לעיבוד נתונים
שרשור קריאות פונקציה מרובות לפעולות מורכבות:
1. **שליפת נתונים** ממקורות מרובים
2. **ניתוח ואימות** המידע
3. **המרת נתונים** לפורמט הנדרש
4. **אחסון תוצאות** במערכות המתאימות
5. **יצירת דוחות** או ויזואליזציות

### אינטגרציה עם ממשק משתמש/חוויית משתמש
אפשרות לעדכונים דינמיים בממשק:
- **"הראה נתוני מכירות בלוח הבקרה"** → יצירת גרף והצגה
- **"עדכן את המפה עם מיקומים חדשים"** → אינטגרציה עם נתונים גיאוגרפיים
- **"רענן את תצוגת המלאי"** → סנכרון נתונים בזמן אמת

## הגדרת קריאה לפונקציות עם Phi-4-mini ו-Ollama

Phi-4-mini של Microsoft תומך בקריאה לפונקציות יחידניות ובמקביל דרך Ollama. כך ניתן להגדיר זאת:

### דרישות מוקדמות
- גרסה 0.5.13 או גבוהה יותר של Ollama
- מודל Phi-4-mini (מומלץ: `phi4-mini:3.8b-fp16`)

### שלבי התקנה

#### 1. התקן והפעל את Phi-4-mini
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. צור תבנית ModelFile מותאמת אישית
בגלל מגבלות נוכחיות בתבניות ברירת המחדל של Ollama, יש ליצור ModelFile מותאם אישית עם התבנית הבאה:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. צור את המודל המותאם אישית
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### דוגמה לקריאה לפונקציה יחידנית

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### דוגמה לקריאה לפונקציות במקביל

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## עבודה עם קריאה לפונקציות ב-Qwen3

Qwen3 מציע יכולות מתקדמות לקריאה לפונקציות עם ביצועים וגמישות מעולים. כך ניתן ליישם זאת:

### שימוש במסגרת Qwen-Agent

Qwen-Agent מספק מסגרת ברמה גבוהה שמפשטת את יישום הקריאה לפונקציות:

#### התקנה
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### הגדרה בסיסית

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### יישום פונקציות מותאמות אישית

ניתן גם להגדיר פונקציות מותאמות אישית עבור Qwen3:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### תכונות מתקדמות של Qwen3

#### שליטה במצב חשיבה
Qwen3 תומך במעבר דינמי בין מצב חשיבה למצב לא-חשיבה:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### קריאה לפונקציות מרובות שלבים
Qwen3 מצטיין בשרשור קריאות פונקציות מרובות:

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## אינטגרציה מקומית עם Foundry

Foundry Local של Microsoft מספק API תואם OpenAI להפעלת מודלים באופן מקומי עם פרטיות וביצועים משופרים.

### הגדרה והתקנה

#### Windows
הורד את המתקין מדף [השחרורים של Foundry Local](https://github.com/microsoft/Foundry-Local/releases) ופעל לפי הוראות ההתקנה.

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### שימוש בסיסי

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### תכונות מתקדמות של Foundry Local

#### ניהול מודלים
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### אופטימיזציית ביצועים
Foundry Local בוחר אוטומטית את גרסת המודל הטובה ביותר עבור החומרה שלך:
- **CUDA GPU**: מוריד מודלים מותאמים ל-GPU
- **Qualcomm NPU**: משתמש בגרסאות מואצות NPU
- **רק CPU**: בוחר מודלים מותאמים ל-CPU

## שיטות עבודה מומלצות ופתרון תקלות

### שיטות עבודה מומלצות להגדרת פונקציות

#### 1. שמות ברורים ותיאוריים
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. הגדרות פרמטרים מקיפות
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. אימות קלט וטיפול בשגיאות
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### בעיות נפוצות ופתרונות

#### בעיה 1: פונקציה לא נקראת
**תסמינים**: המודל מגיב בטקסט במקום לקרוא לפונקציה

**פתרונות**:
1. **בדוק את תיאור הפונקציה**: ודא שהוא תואם בבירור לכוונת המשתמש
2. **אמת הגדרות פרמטרים**: ודא שכל הפרמטרים הנדרשים מוגדרים כראוי
3. **סקור את ההנחיה המערכתית**: כלול הוראות ברורות מתי להשתמש בפונקציות
4. **בדוק עם בקשות מפורשות**: נסה "אנא השתמש בפונקציית מזג האוויר כדי לקבל נתונים עבור לונדון"

#### בעיה 2: פרמטרים שגויים
**תסמינים**: פונקציה נקראת עם פרמטרים שגויים או חסרים

**פתרונות**:
1. **הוסף דוגמאות לפרמטרים**: כלול ערכי דוגמה בתיאורי הפרמטרים
2. **השתמש במגבלות enum**: הגבל ערכי פרמטרים לאפשרויות ספציפיות כשאפשר
3. **הטמע ערכי ברירת מחדל**: ספק ערכי ברירת מחדל הגיוניים עבור פרמטרים אופציונליים

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### בעיה 3: כשלונות בקריאה לפונקציות במקביל
**תסמינים**: רק פונקציה אחת מבוצעת כאשר אמורות להתבצע מספר פונקציות

**פתרונות**:
1. **בדוק תמיכת מודל**: ודא שהמודל שלך תומך בקריאה לפונקציות במקביל
2. **עדכן את ההנחיה המערכתית**: כלול "כמה כלים" או "כלים מרובים" בהודעת המערכת
3. **השתמש בגרסאות מודל מתאימות**: מומלץ Phi-4-mini:3.8b-fp16 עבור Ollama

#### בעיה 4: בעיות בתבניות עם Ollama
**תסמינים**: קריאה לפונקציות לא עובדת עם הגדרת ברירת המחדל של Ollama

**פתרונות**:
1. **השתמש ב-ModelFile מותאם אישית**: יישם את התבנית המתוקנת שסופקה במדריך זה
2. **עדכן את Ollama**: ודא שאתה משתמש בגרסה 0.5.13 או גבוהה יותר
3. **בדוק כימות מודל**: רמות כימות גבוהות יותר (Q8_0, fp16) עובדות טוב יותר מגרסאות כמותיות מאוד

### אופטימיזציית ביצועים

#### 1. עיצוב פונקציות יעיל
- **שמור על פונקציות ממוקדות**: כל פונקציה צריכה להיות בעלת מטרה אחת ברורה
- **מזער תלות חיצונית**: צמצם קריאות API ובקשות רשת ככל האפשר
- **שמור תוצאות**: אחסן נתונים מבוקשים לעיתים קרובות כדי לשפר את זמני התגובה

#### 2. פעולות אצווה ואסינכרוניות
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. ניהול משאבים
- **Pooling חיבורים**: השתמש מחדש בחיבורים למסדי נתונים ו-APIs
- **הגבלת קצב**: הטמע הגבלת קצב נכונה עבור APIs חיצוניים
- **טיפול בפסקי זמן**: הגדר פסקי זמן סבירים לכל הקריאות החיצוניות

## דוגמאות מתקדמות

### מערכת שיתוף פעולה מרובת סוכנים

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### מערכת בחירת כלים דינמית

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```python
import asyncio
import json
from typing import Dict, List, Any
from dataclasses import dataclass
from datetime import datetime

@dataclass
class FunctionResult:
    """פורמט תוצאה סטנדרטי לכל קריאות הפונקציות"""
    success: bool
    data: Any = None
    error: str = None
    execution_time: float = 0.0
    timestamp: datetime = None

class EnterpriseAIAgent:
    """סוכן AI מוכן לייצור עם יכולות קריאה לפונקציות מקיפות"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.functions = {}
        self.audit_log = []
        self.rate_limiters = {}
        
        # אתחל פונקציות עסקיות מרכזיות
        self._register_core_functions()
    
    def _register_core_functions(self):
        """רשום את כל הפונקציות העסקיות הזמינות"""
        
        # פונקציות CRM
        self.register_function(
            name="get_customer_info",
            description="שליפת מידע על לקוח מ-CRM",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "include_history": {"type": "boolean", "default": False}
            },
            handler=self._get_customer_info,
            rate_limit=100  # קריאות לדקה
        )
        
        # פונקציות מכירה
        self.register_function(
            name="create_sales_opportunity",
            description="יצירת הזדמנות מכירה חדשה",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "product_id": {"type": "string", "required": True},
                "estimated_value": {"type": "number", "required": True},
                "expected_close_date": {"type": "string", "required": True}
            },
            handler=self._create_sales_opportunity,
            rate_limit=50
        )
        
        # פונקציות אנליטיקה
        self.register_function(
            name="generate_sales_report",
            description="יצירת דוח ביצועי מכירות",
            parameters={
                "period": {"type": "string", "enum": ["daily", "weekly", "monthly", "quarterly"]},
                "region": {"type": "string", "required": False},
                "product_category": {"type": "string", "required": False}
            },
            handler=self._generate_sales_report,
            rate_limit=10
        )
        
        # פונקציות התראה
        self.register_function(
            name="send_notification",
            description="שליחת התראה לחברי צוות",
            parameters={
                "recipients": {"type": "array", "items": {"type": "string"}},
                "message": {"type": "string", "required": True},
                "priority": {"type": "string", "enum": ["low", "medium", "high"], "default": "medium"},
                "channel": {"type": "string", "enum": ["email", "slack", "teams"], "default": "email"}
            },
            handler=self._send_notification,
            rate_limit=200
        )
    
    def register_function(self, name: str, description: str, parameters: Dict, 
                         handler: callable, rate_limit: int = 60):
        """רשום פונקציה חדשה עם הסוכן"""
        self.functions[name] = {
            'description': description,
            'parameters': parameters,
            'handler': handler,
            'rate_limit': rate_limit,
            'call_count': 0,
            'last_reset': datetime.now()
        }
    
    async def execute_function(self, function_name: str, parameters: Dict) -
תוצאה של הפונקציה:

## מבוא

הפונקציה @@INLINE_CODE_1@@ מחזירה את התוצאה של חישוב המבוסס על הקלט שסופק. היא מיועדת לשימוש במגוון תרחישים, כולל ניתוח נתונים, חישובים מתמטיים, ועוד.

[!NOTE] הפונקציה אינה משנה את הקלט המקורי אלא מחזירה ערך חדש.

---

## פרמטרים

- @@INLINE_CODE_2@@: ערך הקלט הראשי. חייב להיות מספרי.
- @@INLINE_CODE_3@@: פרמטר אופציונלי שמגדיר את רמת הדיוק של החישוב.

---

## דוגמה לשימוש

```python
result = FunctionResult(5, precision=2)
print(result)
```

---

## הערות

[!WARNING] יש לוודא שהקלט תואם את הדרישות המוגדרות, אחרת הפונקציה עשויה להחזיר שגיאה.

[!TIP] השתמשו בפרמטר @@INLINE_CODE_3@@ כדי לשפר את דיוק התוצאה במקרים בהם נדרשת רמת דיוק גבוהה.

---

## שגיאות נפוצות

[!IMPORTANT] אם הקלט אינו מספרי, הפונקציה תזרוק חריגת @@INLINE_CODE_4@@.

[!CAUTION] שימוש בערכים גדולים מאוד עבור @@INLINE_CODE_2@@ עשוי לגרום לזמני עיבוד ארוכים.

---

## סיכום

הפונקציה @@INLINE_CODE_1@@ היא כלי רב עוצמה לחישובים מדויקים ומהירים. הקפידו לעקוב אחר ההנחיות כדי להבטיח שימוש נכון ויעיל.
"""בצע פונקציה עם טיפול מקיף בשגיאות ורישום"""
זמן התחלה = datetime.now()

נסה:
    # בדוק אם הפונקציה קיימת
    אם function_name לא נמצא ב-self.functions:
        החזר FunctionResult(
            success=False,
            error=f"פונקציה '{function_name}' לא נמצאה",
            timestamp=זמן התחלה
        )
    
    # בדוק מגבלות קצב
    אם לא self._check_rate_limit(function_name):
        החזר FunctionResult(
            success=False,
            error=f"חריגה ממגבלת הקצב עבור הפונקציה '{function_name}'",
            timestamp=זמן התחלה
        )
    
    # בדוק פרמטרים
    validation_result = self._validate_parameters(function_name, parameters)
    אם לא validation_result.success:
        החזר validation_result
    
    # בצע את הפונקציה
    func_info = self.functions[function_name]
    handler = func_info['handler']
    
    אם asyncio.iscoroutinefunction(handler):
        result_data = await handler(**parameters)
    אחרת:
        result_data = handler(**parameters)
    
    זמן ביצוע = (datetime.now() - זמן התחלה).total_seconds()
    
    תוצאה = FunctionResult(
        success=True,
        data=result_data,
        execution_time=זמן ביצוע,
        timestamp=זמן התחלה
    )
    
    # רשום ביצוע מוצלח
    self._log_function_call(function_name, parameters, תוצאה)
    
    החזר תוצאה
    
למעט Exception כ-e:
    זמן ביצוע = (datetime.now() - זמן התחלה).total_seconds()
    תוצאה = FunctionResult(
        success=False,
        error=str(e),
        execution_time=זמן ביצוע,
        timestamp=זמן התחלה
    )
    
    # רשום ביצוע שנכשל
    self._log_function_call(function_name, parameters, תוצאה)
    
    החזר תוצאה

def _check_rate_limit(self, function_name: str) -> bool:
    """בדוק אם קריאת הפונקציה נמצאת בתוך מגבלות הקצב"""
    func_info = self.functions[function_name]
    עכשיו = datetime.now()
    
    # אפס את המונה אם עברו דקה
    אם (עכשיו - func_info['last_reset']).seconds >= 60:
        func_info['call_count'] = 0
        func_info['last_reset'] = עכשיו
    
    # בדוק אם מתחת למגבלה
    אם func_info['call_count'] >= func_info['rate_limit']:
        החזר False
    
    func_info['call_count'] += 1
    החזר True

def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
    """בדוק את הפרמטרים של הפונקציה"""
    func_params = self.functions[function_name]['parameters']
    
    # בדוק פרמטרים נדרשים
    עבור param_name, param_info ב-func_params.items():
        אם param_info.get('required', False) ו-param_name לא נמצא ב-parameters:
            החזר FunctionResult(
                success=False,
                error=f"חסר פרמטר נדרש: {param_name}"
            )
    
    # בדוק סוגי פרמטרים ומגבלות
    עבור param_name, value ב-parameters.items():
        אם param_name ב-func_params:
            param_info = func_params[param_name]
            
            # בדיקת סוג
            expected_type = param_info.get('type')
            אם expected_type == 'string' ולא isinstance(value, str):
                החזר FunctionResult(
                    success=False,
                    error=f"פרמטר '{param_name}' חייב להיות מסוג מחרוזת"
                )
            elif expected_type == 'number' ולא isinstance(value, (int, float)):
                החזר FunctionResult(
                    success=False,
                    error=f"פרמטר '{param_name}' חייב להיות מספר"
                )
            elif expected_type == 'boolean' ולא isinstance(value, bool):
                החזר FunctionResult(
                    success=False,
                    error=f"פרמטר '{param_name}' חייב להיות בוליאני"
                )
            
            # בדיקת ערכים אפשריים
            אם 'enum' ב-param_info ו-value לא נמצא ב-param_info['enum']:
                החזר FunctionResult(
                    success=False,
                    error=f"פרמטר '{param_name}' חייב להיות אחד מ: {param_info['enum']}"
                )
    
    החזר FunctionResult(success=True)

def _log_function_call(self, function_name: str, parameters: Dict, תוצאה: FunctionResult):
    """רשום קריאת פונקציה לצורכי ביקורת"""
    log_entry = {
        'timestamp': תוצאה.timestamp.isoformat(),
        'function_name': function_name,
        'parameters': parameters,
        'success': תוצאה.success,
        'execution_time': תוצאה.execution_time,
        'error': תוצאה.error אם לא תוצאה.success אחרת None
    }
    
    self.audit_log.append(log_entry)
    
    # אפשרות לכתיבה למערכת רישום חיצונית
    אם self.config.get('enable_external_logging', False):
        self._write_to_external_log(log_entry)

def _write_to_external_log(self, log_entry: Dict):
    """כתוב רשומת רישום למערכת רישום חיצונית"""
    # היישום תלוי בתשתית הרישום שלך
    # לדוגמה, שלח ל-ELK stack, CloudWatch וכו'.
    pass

# יישומי פונקציות עסקיות
async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
    """שלוף מידע על לקוח ממערכת CRM"""
    # סימולציה של קריאה למסד נתונים/API
    await asyncio.sleep(0.1)  # סימולציה של עיכוב רשת
    
    customer_data = {
        'customer_id': customer_id,
        'name': 'John Doe',
        'email': 'john.doe@example.com',
        'phone': '+1-555-0123',
        'status': 'active',
        'tier': 'premium'
    }
    
    אם include_history:
        customer_data['purchase_history'] = [
            {'date': '2024-01-15', 'product': 'Product A', 'amount': 1500},
            {'date': '2024-03-22', 'product': 'Product B', 'amount': 2300}
        ]
    
    החזר customer_data

async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                  estimated_value: float, expected_close_date: str) -> Dict:
    """צור הזדמנות מכירה חדשה"""
    # סימולציה של קריאה ל-API CRM
    await asyncio.sleep(0.2)
    
    opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    החזר {
        'opportunity_id': opportunity_id,
        'customer_id': customer_id,
        'product_id': product_id,
        'estimated_value': estimated_value,
        'expected_close_date': expected_close_date,
        'status': 'open',
        'created_date': datetime.now().isoformat()
    }

async def _generate_sales_report(self, period: str, region: str = None, 
                               product_category: str = None) -> Dict:
    """צור דוח מכירות מקיף"""
    # סימולציה של איסוף נתונים
    await asyncio.sleep(0.5)
    
    החזר {
        'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
        'period': period,
        'region': region,
        'product_category': product_category,
        'total_sales': 125000.00,
        'total_opportunities': 45,
        'conversion_rate': 0.67,
        'top_products': [
            {'product_id': 'PROD-001', 'sales': 45000},
            {'product_id': 'PROD-002', 'sales': 32000}
        ],
        'generated_at': datetime.now().isoformat()
    }

async def _send_notification(self, recipients: List[str], message: str, 
                           priority: str = 'medium', channel: str = 'email') -> Dict:
    """שלח הודעה דרך ערוץ מוגדר"""
    # סימולציה של קריאה לשירות הודעות
    await asyncio.sleep(0.1)
    
    notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    החזר {
        'notification_id': notification_id,
        'recipients': recipients,
        'channel': channel,
        'priority': priority,
        'status': 'sent',
        'sent_at': datetime.now().isoformat()
    }

def get_function_definitions(self) -> List[Dict]:
    """קבל הגדרות פונקציות תואמות OpenAI עבור כל הפונקציות הרשומות"""
    definitions = []
    
    עבור func_name, func_info ב-self.functions.items():
        definition = {
            'name': func_name,
            'description': func_info['description'],
            'parameters': {
                'type': 'object',
                'properties': {},
                'required': []
            }
        }
        
        עבור param_name, param_info ב-func_info['parameters'].items():
            definition['parameters']['properties'][param_name] = {
                'type': param_info['type'],
                'description': param_info.get('description', '')
            }
            
            אם 'enum' ב-param_info:
                definition['parameters']['properties'][param_name]['enum'] = param_info['enum']
            
            אם 'default' ב-param_info:
                definition['parameters']['properties'][param_name]['default'] = param_info['default']
            
            אם param_info.get('required', False):
                definition['parameters']['required'].append(param_name)
        
        definitions.append(definition)
    
    החזר definitions

# דוגמה לשימוש עבור אינטגרציה ארגונית
async def enterprise_demo():
    """הדגמה של יכולות סוכן AI ארגוני"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # דוגמה 1: עיבוד פניות לקוח
    print("=== עיבוד פניות לקוח ===")
    
    # שלוף מידע על לקוח
    תוצאה = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    אם תוצאה.success:
        print(f"מידע על לקוח נשלף: {תוצאה.data['name']}")
        print(f"זמן ביצוע: {תוצאה.execution_time:.3f} שניות")
    
    # דוגמה 2: יצירת הזדמנות מכירה
    print("\n=== יצירת הזדמנות מכירה ===")
    
    תוצאה = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    אם תוצאה.success:
        print(f"הזדמנות נוצרה: {תוצאה.data['opportunity_id']}")
    
    # דוגמה 3: פעולות בקבוצות
    print("\n=== פעולות בקבוצות ===")
    
    משימות = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': 'נוצרה הזדמנות חדשה',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    תוצאות = await asyncio.gather(*משימות)
    
    עבור i, תוצאה ב-enumerate(תוצאות):
        אם תוצאה.success:
            print(f"משימה {i+1} הושלמה בהצלחה")
        אחרת:
            print(f"משימה {i+1} נכשלה: {תוצאה.error}")
    
    # הצג יומן ביקורת
    print(f"\n=== יומן ביקורת ({len(agent.audit_log)} רשומות) ===")
    עבור רשומה ב-agent.audit_log[-3:]:  # הצג 3 הרשומות האחרונות
        print(f"{רשומה['timestamp']}: {רשומה['function_name']} - {'SUCCESS' אם רשומה['success'] אחרת 'FAILED'}")

# הפעל את הדגמת הארגון
# asyncio.run(enterprise_demo())
- **Phi-4 Models**: [Hugging Face Collection](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)  
- **תיעוד Qwen3**: [תיעוד רשמי של Qwen](https://qwen.readthedocs.io/)  
- **Ollama**: [אתר רשמי](https://ollama.com/)  
- **Foundry Local**: [מאגר GitHub](https://github.com/microsoft/Foundry-Local)  
- **שיטות עבודה מומלצות לקריאה לפונקציות**: [מדריך Hugging Face](https://huggingface.co/docs/hugs/en/guides/function-calling)  

זכרו שקריאה לפונקציות היא תחום שמתפתח כל הזמן, ועדכון שוטף לגבי ההתפתחויות האחרונות במסגרת ובמודלים שבחרתם יסייע לכם לבנות סוכני AI יעילים יותר.  

## ➡️ מה הלאה  

- [03: שילוב פרוטוקול הקשר מודל (MCP)](./03.IntroduceMCP.md)  

---

**כתב ויתור**:  
מסמך זה תורגם באמצעות שירות תרגום מבוסס בינה מלאכותית [Co-op Translator](https://github.com/Azure/co-op-translator). למרות שאנו שואפים לדיוק, יש להיות מודעים לכך שתרגומים אוטומטיים עשויים להכיל שגיאות או אי דיוקים. המסמך המקורי בשפתו המקורית צריך להיחשב כמקור הסמכותי. עבור מידע קריטי, מומלץ להשתמש בתרגום מקצועי על ידי אדם. איננו נושאים באחריות לאי הבנות או לפרשנויות שגויות הנובעות משימוש בתרגום זה.