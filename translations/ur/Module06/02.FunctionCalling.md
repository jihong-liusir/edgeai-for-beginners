<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-09-17T17:29:51+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "ur"
}
-->
# سیکشن 02: چھوٹے زبان ماڈلز (SLMs) میں فنکشن کالنگ

## فہرستِ مضامین
1. [فنکشن کالنگ کیا ہے؟](../../../Module06)
2. [فنکشن کالنگ کیسے کام کرتی ہے؟](../../../Module06)
3. [ایپلیکیشن کے منظرنامے](../../../Module06)
4. [Phi-4-mini اور Ollama کے ساتھ فنکشن کالنگ سیٹ اپ کرنا](../../../Module06)
5. [Qwen3 فنکشن کالنگ کے ساتھ کام کرنا](../../../Module06)
6. [Foundry Local انٹیگریشن](../../../Module06)
7. [بہترین طریقے اور مسائل کا حل](../../../Module06)
8. [ایڈوانس مثالیں](../../../Module06)

## فنکشن کالنگ کیا ہے؟

فنکشن کالنگ ایک طاقتور صلاحیت ہے جو چھوٹے زبان ماڈلز (SLMs) کو بیرونی ٹولز، APIs، اور سروسز کے ساتھ تعامل کرنے کی اجازت دیتی ہے۔ یہ ماڈلز کو ان کے تربیتی ڈیٹا تک محدود رکھنے کے بجائے انہیں درج ذیل کام کرنے کے قابل بناتی ہے:

- **بیرونی APIs سے جڑنا** (موسمی سروسز، ڈیٹا بیس، سرچ انجن)
- **صارف کی درخواستوں کے مطابق مخصوص فنکشنز کو انجام دینا**
- **مختلف ذرائع سے حقیقی وقت کی معلومات حاصل کرنا**
- **خصوصی ٹولز کے ذریعے حسابی کام انجام دینا**
- **پیچیدہ ورک فلو کے لیے متعدد آپریشنز کو جوڑنا**

یہ صلاحیت SLMs کو جامد ٹیکسٹ جنریٹرز سے حقیقی دنیا کے کام انجام دینے والے متحرک AI ایجنٹس میں تبدیل کرتی ہے۔

## فنکشن کالنگ کیسے کام کرتی ہے؟

فنکشن کالنگ کا عمل ایک منظم ورک فلو کی پیروی کرتا ہے:

### 1. ٹول انٹیگریشن
- **بیرونی ٹولز**: SLMs موسمی APIs، ڈیٹا بیس، ویب سروسز، اور دیگر بیرونی نظاموں سے جڑ سکتے ہیں
- **فنکشن کی تعریفیں**: ہر ٹول مخصوص پیرامیٹرز، ان پٹ/آؤٹ پٹ فارمیٹس، اور وضاحتوں کے ساتھ بیان کیا جاتا ہے
- **API مطابقت**: ٹولز کو معیاری انٹرفیسز (REST APIs، SDKs وغیرہ) کے ذریعے مربوط کیا جاتا ہے

### 2. فنکشن کی تعریف
فنکشنز تین اہم اجزاء کے ساتھ بیان کیے جاتے ہیں:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. ارادے کا پتہ لگانا
- **قدرتی زبان کی پروسیسنگ**: SLM صارف کے ان پٹ کا تجزیہ کرتا ہے تاکہ ارادے کو سمجھ سکے
- **فنکشن کا انتخاب**: یہ طے کرتا ہے کہ صارف کی درخواست کو پورا کرنے کے لیے کون سا فنکشن ضروری ہے
- **پیرامیٹرز نکالنا**: صارف کے پیغام سے مطلوبہ پیرامیٹرز کی شناخت اور نکالنا

### 4. JSON آؤٹ پٹ جنریشن
SLM ایک منظم JSON تیار کرتا ہے جس میں شامل ہوتا ہے:
- کال کرنے کے لیے فنکشن کا نام
- مطلوبہ پیرامیٹرز کے ساتھ مناسب اقدار
- عملدرآمد کا سیاق و سباق اور میٹا ڈیٹا

### 5. بیرونی عملدرآمد
- **پیرامیٹرز کی توثیق**: یقینی بناتا ہے کہ تمام مطلوبہ پیرامیٹرز موجود ہیں اور صحیح طور پر فارمیٹ کیے گئے ہیں
- **فنکشن کا عملدرآمد**: ایپلیکیشن فراہم کردہ پیرامیٹرز کے ساتھ مخصوص فنکشن کو انجام دیتی ہے
- **خرابیوں کا انتظام**: ناکامیوں، ٹائم آؤٹس، اور غلط جوابات کو سنبھالتا ہے

### 6. جواب کا انضمام
- **نتائج کی پروسیسنگ**: فنکشن آؤٹ پٹ SLM کو واپس کیا جاتا ہے
- **سیاق و سباق کا انضمام**: SLM نتائج کو اپنے جواب میں شامل کرتا ہے
- **صارف سے بات چیت**: معلومات کو قدرتی، گفتگو کے انداز میں پیش کرتا ہے

## ایپلیکیشن کے منظرنامے

### ڈیٹا حاصل کرنا
قدرتی زبان کی درخواستوں کو منظم API کالز میں تبدیل کریں:
- **"میرے حالیہ آرڈرز دکھائیں"** → صارف ID اور تاریخ کے فلٹرز کے ساتھ ڈیٹا بیس کی درخواست
- **"ٹوکیو میں موسم کیسا ہے؟"** → مقام پیرامیٹر کے ساتھ موسمی API کال
- **"پچھلے ہفتے جان کے ای میلز تلاش کریں"** → بھیجنے والے اور تاریخ کے فلٹرز کے ساتھ ای میل سروس کی درخواست

### آپریشن انجام دینا
صارف کی درخواستوں کو مخصوص فنکشن کالز میں تبدیل کریں:
- **"کل دوپہر 2 بجے کے لیے میٹنگ شیڈول کریں"** → کیلنڈر API انٹیگریشن
- **"ٹیم کو پیغام بھیجیں"** → کمیونیکیشن پلیٹ فارم API
- **"میری فائلز کا بیک اپ بنائیں"** → فائل سسٹم آپریشن

### حسابی کام
پیچیدہ ریاضی یا منطقی آپریشنز کو سنبھالیں:
- **"$10,000 پر 5% شرح سود کے ساتھ 10 سال کے لیے کمپاؤنڈ انٹرسٹ کا حساب لگائیں"** → مالیاتی حسابی فنکشن
- **"اس ڈیٹا سیٹ کا رجحانات کے لیے تجزیہ کریں"** → شماریاتی تجزیہ کے ٹولز
- **"ڈلیوری کے لیے اس راستے کو بہتر بنائیں"** → راستے کی اصلاح کے الگورتھمز

### ڈیٹا پروسیسنگ ورک فلو
پیچیدہ آپریشنز کے لیے متعدد فنکشن کالز کو جوڑیں:
1. **مختلف ذرائع سے ڈیٹا حاصل کریں**
2. **معلومات کو پارس اور توثیق کریں**
3. **ڈیٹا کو مطلوبہ فارمیٹ میں تبدیل کریں**
4. **نتائج کو مناسب نظاموں میں محفوظ کریں**
5. **رپورٹس یا ویژولائزیشنز تیار کریں**

### UI/UX انٹیگریشن
متحرک انٹرفیس اپڈیٹس کو فعال کریں:
- **"ڈیش بورڈ پر سیلز ڈیٹا دکھائیں"** → چارٹ جنریشن اور ڈسپلے
- **"نئے مقامات کے ساتھ نقشہ اپڈیٹ کریں"** → جغرافیائی ڈیٹا انٹیگریشن
- **"انونٹری ڈسپلے کو ریفریش کریں"** → حقیقی وقت کے ڈیٹا کی ہم آہنگی

## Phi-4-mini اور Ollama کے ساتھ فنکشن کالنگ سیٹ اپ کرنا

مائیکروسافٹ کا Phi-4-mini Ollama کے ذریعے سنگل اور متوازی فنکشن کالنگ دونوں کو سپورٹ کرتا ہے۔ اسے سیٹ اپ کرنے کا طریقہ یہ ہے:

### ضروریات
- Ollama ورژن 0.5.13 یا اس سے زیادہ
- Phi-4-mini ماڈل (تجویز کردہ: `phi4-mini:3.8b-fp16`)

### انسٹالیشن کے مراحل

#### 1. Phi-4-mini انسٹال اور چلائیں
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. کسٹم ModelFile ٹیمپلیٹ بنائیں
Ollama کے ڈیفالٹ ٹیمپلیٹس میں موجودہ حدود کی وجہ سے، آپ کو درج ذیل ٹیمپلیٹ کے ساتھ ایک کسٹم ModelFile بنانا ہوگا:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. کسٹم ماڈل بنائیں
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### سنگل فنکشن کالنگ کی مثال

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### متوازی فنکشن کالنگ کی مثال

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## Qwen3 فنکشن کالنگ کے ساتھ کام کرنا

Qwen3 بہترین کارکردگی اور لچک کے ساتھ ایڈوانس فنکشن کالنگ کی صلاحیتیں فراہم کرتا ہے۔ اسے نافذ کرنے کا طریقہ یہ ہے:

### Qwen-Agent فریم ورک کا استعمال

Qwen-Agent ایک اعلیٰ سطحی فریم ورک فراہم کرتا ہے جو فنکشن کالنگ کے نفاذ کو آسان بناتا ہے:

#### انسٹالیشن
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### بنیادی سیٹ اپ

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### کسٹم فنکشن کا نفاذ

آپ Qwen3 کے لیے کسٹم فنکشنز بھی بیان کر سکتے ہیں:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### Qwen3 کی ایڈوانس خصوصیات

#### تھنکنگ موڈ کنٹرول
Qwen3 سوچنے اور غیر سوچنے والے موڈز کے درمیان متحرک سوئچنگ کو سپورٹ کرتا ہے:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### ملٹی-اسٹیپ فنکشن کالنگ
Qwen3 متعدد فنکشن کالز کو جوڑنے میں مہارت رکھتا ہے:

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## Foundry Local انٹیگریشن

مائیکروسافٹ کا Foundry Local ماڈلز کو مقامی طور پر چلانے کے لیے ایک OpenAI-مطابقت پذیر API فراہم کرتا ہے، جس میں بہتر پرائیویسی اور کارکردگی شامل ہے۔

### سیٹ اپ اور انسٹالیشن

#### ونڈوز
[Foundry Local ریلیز پیج](https://github.com/microsoft/Foundry-Local/releases) سے انسٹالر ڈاؤن لوڈ کریں اور انسٹالیشن کی ہدایات پر عمل کریں۔

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### بنیادی استعمال

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### Foundry Local کی ایڈوانس خصوصیات

#### ماڈل مینجمنٹ
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### کارکردگی کی اصلاح
Foundry Local خود بخود آپ کے ہارڈویئر کے لیے بہترین ماڈل ویریئنٹ کا انتخاب کرتا ہے:
- **CUDA GPU**: GPU-آپٹمائزڈ ماڈلز ڈاؤن لوڈ کرتا ہے
- **Qualcomm NPU**: NPU-تیز شدہ ویریئنٹس استعمال کرتا ہے
- **CPU-only**: CPU-آپٹمائزڈ ماڈلز کا انتخاب کرتا ہے

## بہترین طریقے اور مسائل کا حل

### فنکشن کی تعریف کے بہترین طریقے

#### 1. واضح اور وضاحتی نام
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. جامع پیرامیٹر کی تعریفیں
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. ان پٹ کی توثیق اور خرابیوں کا انتظام
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### عام مسائل اور ان کے حل

#### مسئلہ 1: فنکشن کال نہیں ہو رہا
**علامات**: ماڈل ٹیکسٹ کے ساتھ جواب دیتا ہے بجائے فنکشن کال کرنے کے

**حل**:
1. **فنکشن کی وضاحت چیک کریں**: یقینی بنائیں کہ یہ صارف کے ارادے سے واضح طور پر میل کھاتا ہے
2. **پیرامیٹر کی تعریفوں کی تصدیق کریں**: یقینی بنائیں کہ تمام مطلوبہ پیرامیٹرز صحیح طور پر بیان کیے گئے ہیں
3. **سسٹم پرامپٹ کا جائزہ لیں**: واضح ہدایات شامل کریں کہ کب فنکشنز استعمال کیے جائیں
4. **واضح درخواستوں کے ساتھ ٹیسٹ کریں**: "براہ کرم لندن کے لیے ڈیٹا حاصل کرنے کے لیے موسمی فنکشن استعمال کریں" آزمائیں

#### مسئلہ 2: غلط پیرامیٹرز
**علامات**: فنکشن غلط یا گمشدہ پیرامیٹرز کے ساتھ کال کیا جاتا ہے

**حل**:
1. **پیرامیٹر کی مثالیں شامل کریں**: پیرامیٹر کی وضاحتوں میں نمونہ اقدار شامل کریں
2. **enum پابندیاں استعمال کریں**: پیرامیٹر کی اقدار کو مخصوص اختیارات تک محدود کریں جہاں ممکن ہو
3. **فال بیک اقدار نافذ کریں**: اختیاری پیرامیٹرز کے لیے معقول ڈیفالٹس فراہم کریں

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### مسئلہ 3: متوازی فنکشن کالنگ کی ناکامی
**علامات**: جب متعدد فنکشنز کو چلنا چاہیے تو صرف ایک فنکشن چلتا ہے

**حل**:
1. **ماڈل سپورٹ چیک کریں**: یقینی بنائیں کہ آپ کا ماڈل متوازی فنکشن کالنگ کو سپورٹ کرتا ہے
2. **سسٹم پرامپٹ اپڈیٹ کریں**: سسٹم میسج میں "کچھ ٹولز" یا "متعدد ٹولز" شامل کریں
3. **مناسب ماڈل ورژنز استعمال کریں**: Ollama کے لیے Phi-4-mini:3.8b-fp16 تجویز کردہ ہے

#### مسئلہ 4: Ollama کے ساتھ ٹیمپلیٹ کے مسائل
**علامات**: ڈیفالٹ Ollama سیٹ اپ کے ساتھ فنکشن کالنگ کام نہیں کرتی

**حل**:
1. **کسٹم ModelFile استعمال کریں**: اس ٹیوٹوریل میں فراہم کردہ درست ٹیمپلیٹ کو اپلائی کریں
2. **Ollama اپڈیٹ کریں**: یقینی بنائیں کہ آپ ورژن 0.5.13 یا اس سے زیادہ استعمال کر رہے ہیں
3. **ماڈل کوانٹائزیشن چیک کریں**: زیادہ کوانٹائزیشن لیولز (Q8_0، fp16) کم کوانٹائزڈ ورژنز کے مقابلے میں بہتر کام کرتے ہیں

### کارکردگی کی اصلاح

#### 1. مؤثر فنکشن ڈیزائن
- **فنکشنز کو مرکوز رکھیں**: ہر فنکشن کا ایک واحد، واضح مقصد ہونا چاہیے
- **بیرونی انحصار کو کم کریں**: جہاں ممکن ہو API کالز اور نیٹ ورک درخواستوں کو کم کریں
- **نتائج کو کیش کریں**: جواب کے وقت کو بہتر بنانے کے لیے اکثر درخواست کردہ ڈیٹا کو محفوظ کریں

#### 2. بیچنگ اور غیر متزامن آپریشنز
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. وسائل کا انتظام
- **کنکشن پولنگ**: ڈیٹا بیس اور API کنکشنز کو دوبارہ استعمال کریں
- **ریٹ لمٹنگ**: بیرونی APIs کے لیے مناسب ریٹ لمٹنگ نافذ کریں
- **ٹائم آؤٹ ہینڈلنگ**: تمام بیرونی کالز کے لیے معقول ٹائم آؤٹس سیٹ کریں

## ایڈوانس مثالیں

### ملٹی-ایجنٹ تعاون کا نظام

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### متحرک ٹول انتخاب کا نظام

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```
نتیجہ فنکشن
"""ایک فنکشن کو جامع ایرر ہینڈلنگ اور لاگنگ کے ساتھ چلائیں"""
start_time = datetime.now()

try:
    # چیک کریں کہ فنکشن موجود ہے
    if function_name not in self.functions:
        return FunctionResult(
            success=False,
            error=f"فنکشن '{function_name}' نہیں ملا",
            timestamp=start_time
        )
    
    # ریٹ لیمٹس چیک کریں
    if not self._check_rate_limit(function_name):
        return FunctionResult(
            success=False,
            error=f"فنکشن '{function_name}' کے لیے ریٹ لیمٹ ختم ہو گئی ہے",
            timestamp=start_time
        )
    
    # پیرامیٹرز کی تصدیق کریں
    validation_result = self._validate_parameters(function_name, parameters)
    if not validation_result.success:
        return validation_result
    
    # فنکشن کو چلائیں
    func_info = self.functions[function_name]
    handler = func_info['handler']
    
    if asyncio.iscoroutinefunction(handler):
        result_data = await handler(**parameters)
    else:
        result_data = handler(**parameters)
    
    execution_time = (datetime.now() - start_time).total_seconds()
    
    result = FunctionResult(
        success=True,
        data=result_data,
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # کامیاب عملدرآمد کو لاگ کریں
    self._log_function_call(function_name, parameters, result)
    
    return result
    
except Exception as e:
    execution_time = (datetime.now() - start_time).total_seconds()
    result = FunctionResult(
        success=False,
        error=str(e),
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # ناکام عملدرآمد کو لاگ کریں
    self._log_function_call(function_name, parameters, result)
    
    return result

def _check_rate_limit(self, function_name: str) -> bool:
    """چیک کریں کہ فنکشن کال ریٹ لیمٹس کے اندر ہے"""
    func_info = self.functions[function_name]
    now = datetime.now()
    
    # اگر ایک منٹ گزر گیا ہے تو کاؤنٹر ری سیٹ کریں
    if (now - func_info['last_reset']).seconds >= 60:
        func_info['call_count'] = 0
        func_info['last_reset'] = now
    
    # چیک کریں کہ لیمٹ کے اندر ہے
    if func_info['call_count'] >= func_info['rate_limit']:
        return False
    
    func_info['call_count'] += 1
    return True

def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
    """فنکشن پیرامیٹرز کی تصدیق کریں"""
    func_params = self.functions[function_name]['parameters']
    
    # مطلوبہ پیرامیٹرز چیک کریں
    for param_name, param_info in func_params.items():
        if param_info.get('required', False) and param_name not in parameters:
            return FunctionResult(
                success=False,
                error=f"مطلوبہ پیرامیٹر غائب ہے: {param_name}"
            )
    
    # پیرامیٹرز کی اقسام اور حدود کی تصدیق کریں
    for param_name, value in parameters.items():
        if param_name in func_params:
            param_info = func_params[param_name]
            
            # قسم کی تصدیق
            expected_type = param_info.get('type')
            if expected_type == 'string' and not isinstance(value, str):
                return FunctionResult(
                    success=False,
                    error=f"پیرامیٹر '{param_name}' ایک سٹرنگ ہونا چاہیے"
                )
            elif expected_type == 'number' and not isinstance(value, (int, float)):
                return FunctionResult(
                    success=False,
                    error=f"پیرامیٹر '{param_name}' ایک نمبر ہونا چاہیے"
                )
            elif expected_type == 'boolean' and not isinstance(value, bool):
                return FunctionResult(
                    success=False,
                    error=f"پیرامیٹر '{param_name}' ایک بولین ہونا چاہیے"
                )
            
            # اینم کی تصدیق
            if 'enum' in param_info and value not in param_info['enum']:
                return FunctionResult(
                    success=False,
                    error=f"پیرامیٹر '{param_name}' ان میں سے ایک ہونا چاہیے: {param_info['enum']}"
                )
    
    return FunctionResult(success=True)

def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):
    """فنکشن کال کو آڈٹ کے مقاصد کے لیے لاگ کریں"""
    log_entry = {
        'timestamp': result.timestamp.isoformat(),
        'function_name': function_name,
        'parameters': parameters,
        'success': result.success,
        'execution_time': result.execution_time,
        'error': result.error if not result.success else None
    }
    
    self.audit_log.append(log_entry)
    
    # اختیاری طور پر بیرونی لاگنگ سسٹم میں لکھیں
    if self.config.get('enable_external_logging', False):
        self._write_to_external_log(log_entry)

def _write_to_external_log(self, log_entry: Dict):
    """لاگ انٹری کو بیرونی لاگنگ سسٹم میں لکھیں"""
    # عملدرآمد آپ کے لاگنگ انفراسٹرکچر پر منحصر ہوگا
    # جیسے ELK اسٹیک، CloudWatch، وغیرہ کو بھیجنا
    pass

# بزنس فنکشنز کی عملدرآمد
async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
    """CRM سسٹم سے کسٹمر کی معلومات حاصل کریں"""
    # ڈیٹا بیس/API کال کی نقل کریں
    await asyncio.sleep(0.1)  # نیٹ ورک کی تاخیر کی نقل
    
    customer_data = {
        'customer_id': customer_id,
        'name': 'John Doe',
        'email': 'john.doe@example.com',
        'phone': '+1-555-0123',
        'status': 'active',
        'tier': 'premium'
    }
    
    if include_history:
        customer_data['purchase_history'] = [
            {'date': '2024-01-15', 'product': 'Product A', 'amount': 1500},
            {'date': '2024-03-22', 'product': 'Product B', 'amount': 2300}
        ]
    
    return customer_data

async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                  estimated_value: float, expected_close_date: str) -> Dict:
    """نئی سیلز اپرچونٹی بنائیں"""
    # CRM API کال کی نقل کریں
    await asyncio.sleep(0.2)
    
    opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'opportunity_id': opportunity_id,
        'customer_id': customer_id,
        'product_id': product_id,
        'estimated_value': estimated_value,
        'expected_close_date': expected_close_date,
        'status': 'open',
        'created_date': datetime.now().isoformat()
    }

async def _generate_sales_report(self, period: str, region: str = None, 
                               product_category: str = None) -> Dict:
    """جامع سیلز رپورٹ تیار کریں"""
    # ڈیٹا ایگریگیشن کی نقل کریں
    await asyncio.sleep(0.5)
    
    return {
        'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
        'period': period,
        'region': region,
        'product_category': product_category,
        'total_sales': 125000.00,
        'total_opportunities': 45,
        'conversion_rate': 0.67,
        'top_products': [
            {'product_id': 'PROD-001', 'sales': 45000},
            {'product_id': 'PROD-002', 'sales': 32000}
        ],
        'generated_at': datetime.now().isoformat()
    }

async def _send_notification(self, recipients: List[str], message: str, 
                           priority: str = 'medium', channel: str = 'email') -> Dict:
    """مخصوص چینل کے ذریعے نوٹیفکیشن بھیجیں"""
    # نوٹیفکیشن سروس کال کی نقل کریں
    await asyncio.sleep(0.1)
    
    notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'notification_id': notification_id,
        'recipients': recipients,
        'channel': channel,
        'priority': priority,
        'status': 'sent',
        'sent_at': datetime.now().isoformat()
    }

def get_function_definitions(self) -> List[Dict]:
    """تمام رجسٹرڈ فنکشنز کے لیے OpenAI-مطابق فنکشن تعریفیں حاصل کریں"""
    definitions = []
    
    for func_name, func_info in self.functions.items():
        definition = {
            'name': func_name,
            'description': func_info['description'],
            'parameters': {
                'type': 'object',
                'properties': {},
                'required': []
            }
        }
        
        for param_name, param_info in func_info['parameters'].items():
            definition['parameters']['properties'][param_name] = {
                'type': param_info['type'],
                'description': param_info.get('description', '')
            }
            
            if 'enum' in param_info:
                definition['parameters']['properties'][param_name]['enum'] = param_info['enum']
            
            if 'default' in param_info:
                definition['parameters']['properties'][param_name]['default'] = param_info['default']
            
            if param_info.get('required', False):
                definition['parameters']['required'].append(param_name)
        
        definitions.append(definition)
    
    return definitions

# انٹرپرائز انٹیگریشن کے لیے استعمال کی مثال
async def enterprise_demo():
    """انٹرپرائز AI ایجنٹ کی صلاحیتوں کا مظاہرہ کریں"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # مثال 1: کسٹمر انکوائری پروسیسنگ
    print("=== کسٹمر انکوائری پروسیسنگ ===")
    
    # کسٹمر کی معلومات حاصل کریں
    result = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    if result.success:
        print(f"کسٹمر کی معلومات حاصل کی گئی: {result.data['name']}")
        print(f"عملدرآمد کا وقت: {result.execution_time:.3f}s")
    
    # مثال 2: سیلز اپرچونٹی بنانا
    print("\n=== سیلز اپرچونٹی بنانا ===")
    
    result = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    if result.success:
        print(f"اپرچونٹی بنائی گئی: {result.data['opportunity_id']}")
    
    # مثال 3: بیچ آپریشنز
    print("\n=== بیچ آپریشنز ===")
    
    tasks = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': 'نئی اپرچونٹی بنائی گئی',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    results = await asyncio.gather(*tasks)
    
    for i, result in enumerate(results):
        if result.success:
            print(f"ٹاسک {i+1} کامیابی سے مکمل ہوا")
        else:
            print(f"ٹاسک {i+1} ناکام ہوا: {result.error}")
    
    # آڈٹ لاگ دکھائیں
    print(f"\n=== آڈٹ لاگ ({len(agent.audit_log)} انٹریز) ===")
    for entry in agent.audit_log[-3:]:  # آخری 3 انٹریز دکھائیں
        print(f"{entry['timestamp']}: {entry['function_name']} - {'کامیاب' if entry['success'] else 'ناکام'}")

# انٹرپرائز ڈیمو چلائیں
# asyncio.run(enterprise_demo())
- **Phi-4 ماڈلز**: [Hugging Face Collection](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)  
- **Qwen3 دستاویزات**: [Official Qwen Documentation](https://qwen.readthedocs.io/)  
- **Ollama**: [Official Website](https://ollama.com/)  
- **Foundry Local**: [GitHub Repository](https://github.com/microsoft/Foundry-Local)  
- **فنکشن کالنگ کے بہترین طریقے**: [Hugging Face Guide](https://huggingface.co/docs/hugs/en/guides/function-calling)  

یاد رکھیں کہ فنکشن کالنگ ایک ترقی پذیر میدان ہے، اور اپنے منتخب کردہ فریم ورک اور ماڈلز میں تازہ ترین پیش رفت سے باخبر رہنا آپ کو زیادہ مؤثر AI ایجنٹس بنانے میں مدد دے گا۔  

## ➡️ آگے کیا ہے  

- [03: ماڈل کانٹیکسٹ پروٹوکول (MCP) انٹیگریشن](./03.IntroduceMCP.md)  

---

**ڈسکلیمر**:  
یہ دستاویز AI ترجمہ سروس [Co-op Translator](https://github.com/Azure/co-op-translator) کا استعمال کرتے ہوئے ترجمہ کی گئی ہے۔ ہم درستگی کے لیے کوشش کرتے ہیں، لیکن براہ کرم آگاہ رہیں کہ خودکار ترجمے میں غلطیاں یا غیر درستیاں ہو سکتی ہیں۔ اصل دستاویز کو اس کی اصل زبان میں مستند ذریعہ سمجھا جانا چاہیے۔ اہم معلومات کے لیے، پیشہ ور انسانی ترجمہ کی سفارش کی جاتی ہے۔ ہم اس ترجمے کے استعمال سے پیدا ہونے والی کسی بھی غلط فہمی یا غلط تشریح کے ذمہ دار نہیں ہیں۔