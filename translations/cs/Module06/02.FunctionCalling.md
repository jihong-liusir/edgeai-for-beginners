<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-09-18T16:29:17+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "cs"
}
-->
# Section02 : Volání funkcí v malých jazykových modelech (SLMs)

## Obsah
1. [Co je volání funkcí?](../../../Module06)
2. [Jak funguje volání funkcí](../../../Module06)
3. [Scénáře použití](../../../Module06)
4. [Nastavení volání funkcí s Phi-4-mini a Ollama](../../../Module06)
5. [Práce s voláním funkcí Qwen3](../../../Module06)
6. [Integrace Foundry Local](../../../Module06)
7. [Osvědčené postupy a řešení problémů](../../../Module06)
8. [Pokročilé příklady](../../../Module06)

## Co je volání funkcí?

Volání funkcí je výkonná schopnost, která umožňuje malým jazykovým modelům (SLMs) komunikovat s externími nástroji, API a službami. Namísto omezení na tréninková data mohou SLM nyní:

- **Připojit se k externím API** (služby počasí, databáze, vyhledávače)
- **Provádět specifické funkce** na základě požadavků uživatele
- **Získávat aktuální informace** z různých zdrojů
- **Provádět výpočetní úkoly** pomocí specializovaných nástrojů
- **Řetězit více operací** pro složité pracovní postupy

Tato schopnost mění SLM ze statických generátorů textu na dynamické AI agenty schopné vykonávat úkoly v reálném světě.

## Jak funguje volání funkcí

Proces volání funkcí následuje systematický pracovní postup:

### 1. Integrace nástrojů
- **Externí nástroje**: SLM se mohou připojit k API počasí, databázím, webovým službám a dalším externím systémům
- **Definice funkcí**: Každý nástroj je definován s konkrétními parametry, formáty vstupů/výstupů a popisy
- **Kompatibilita API**: Nástroje jsou integrovány prostřednictvím standardizovaných rozhraní (REST API, SDK atd.)

### 2. Definice funkcí
Funkce jsou definovány třemi klíčovými komponentami:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. Detekce záměru
- **Zpracování přirozeného jazyka**: SLM analyzuje vstup uživatele, aby pochopil záměr
- **Přiřazení funkcí**: Určuje, které funkce jsou potřebné k splnění požadavku
- **Extrahování parametrů**: Identifikuje a extrahuje požadované parametry ze zprávy uživatele

### 4. Generování JSON výstupu
SLM generuje strukturovaný JSON obsahující:
- Název funkce, kterou je třeba volat
- Požadované parametry s odpovídajícími hodnotami
- Kontext provedení a metadata

### 5. Externí provedení
- **Validace parametrů**: Zajišťuje, že všechny požadované parametry jsou přítomny a správně formátovány
- **Provedení funkce**: Aplikace provede specifikovanou funkci s poskytnutými parametry
- **Řešení chyb**: Řídí selhání, časové limity a neplatné odpovědi

### 6. Integrace odpovědi
- **Zpracování výsledků**: Výstup funkce je vrácen do SLM
- **Integrace kontextu**: SLM začleňuje výsledky do své odpovědi
- **Komunikace s uživatelem**: Prezentuje informace přirozeným, konverzačním způsobem

## Scénáře použití

### Získávání dat
Převádí dotazy v přirozeném jazyce na strukturované API volání:
- **"Ukaž moje poslední objednávky"** → Dotaz na databázi s ID uživatele a filtry podle data
- **"Jaké je počasí v Tokiu?"** → Volání API počasí s parametrem lokace
- **"Najdi e-maily od Johna z minulého týdne"** → Dotaz na e-mailovou službu s odesílatelem a filtry podle data

### Provádění operací
Transformuje požadavky uživatele na specifická volání funkcí:
- **"Naplánuj schůzku na zítra ve 14:00"** → Integrace kalendářního API
- **"Pošli zprávu týmu"** → API komunikační platformy
- **"Vytvoř zálohu mých souborů"** → Operace souborového systému

### Výpočetní úkoly
Řeší složité matematické nebo logické operace:
- **"Spočítej složený úrok z $10,000 při 5% na 10 let"** → Funkce finančního výpočtu
- **"Analyzuj tento dataset na trendy"** → Nástroje statistické analýzy
- **"Optimalizuj tuto trasu pro doručení"** → Algoritmy optimalizace tras

### Pracovní postupy zpracování dat
Řetězí více volání funkcí pro složité operace:
1. **Získání dat** z více zdrojů
2. **Parsování a validace** informací
3. **Transformace** dat do požadovaného formátu
4. **Uložení výsledků** do vhodných systémů
5. **Generování reportů** nebo vizualizací

### Integrace UI/UX
Umožňuje dynamické aktualizace rozhraní:
- **"Ukaž data o prodeji na dashboardu"** → Generování a zobrazení grafů
- **"Aktualizuj mapu s novými lokacemi"** → Integrace geodat
- **"Obnov zobrazení inventáře"** → Synchronizace dat v reálném čase

## Nastavení volání funkcí s Phi-4-mini a Ollama

Phi-4-mini od Microsoftu podporuje jak jednotlivé, tak paralelní volání funkcí prostřednictvím Ollama. Zde je postup nastavení:

### Předpoklady
- Ollama verze 0.5.13 nebo vyšší
- Model Phi-4-mini (doporučeno: `phi4-mini:3.8b-fp16`)

### Kroky instalace

#### 1. Instalace a spuštění Phi-4-mini
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. Vytvoření šablony ModelFile
Kvůli aktuálním omezením v defaultních šablonách Ollama je třeba vytvořit vlastní ModelFile s následující šablonou:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. Vytvoření vlastního modelu
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### Příklad volání jedné funkce

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### Příklad paralelního volání funkcí

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## Práce s voláním funkcí Qwen3

Qwen3 nabízí pokročilé schopnosti volání funkcí s vynikajícím výkonem a flexibilitou. Zde je postup implementace:

### Použití frameworku Qwen-Agent

Qwen-Agent poskytuje vysoce úrovňový framework, který zjednodušuje implementaci volání funkcí:

#### Instalace
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### Základní nastavení

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### Vlastní implementace funkcí

Můžete také definovat vlastní funkce pro Qwen3:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### Pokročilé funkce Qwen3

#### Řízení režimu myšlení
Qwen3 podporuje dynamické přepínání mezi režimem myšlení a nemyšlení:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### Vícekrokové volání funkcí
Qwen3 vyniká v řetězení více volání funkcí:

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## Integrace Foundry Local

Foundry Local od Microsoftu poskytuje API kompatibilní s OpenAI pro lokální provoz modelů s vylepšeným soukromím a výkonem.

### Nastavení a instalace

#### Windows
Stáhněte instalační program ze stránky [Foundry Local releases](https://github.com/microsoft/Foundry-Local/releases) a postupujte podle pokynů k instalaci.

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### Základní použití

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### Pokročilé funkce Foundry Local

#### Správa modelů
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### Optimalizace výkonu
Foundry Local automaticky vybírá nejlepší variantu modelu pro váš hardware:
- **CUDA GPU**: Stahuje modely optimalizované pro GPU
- **Qualcomm NPU**: Používá varianty akcelerované pomocí NPU
- **Pouze CPU**: Vybírá modely optimalizované pro CPU

## Osvědčené postupy a řešení problémů

### Osvědčené postupy pro definici funkcí

#### 1. Jasné a popisné názvy
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. Komplexní definice parametrů
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. Validace vstupů a řešení chyb
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### Běžné problémy a jejich řešení

#### Problém 1: Funkce není volána
**Příznaky**: Model odpovídá textem místo volání funkce

**Řešení**:
1. **Zkontrolujte popis funkce**: Ujistěte se, že jasně odpovídá záměru uživatele
2. **Ověřte definice parametrů**: Ujistěte se, že všechny požadované parametry jsou správně definovány
3. **Zkontrolujte systémový prompt**: Zahrňte jasné instrukce, kdy použít funkce
4. **Testujte s explicitními požadavky**: Zkuste "Prosím použij funkci počasí pro získání dat o Londýně"

#### Problém 2: Nesprávné parametry
**Příznaky**: Funkce je volána s nesprávnými nebo chybějícími parametry

**Řešení**:
1. **Přidejte příklady parametrů**: Zahrňte ukázkové hodnoty do popisů parametrů
2. **Použijte omezení enum**: Omezte hodnoty parametrů na konkrétní možnosti, pokud je to možné
3. **Implementujte výchozí hodnoty**: Poskytněte rozumné výchozí hodnoty pro volitelné parametry

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### Problém 3: Selhání paralelního volání funkcí
**Příznaky**: Pouze jedna funkce se provede, když by mělo běžet více

**Řešení**:
1. **Zkontrolujte podporu modelu**: Ujistěte se, že váš model podporuje paralelní volání funkcí
2. **Aktualizujte systémový prompt**: Zahrňte "některé nástroje" nebo "více nástrojů" do systémové zprávy
3. **Použijte vhodné verze modelu**: Doporučeno Phi-4-mini:3.8b-fp16 pro Ollama

#### Problém 4: Problémy se šablonami v Ollama
**Příznaky**: Volání funkcí nefunguje s výchozím nastavením Ollama

**Řešení**:
1. **Použijte vlastní ModelFile**: Použijte opravenou šablonu uvedenou v tomto tutoriálu
2. **Aktualizujte Ollama**: Ujistěte se, že používáte verzi 0.5.13 nebo vyšší
3. **Zkontrolujte kvantizaci modelu**: Vyšší úrovně kvantizace (Q8_0, fp16) fungují lépe než silně kvantizované verze

### Optimalizace výkonu

#### 1. Efektivní návrh funkcí
- **Zaměřte funkce**: Každá funkce by měla mít jeden jasný účel
- **Minimalizujte externí závislosti**: Snižte volání API a síťové požadavky, kde je to možné
- **Cache výsledků**: Ukládejte často požadovaná data pro zlepšení doby odezvy

#### 2. Dávkové a asynchronní operace
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. Správa zdrojů
- **Pooling připojení**: Znovu používejte připojení k databázím a API
- **Omezení rychlosti**: Implementujte správné omezení rychlosti pro externí API
- **Řešení časových limitů**: Nastavte rozumné časové limity pro všechna externí volání

## Pokročilé příklady

### Systém spolupráce více agentů

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### Systém dynamického výběru nástrojů

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```python
import asyncio
import json
from typing import Dict, List, Any
from dataclasses import dataclass
from datetime import datetime

@dataclass
class FunctionResult:
    """Standardní formát výsledků pro všechna volání funkcí"""
    success: bool
    data: Any = None
    error: str = None
    execution_time: float = 0.0
    timestamp: datetime = None

class EnterpriseAIAgent:
    """Produkčně připravený AI agent s komplexními schopnostmi volání funkcí"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.functions = {}
        self.audit_log = []
        self.rate_limiters = {}
        
        # Inicializace základních obchodních funkcí
        self._register_core_functions()
    
    def _register_core_functions(self):
        """Registrace všech dostupných obchodních funkcí"""
        
        # Funkce CRM
        self.register_function(
            name="get_customer_info",
            description="Získání informací o zákazníkovi z CRM",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "include_history": {"type": "boolean", "default": False}
            },
            handler=self._get_customer_info,
            rate_limit=100  # volání za minutu
        )
        
        # Funkce prodeje
        self.register_function(
            name="create_sales_opportunity",
            description="Vytvoření nové obchodní příležitosti",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "product_id": {"type": "string", "required": True},
                "estimated_value": {"type": "number", "required": True},
                "expected_close_date": {"type": "string", "required": True}
            },
            handler=self._create_sales_opportunity,
            rate_limit=50
        )
        
        # Funkce analýzy
        self.register_function(
            name="generate_sales_report",
            description="Generování reportu o výkonu prodeje",
            parameters={
                "period": {"type": "string", "enum": ["daily", "weekly", "monthly", "quarterly"]},
                "region": {"type": "string", "required": False},
                "product_category": {"type": "string", "required": False}
            },
            handler=self._generate_sales_report,
            rate_limit=10
        )
        
        # Funkce notifikací
        self.register_function(
            name="send_notification",
            description="Odeslání notifikace členům týmu",
            parameters={
                "recipients": {"type": "array", "items": {"type": "string"}},
                "message": {"type": "string", "required": True},
                "priority": {"type": "string", "enum": ["low", "medium", "high"], "default": "medium"},
                "channel": {"type": "string", "enum": ["email", "slack", "teams"], "default": "email"}
            },
            handler=self._send_notification,
            rate_limit=200
        )
    
    def register_function(self, name: str, description: str, parameters: Dict, 
                         handler: callable, rate_limit: int = 60):
        """Registrace nové funkce u agenta"""
        self.functions[name] = {
            'description': description,
            'parameters': parameters,
            'handler': handler,
            'rate_limit': rate_limit,
            'call_count': 0,
            'last_reset': datetime.now()
        }
    
    async def execute_function(self, function_name: str, parameters: Dict) -
# Úvod

Tento dokument poskytuje přehled o tom, jak používat @@INLINE_CODE_1@@ v rámci projektu. Je určen pro vývojáře, kteří chtějí integrovat @@INLINE_CODE_2@@ do svých aplikací.

## Požadavky

Než začnete, ujistěte se, že máte následující:

- Nainstalovaný @@INLINE_CODE_3@@
- Přístup k @@INLINE_CODE_4@@
- Základní znalosti o @@INLINE_CODE_5@@

## Instalace

Chcete-li nainstalovat @@INLINE_CODE_6@@, postupujte podle těchto kroků:

1. Otevřete terminál.
2. Spusťte následující příkaz:

   ```bash
   ```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```
   ```

3. Ověřte instalaci pomocí:

   ```bash
   ```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```
   ```

## Použití

### Základní příklad

Níže je uveden jednoduchý příklad, jak použít @@INLINE_CODE_7@@:

```python
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```
```

### Konfigurace

Pro přizpůsobení @@INLINE_CODE_8@@ můžete upravit následující parametry:

- @@INLINE_CODE_9@@: Popis parametru.
- @@INLINE_CODE_10@@: Popis parametru.

## Časté problémy

### Problém: @@INLINE_CODE_11@@ nefunguje

**Možné příčiny:**

1. @@INLINE_CODE_12@@ není správně nakonfigurován.
2. Chybí potřebné oprávnění.

**Řešení:**

- Zkontrolujte konfiguraci v @@INLINE_CODE_13@@.
- Ujistěte se, že máte správná oprávnění.

### Problém: Chyba při spuštění @@INLINE_CODE_14@@

**Možné příčiny:**

- Konflikt verzí.
- Neplatné vstupní hodnoty.

**Řešení:**

- Aktualizujte @@INLINE_CODE_15@@ na nejnovější verzi.
- Ověřte vstupní hodnoty.

## Závěr

Doufáme, že tento dokument vám pomůže úspěšně integrovat @@INLINE_CODE_16@@ do vašeho projektu. Pokud máte jakékoli dotazy, neváhejte nás kontaktovat.
"""Spusťte funkci s komplexním zpracováním chyb a logováním"""
start_time = datetime.now()

try:
    # Ověřte, zda funkce existuje
    if function_name not in self.functions:
        return FunctionResult(
            success=False,
            error=f"Funkce '{function_name}' nebyla nalezena",
            timestamp=start_time
        )
    
    # Zkontrolujte limity volání
    if not self._check_rate_limit(function_name):
        return FunctionResult(
            success=False,
            error=f"Překročen limit volání pro funkci '{function_name}'",
            timestamp=start_time
        )
    
    # Ověřte parametry
    validation_result = self._validate_parameters(function_name, parameters)
    if not validation_result.success:
        return validation_result
    
    # Spusťte funkci
    func_info = self.functions[function_name]
    handler = func_info['handler']
    
    if asyncio.iscoroutinefunction(handler):
        result_data = await handler(**parameters)
    else:
        result_data = handler(**parameters)
    
    execution_time = (datetime.now() - start_time).total_seconds()
    
    result = FunctionResult(
        success=True,
        data=result_data,
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Zalogujte úspěšné provedení
    self._log_function_call(function_name, parameters, result)
    
    return result
    
except Exception as e:
    execution_time = (datetime.now() - start_time).total_seconds()
    result = FunctionResult(
        success=False,
        error=str(e),
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Zalogujte neúspěšné provedení
    self._log_function_call(function_name, parameters, result)
    
    return result

def _check_rate_limit(self, function_name: str) -> bool:
    """Zkontrolujte, zda je volání funkce v rámci limitů"""
    func_info = self.functions[function_name]
    now = datetime.now()
    
    # Resetujte čítač, pokud uplynula minuta
    if (now - func_info['last_reset']).seconds >= 60:
        func_info['call_count'] = 0
        func_info['last_reset'] = now
    
    # Zkontrolujte, zda je pod limitem
    if func_info['call_count'] >= func_info['rate_limit']:
        return False
    
    func_info['call_count'] += 1
    return True

def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
    """Ověřte parametry funkce"""
    func_params = self.functions[function_name]['parameters']
    
    # Zkontrolujte povinné parametry
    for param_name, param_info in func_params.items():
        if param_info.get('required', False) and param_name not in parameters:
            return FunctionResult(
                success=False,
                error=f"Chybí povinný parametr: {param_name}"
            )
    
    # Ověřte typy parametrů a omezení
    for param_name, value in parameters.items():
        if param_name in func_params:
            param_info = func_params[param_name]
            
            # Ověření typu
            expected_type = param_info.get('type')
            if expected_type == 'string' and not isinstance(value, str):
                return FunctionResult(
                    success=False,
                    error=f"Parametr '{param_name}' musí být typu string"
                )
            elif expected_type == 'number' and not isinstance(value, (int, float)):
                return FunctionResult(
                    success=False,
                    error=f"Parametr '{param_name}' musí být typu number"
                )
            elif expected_type == 'boolean' and not isinstance(value, bool):
                return FunctionResult(
                    success=False,
                    error=f"Parametr '{param_name}' musí být typu boolean"
                )
            
            # Ověření hodnoty v seznamu
            if 'enum' in param_info and value not in param_info['enum']:
                return FunctionResult(
                    success=False,
                    error=f"Parametr '{param_name}' musí být jedním z: {param_info['enum']}"
                )
    
    return FunctionResult(success=True)

def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):
    """Zalogujte volání funkce pro účely auditu"""
    log_entry = {
        'timestamp': result.timestamp.isoformat(),
        'function_name': function_name,
        'parameters': parameters,
        'success': result.success,
        'execution_time': result.execution_time,
        'error': result.error if not result.success else None
    }
    
    self.audit_log.append(log_entry)
    
    # Volitelně zapisujte do externího logovacího systému
    if self.config.get('enable_external_logging', False):
        self._write_to_external_log(log_entry)

def _write_to_external_log(self, log_entry: Dict):
    """Zapište záznam do externího logovacího systému"""
    # Implementace závisí na vaší logovací infrastruktuře
    # např. odeslání do ELK stacku, CloudWatch, atd.
    pass

# Implementace obchodních funkcí
async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
    """Získejte informace o zákazníkovi z CRM systému"""
    # Simulace volání databáze/API
    await asyncio.sleep(0.1)  # Simulace síťového zpoždění
    
    customer_data = {
        'customer_id': customer_id,
        'name': 'John Doe',
        'email': 'john.doe@example.com',
        'phone': '+1-555-0123',
        'status': 'active',
        'tier': 'premium'
    }
    
    if include_history:
        customer_data['purchase_history'] = [
            {'date': '2024-01-15', 'product': 'Produkt A', 'amount': 1500},
            {'date': '2024-03-22', 'product': 'Produkt B', 'amount': 2300}
        ]
    
    return customer_data

async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                  estimated_value: float, expected_close_date: str) -> Dict:
    """Vytvořte novou obchodní příležitost"""
    # Simulace volání CRM API
    await asyncio.sleep(0.2)
    
    opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'opportunity_id': opportunity_id,
        'customer_id': customer_id,
        'product_id': product_id,
        'estimated_value': estimated_value,
        'expected_close_date': expected_close_date,
        'status': 'open',
        'created_date': datetime.now().isoformat()
    }

async def _generate_sales_report(self, period: str, region: str = None, 
                               product_category: str = None) -> Dict:
    """Vygenerujte komplexní prodejní zprávu"""
    # Simulace agregace dat
    await asyncio.sleep(0.5)
    
    return {
        'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
        'period': period,
        'region': region,
        'product_category': product_category,
        'total_sales': 125000.00,
        'total_opportunities': 45,
        'conversion_rate': 0.67,
        'top_products': [
            {'product_id': 'PROD-001', 'sales': 45000},
            {'product_id': 'PROD-002', 'sales': 32000}
        ],
        'generated_at': datetime.now().isoformat()
    }

async def _send_notification(self, recipients: List[str], message: str, 
                           priority: str = 'medium', channel: str = 'email') -> Dict:
    """Odešlete oznámení přes zvolený kanál"""
    # Simulace volání notifikační služby
    await asyncio.sleep(0.1)
    
    notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'notification_id': notification_id,
        'recipients': recipients,
        'channel': channel,
        'priority': priority,
        'status': 'sent',
        'sent_at': datetime.now().isoformat()
    }

def get_function_definitions(self) -> List[Dict]:
    """Získejte definice funkcí kompatibilní s OpenAI pro všechny registrované funkce"""
    definitions = []
    
    for func_name, func_info in self.functions.items():
        definition = {
            'name': func_name,
            'description': func_info['description'],
            'parameters': {
                'type': 'object',
                'properties': {},
                'required': []
            }
        }
        
        for param_name, param_info in func_info['parameters'].items():
            definition['parameters']['properties'][param_name] = {
                'type': param_info['type'],
                'description': param_info.get('description', '')
            }
            
            if 'enum' in param_info:
                definition['parameters']['properties'][param_name]['enum'] = param_info['enum']
            
            if 'default' in param_info:
                definition['parameters']['properties'][param_name]['default'] = param_info['default']
            
            if param_info.get('required', False):
                definition['parameters']['required'].append(param_name)
        
        definitions.append(definition)
    
    return definitions

# Ukázka použití pro podnikové integrace
async def enterprise_demo():
    """Ukázka schopností podnikových AI agentů"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # Příklad 1: Zpracování dotazů zákazníků
    print("=== Zpracování dotazů zákazníků ===")
    
    # Získejte informace o zákazníkovi
    result = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    if result.success:
        print(f"Informace o zákazníkovi získány: {result.data['name']}")
        print(f"Doba provedení: {result.execution_time:.3f}s")
    
    # Příklad 2: Vytvoření obchodní příležitosti
    print("\n=== Vytvoření obchodní příležitosti ===")
    
    result = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    if result.success:
        print(f"Obchodní příležitost vytvořena: {result.data['opportunity_id']}")
    
    # Příklad 3: Hromadné operace
    print("\n=== Hromadné operace ===")
    
    tasks = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': 'Nová příležitost vytvořena',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    results = await asyncio.gather(*tasks)
    
    for i, result in enumerate(results):
        if result.success:
            print(f"Úloha {i+1} úspěšně dokončena")
        else:
            print(f"Úloha {i+1} selhala: {result.error}")
    
    # Zobrazte auditní log
    print(f"\n=== Auditní log ({len(agent.audit_log)} záznamů) ===")
    for entry in agent.audit_log[-3:]:  # Zobrazte poslední 3 záznamy
        print(f"{entry['timestamp']}: {entry['function_name']} - {'ÚSPĚCH' if entry['success'] else 'SELHÁNÍ'}")

# Spusťte podnikové demo
# asyncio.run(enterprise_demo())

## Závěr

Volání funkcí v malých jazykových modelech představuje posun od statických AI asistentů k dynamickým, schopným agentům, kteří mohou interagovat s reálným světem. Tento tutoriál pokryl:

### Klíčové poznatky

1. **Základní porozumění**: Volání funkcí umožňuje SLM rozšířit se nad rámec jejich tréninkových dat prostřednictvím připojení k externím nástrojům a službám.

2. **Flexibilita implementace**: Existuje několik přístupů, od nízkoúrovňových implementací s vlastními šablonami až po vysoce úrovňové frameworky jako Qwen-Agent a Foundry Local.

3. **Produkční aspekty**: Podnikové nasazení vyžaduje pozornost k zpracování chyb, limitům volání, bezpečnosti a auditnímu logování.

4. **Optimalizace výkonu**: Správný návrh funkcí, efektivní provedení a chytré ukládání do mezipaměti mohou výrazně zlepšit dobu odezvy.

### Budoucí směry

Jak se technologie SLM nadále vyvíjí, můžeme očekávat:

- **Zlepšenou přesnost volání funkcí**: Lepší detekce záměrů a extrakce parametrů
- **Pokročilé paralelní zpracování**: Sofistikovanější orchestraci více funkcí
- **Lepší integrační standardy**: Standardizované protokoly pro integraci nástrojů
- **Pokročilé bezpečnostní funkce**: Vylepšené mechanismy autentizace a autorizace
- **Rozšířený ekosystém**: Rostoucí knihovna předem připravených funkcí a integrací

### Jak začít

Chcete-li začít implementovat volání funkcí ve svých projektech:

1. **Začněte jednoduše**: Začněte s jednoduchými scénáři jedné funkce
2. **Vyberte si framework**: Zvolte mezi přímou implementací (Ollama/Phi-4) nebo frameworkem (Qwen-Agent)
3. **Pečlivě navrhněte funkce**: Zaměřte se na jasné, dobře dokumentované definice funkcí
4. **Implementujte zpracování chyb**: Od začátku budujte robustní zpracování chyb
5. **Postupně škálujte**: Přecházejte od jednoduchých k složitým scénářům, jak získáváte zkušenosti

Volání funkcí transformuje SLM z působivých generátorů textu na praktické AI agenty schopné řešit reálné problémy. Dodržováním vzorů a postupů uvedených v tomto tutoriálu můžete vytvořit výkonné, spolehlivé AI systémy, které přesahují tradiční chatovací rozhraní.

### Zdroje a odkazy
- **Phi-4 Modely**: [Hugging Face Kolekce](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)
- **Qwen3 Dokumentace**: [Oficiální dokumentace Qwen](https://qwen.readthedocs.io/)
- **Ollama**: [Oficiální web](https://ollama.com/)
- **Foundry Local**: [GitHub Repozitář](https://github.com/microsoft/Foundry-Local)
- **Nejlepší postupy pro volání funkcí**: [Hugging Face Průvodce](https://huggingface.co/docs/hugs/en/guides/function-calling)

Pamatujte, že volání funkcí je dynamicky se rozvíjející oblast, a sledování nejnovějších vývojů ve vámi zvolených rámcích a modelech vám pomůže vytvářet efektivnější AI agenty.


## ➡️ Co dál

- [03: Integrace Model Context Protocol (MCP)](./03.IntroduceMCP.md)

---

**Prohlášení**:  
Tento dokument byl přeložen pomocí služby pro automatický překlad [Co-op Translator](https://github.com/Azure/co-op-translator). I když se snažíme o přesnost, mějte na paměti, že automatické překlady mohou obsahovat chyby nebo nepřesnosti. Původní dokument v jeho původním jazyce by měl být považován za autoritativní zdroj. Pro důležité informace se doporučuje profesionální lidský překlad. Neodpovídáme za žádné nedorozumění nebo nesprávné interpretace vyplývající z použití tohoto překladu.