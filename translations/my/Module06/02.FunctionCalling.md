<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-09-18T23:31:20+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "my"
}
-->
# အပိုင်း 02 : Function Calling in Small Language Models (SLMs)

## အကြောင်းအရာများ
1. [Function Calling ဆိုတာဘာလဲ?](../../../Module06)
2. [Function Calling အလုပ်လုပ်ပုံ](../../../Module06)
3. [အသုံးချနိုင်သောအခွင့်အရေးများ](../../../Module06)
4. [Phi-4-mini နှင့် Ollama ဖြင့် Function Calling ကို Set Up လုပ်ခြင်း](../../../Module06)
5. [Qwen3 Function Calling နှင့်အလုပ်လုပ်ခြင်း](../../../Module06)
6. [Foundry Local Integration](../../../Module06)
7. [အကောင်းဆုံးနည်းလမ်းများနှင့် ပြဿနာဖြေရှင်းခြင်း](../../../Module06)
8. [အဆင့်မြင့် နမူနာများ](../../../Module06)

## Function Calling ဆိုတာဘာလဲ?

Function calling ဆိုတာ Small Language Models (SLMs) တွေကို အပြင်ပန်း tools, APIs, နဲ့ services တွေကို ချိတ်ဆက်နိုင်စေတဲ့ အင်္ဂါရပ်တစ်ခုဖြစ်ပါတယ်။ ဒီအင်္ဂါရပ်ကြောင့် SLMs တွေဟာ သူတို့ရဲ့ training data အကန့်အသတ်ကို ကျော်လွှားပြီး:

- **အပြင်ပန်း APIs တွေကို ချိတ်ဆက်နိုင်ခြင်း** (ရာသီဥတုဝန်ဆောင်မှု, ဒေတာဘေ့စ်, ရှာဖွေမှုစနစ်များ)
- **အသုံးပြုသူရဲ့တောင်းဆိုမှုအပေါ် အခြေခံပြီး အထူး function တွေကို အကောင်အထည်ဖော်နိုင်ခြင်း**
- **အချိန်နှင့်တပြေးညီ အချက်အလက်တွေကို ရယူနိုင်ခြင်း**
- **အထူး tools တွေကို အသုံးပြုပြီး တွက်ချက်မှုလုပ်ဆောင်နိုင်ခြင်း**
- **အဆင့်ဆင့်လုပ်ဆောင်မှုများကို ချိတ်ဆက်ပြီး ရှုပ်ထွေးတဲ့ workflow များကို ဖော်ဆောင်နိုင်ခြင်း**

ဒီအင်္ဂါရပ်ကြောင့် SLMs တွေဟာ static text generator အနေဖြင့်သာမက dynamic AI agent အဖြစ် ပြောင်းလဲလာပါတယ်။

## Function Calling အလုပ်လုပ်ပုံ

Function calling လုပ်ငန်းစဉ်ဟာ အဆင့်ဆင့် workflow တစ်ခုကို လိုက်နာပါတယ်:

### 1. Tool Integration
- **အပြင်ပန်း Tools**: SLMs တွေဟာ ရာသီဥတု APIs, ဒေတာဘေ့စ်, ဝန်ဆောင်မှုများနဲ့ အခြားစနစ်များကို ချိတ်ဆက်နိုင်ပါတယ်။
- **Function Definitions**: Tool တစ်ခုစီကို parameter, input/output format, နဲ့ ဖော်ပြချက်များနဲ့အတူ သတ်မှတ်ထားပါတယ်။
- **API Compatibility**: Tools တွေကို REST APIs, SDKs စတဲ့ စံနည်းများကို အသုံးပြုပြီး ချိတ်ဆက်ထားပါတယ်။

### 2. Function Definition
Functions တွေကို အဓိက component သုံးခုနဲ့ သတ်မှတ်ထားပါတယ်:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. Intent Detection
- **Natural Language Processing**: SLM ဟာ အသုံးပြုသူရဲ့ input ကို ခွဲခြားပြီး ရည်ရွယ်ချက်ကို နားလည်ပါတယ်။
- **Function Matching**: တောင်းဆိုမှုကို ဖြေရှင်းဖို့ လိုအပ်တဲ့ function(s) ကို ရွေးချယ်ပါတယ်။
- **Parameter Extraction**: အသုံးပြုသူရဲ့ message ထဲက လိုအပ်တဲ့ parameter တွေကို ရှာဖွေပြီး ထုတ်ယူပါတယ်။

### 4. JSON Output Generation
SLM ဟာ structured JSON ကို ဖန်တီးပြီး:
- ခေါ်ရန်လိုအပ်တဲ့ function name
- လိုအပ်တဲ့ parameter တွေ နဲ့ တန်ဖိုးများ
- Execution context နဲ့ metadata

### 5. External Execution
- **Parameter Validation**: လိုအပ်တဲ့ parameter တွေ အားလုံးရှိမရှိ၊ format မှန်မမှန် စစ်ဆေးပါတယ်။
- **Function Execution**: Application ဟာ သတ်မှတ်ထားတဲ့ function ကို parameter တွေနဲ့အတူ အကောင်အထည်ဖော်ပါတယ်။
- **Error Handling**: Failures, timeouts, နဲ့ invalid responses တွေကို စီမံခန့်ခွဲပါတယ်။

### 6. Response Integration
- **Result Processing**: Function output ကို SLM သို့ ပြန်ပို့ပါတယ်။
- **Context Integration**: SLM ဟာ ရလဒ်တွေကို သူ့ရဲ့ response ထဲမှာ ထည့်သွင်းပါတယ်။
- **User Communication**: အသုံးပြုသူနဲ့ သဘာဝကျတဲ့ စကားပြောပုံစံနဲ့ အချက်အလက်တွေကို ဖော်ပြပါတယ်။

## အသုံးချနိုင်သောအခွင့်အရေးများ

### Data Retrieval
Natural language queries တွေကို structured API calls အဖြစ် ပြောင်းလဲပါ:
- **"Show my recent orders"** → User ID နဲ့ date filter တွေပါဝင်တဲ့ database query
- **"What's the weather in Tokyo?"** → Location parameter ပါဝင်တဲ့ ရာသီဥတု API call
- **"Find emails from John last week"** → Sender နဲ့ date filter တွေပါဝင်တဲ့ email service query

### Operation Execution
အသုံးပြုသူရဲ့ တောင်းဆိုမှုတွေကို အထူး function calls အဖြစ် ပြောင်းလဲပါ:
- **"Schedule a meeting for tomorrow at 2 PM"** → Calendar API integration
- **"Send a message to the team"** → Communication platform API
- **"Create a backup of my files"** → File system operation

### Computational Tasks
ရှုပ်ထွေးတဲ့ တွက်ချက်မှုတွေကို လုပ်ဆောင်ပါ:
- **"Calculate compound interest on $10,000 at 5% for 10 years"** → ငွေကြေး တွက်ချက်မှု function
- **"Analyze this dataset for trends"** → စာရင်းဇယား tools
- **"Optimize this route for delivery"** → လမ်းကြောင်း optimization algorithm

### Data Processing Workflows
ရှုပ်ထွေးတဲ့ လုပ်ငန်းစဉ်များအတွက် function calls တွေကို ချိတ်ဆက်ပါ:
1. **အချက်အလက်တွေကို ရယူပါ** အမျိုးမျိုးသောရင်းမြစ်များမှ
2. **အချက်အလက်တွေကို စစ်ဆေးပြီး အတည်ပြုပါ**
3. **လိုအပ်တဲ့ format အဖြစ် ပြောင်းလဲပါ**
4. **ရလဒ်တွေကို သင့်တော်တဲ့စနစ်များမှာ သိမ်းဆည်းပါ**
5. **Report များ သို့မဟုတ် visualization များ ဖန်တီးပါ**

### UI/UX Integration
Dynamic interface updates တွေကို အကောင်အထည်ဖော်ပါ:
- **"Show sales data on the dashboard"** → Chart ဖန်တီးပြီး ပြသခြင်း
- **"Update the map with new locations"** → Geospatial data integration
- **"Refresh the inventory display"** → Real-time data synchronization

## Phi-4-mini နှင့် Ollama ဖြင့် Function Calling ကို Set Up လုပ်ခြင်း

Microsoft ရဲ့ Phi-4-mini ဟာ single function calling နဲ့ parallel function calling နှစ်မျိုးလုံးကို Ollama မှတစ်ဆင့် ပံ့ပိုးပေးပါတယ်။ Set up လုပ်ပုံကို အောက်ပါအတိုင်း:

### လိုအပ်ချက်များ
- Ollama version 0.5.13 သို့မဟုတ် အထက်
- Phi-4-mini model (အကြံပြုချက်: `phi4-mini:3.8b-fp16`)

### Installation လုပ်နည်း

#### 1. Phi-4-mini ကို Install နဲ့ Run လုပ်ပါ
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. Custom ModelFile Template ဖန်တီးပါ
Ollama ရဲ့ default templates တွေမှာ limitations ရှိနေတဲ့အတွက် Custom ModelFile ကို အောက်ပါ template နဲ့ ဖန်တီးရပါမယ်:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. Custom Model ကို ဖန်တီးပါ
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### Single Function Calling နမူနာ

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### Parallel Function Calling နမူနာ

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## Qwen3 Function Calling နှင့်အလုပ်လုပ်ခြင်း

Qwen3 ဟာ အဆင့်မြင့် function calling အင်္ဂါရပ်တွေနဲ့ လုပ်ဆောင်မှုမြင့်မားမှုကို ပံ့ပိုးပေးပါတယ်။ အကောင်အထည်ဖော်ပုံမှာ:

### Qwen-Agent Framework ကို အသုံးပြုခြင်း

Qwen-Agent ဟာ function calling implementation ကို လွယ်ကူစေတဲ့ high-level framework တစ်ခုဖြစ်ပါတယ်:

#### Installation
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### Basic Setup

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### Custom Function Implementation

Qwen3 အတွက် custom functions တွေကို သတ်မှတ်နိုင်ပါတယ်:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### Qwen3 ရဲ့ အဆင့်မြင့် Features

#### Thinking Mode Control
Qwen3 ဟာ thinking mode နဲ့ non-thinking mode အကြား dynamic switching ကို ပံ့ပိုးပေးပါတယ်:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### Multi-step Function Calling
Qwen3 ဟာ function calls အများအပြားကို ချိတ်ဆက်ပြီး အကောင်းဆုံးလုပ်ဆောင်နိုင်ပါတယ်:

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## Foundry Local Integration

Microsoft ရဲ့ Foundry Local ဟာ OpenAI-compatible API ကို privacy နဲ့ performance မြင့်မားမှုနဲ့အတူ locally မှာ run လုပ်နိုင်စေပါတယ်။

### Setup နဲ့ Installation

#### Windows
[Foundry Local releases page](https://github.com/microsoft/Foundry-Local/releases) မှ installer ကို download လုပ်ပြီး installation လုပ်ပါ။

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### Basic Usage

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### Foundry Local ရဲ့ အဆင့်မြင့် Features

#### Model Management
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### Performance Optimization
Foundry Local ဟာ သင့် hardware အတွက် အကောင်းဆုံး model variant ကို အလိုအလျောက် ရွေးချယ်ပေးပါတယ်:
- **CUDA GPU**: GPU-optimized models ကို download လုပ်ပါ။
- **Qualcomm NPU**: NPU-accelerated variants ကို အသုံးပြုပါ။
- **CPU-only**: CPU-optimized models ကို ရွေးချယ်ပါ။

## အကောင်းဆုံးနည်းလမ်းများနှင့် ပြဿနာဖြေရှင်းခြင်း

### Function Definition အတွက် အကောင်းဆုံးနည်းလမ်းများ

#### 1. ရှင်းလင်းပြီး ဖော်ပြချက်ကောင်းသော နာမည်ပေးခြင်း
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. Parameter တွေကို ကျယ်ကျယ်ပြန့်ပြန့် သတ်မှတ်ခြင်း
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. Input Validation နဲ့ Error Handling
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### အများဆုံးတွေ့ရတဲ့ ပြဿနာများနဲ့ ဖြေရှင်းနည်းများ

#### ပြဿနာ 1: Function မခေါ်ခြင်း
**လက္ခဏာများ**: Model ဟာ function ကို မခေါ်ဘဲ text ဖြင့် တုံ့ပြန်ခြင်း

**ဖြေရှင်းနည်းများ**:
1. **Function ဖော်ပြချက်ကို စစ်ဆေးပါ**: အသုံးပြုသူရဲ့ ရည်ရွယ်ချက်နဲ့ တိတိကျကျ ကိုက်ညီအောင် ဖော်ပြထားပါ။
2. **Parameter သတ်မှတ်ချက်ကို စစ်ဆေးပါ**: လိုအပ်တဲ့ parameter တွေကို မှန်ကန်စွာ သတ်မှတ်ထားပါ။
3. **System prompt ကို ပြန်လည်သုံးသပ်ပါ**: Function ကို ဘယ်အချိန်မှာ အသုံးပြုရမယ်ဆိုတာ ရှင်းလင်းစွာ ဖော်ပြပါ။
4. **Explicit requests နဲ့ စမ်းသပ်ပါ**: "Please use the weather function to get data for London" စတဲ့ တိတိကျကျ တောင်းဆိုမှုတွေကို စမ်းသပ်ပါ။

#### ပြဿနာ 2: Parameter မမှန်ခြင်း
**လက္ခဏာများ**: Function ကို parameter မမှန်ဘဲ သို့မဟုတ် မရှိဘဲ ခေါ်ခြင်း

**ဖြေရှင်းနည်းများ**:
1. **Parameter နမူနာတွေ ထည့်သွင်းပါ**: Parameter ဖော်ပြချက်ထဲမှာ နမူနာတန်ဖိုးတွေ ထည့်သွင်းပါ။
2. **Enum constraints ကို အသုံးပြုပါ**: Parameter တန်ဖိုးတွေကို သတ်မှတ်ထားတဲ့ ရွေးချယ်စရာများအတွင်း ကန့်သတ်ပါ။
3. **Fallback values ကို အသုံးပြုပါ**: Optional parameters အတွက် သင့်တော်တဲ့ default တန်ဖိုးတွေ ပေးပါ။

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### ပြဿနာ 3: Parallel Function Calling Failures
**လက္ခဏာများ**: Function တစ်ခုသာ အလုပ်လုပ်ပြီး အများအပြား run မလုပ်ခြင်း

**ဖြေရှင်းနည်းများ**:
1. **Model support ကို စစ်ဆေးပါ**: သင့် model ဟာ parallel function calling ကို ပံ့ပိုးပေးနိုင်မလား စစ်ဆေးပါ။
2. **System prompt ကို ပြန်လည်ပြင်ဆင်ပါ**: "some tools" သို့မဟုတ် "multiple tools" စတဲ့ စနစ် message ထဲမှာ ထည့်သွင်းပါ။
3. **Model version ကို သင့်တော်စွာ အသုံးပြုပါ**: Ollama အတွက် Phi-4-mini:3.8b-fp16 ကို အကြံပြုပါတယ်။

#### ပြဿနာ 4: Ollama Template Issues
**လက္ခဏာများ**: Function calling ဟာ Ollama ရဲ့ default setup နဲ့ အလုပ်မလုပ်ခြင်း

**ဖြေရှင်းနည်းများ**:
1. **Custom ModelFile ကို အသုံးပြုပါ**: ဒီ tutorial မှာ ပေးထားတဲ့ corrected template ကို အသုံးပြုပါ။
2. **Ollama ကို update လုပ်ပါ**: Version 0.5.13 သို့မဟုတ် အထက်ကို အသုံးပြုပါ။
3. **Model quantization ကို စစ်ဆေးပါ**: Q8_0, fp16 စတဲ့ quantization အဆင့်မြင့်များဟာ အလုပ်ပိုကောင်းပါတယ်။

### Performance Optimization

#### 1. Function Design ကို ထိရောက်စွာ ပြုလုပ်ပါ
- **Function တွေကို ရှင်းလင်းစွာ သတ်မှတ်ပါ**: Function တစ်ခုစီဟာ ရည်ရွယ်ချက်တစ်ခုသာ ရှိရပါမယ်။
- **အပြင်ပန်း အခြေခံလိုအပ်ချက်တွေကို လျှော့ချပါ**: API calls နဲ့ network requests တွေကို လျှော့ချပါ။
- **Result တွေကို cache လုပ်ပါ**: အကြိမ်ကြိမ် တောင်းဆိုတဲ့ data တွေကို သိမ်းဆည်းထားပါ။

#### 2. Batching နဲ့ Async Operations
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. Resource Management
- **Connection pooling**: Database နဲ့ API connection တွေကို ပြန်လည်အသုံးပြုပါ။
- **Rate limiting**: အပြင်ပန်း APIs အတွက် rate limiting ကို သင့်တော်စွာ ပြုလုပ်ပါ။
- **Timeout handling**: အပြင်ပန်း calls အတွက် reasonable timeouts သတ်မှတ်ပါ။

## အဆင့်မြင့် နမူနာများ

### Multi-Agent Collaboration System

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### Dynamic Tool Selection System

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```python
import asyncio
import json
from typing import Dict, List, Any
from dataclasses import dataclass
from datetime import datetime

@dataclass
class FunctionResult:
    """Function calls အတွက် standard result format"""
    success: bool
    data: Any = None
    error: str = None
    execution_time: float = 0.0
    timestamp: datetime = None

class EnterpriseAIAgent:
    """Function calling အင်္ဂါရပ်များပါဝင်တဲ့ production-ready AI agent"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.functions = {}
        self.audit_log = []
        self.rate_limiters = {}
        
        # Core business functions တွေကို initialize လုပ်ပါ
        self._register_core_functions()
    
    def _register_core_functions(self):
        """ရရှိနိုင်တဲ့ business functions အားလုံးကို register လုပ်ပါ"""
        
        # CRM Functions
        self.register_function(
            name="get_customer_info",
            description="CRM မှ customer အချက်အလက်ကို ရယူပါ",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "include_history": {"type": "boolean", "default": False}
            },
            handler=self._get_customer_info,
            rate_limit=100  # calls per minute
        )
        
        # Sales Functions
        self.register_function(
            name="create_sales_opportunity",
            description="အသစ်သော sales opportunity တစ်ခု ဖန်တီးပါ",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "product_id": {"type": "string", "required": True},
                "estimated_value": {"type": "number", "required": True},
                "expected_close_date": {"type": "string", "required": True}
            },
            handler=self._create_sales_opportunity,
            rate_limit=50
        )
        
        # Analytics Functions
        self.register_function(
            name="generate_sales_report",
            description="Sales performance report ကို ဖန်တီးပါ",
            parameters={
                "period": {"type": "string", "enum": ["daily", "weekly", "monthly", "quarterly"]},
                "region": {"type": "string", "required": False},
                "product_category": {"type": "string", "required": False}
            },
            handler
ကျေးဇူးပြု၍ Markdown ဖိုင်ကို ပေးပါ၊ ပြန်လည်ဘာသာပြန်ပေးပါမည်။
"""လုပ်ဆောင်မှုတစ်ခုကို အမှားများကို ကောင်းစွာကိုင်တွယ်ပြီး မှတ်တမ်းတင်ခြင်းဖြင့် အကောင်အထည်ဖော်ပါ"""
start_time = datetime.now()

try:
    # လုပ်ဆောင်မှုရှိမရှိစစ်ဆေးပါ
    if function_name not in self.functions:
        return FunctionResult(
            success=False,
            error=f"Function '{function_name}' not found",
            timestamp=start_time
        )
    
    # အကြိမ်ရေကန့်သတ်ချက်များစစ်ဆေးပါ
    if not self._check_rate_limit(function_name):
        return FunctionResult(
            success=False,
            error=f"Rate limit exceeded for function '{function_name}'",
            timestamp=start_time
        )
    
    # parameter များစစ်ဆေးပါ
    validation_result = self._validate_parameters(function_name, parameters)
    if not validation_result.success:
        return validation_result
    
    # လုပ်ဆောင်မှုကို အကောင်အထည်ဖော်ပါ
    func_info = self.functions[function_name]
    handler = func_info['handler']
    
    if asyncio.iscoroutinefunction(handler):
        result_data = await handler(**parameters)
    else:
        result_data = handler(**parameters)
    
    execution_time = (datetime.now() - start_time).total_seconds()
    
    result = FunctionResult(
        success=True,
        data=result_data,
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # အောင်မြင်မှုကို မှတ်တမ်းတင်ပါ
    self._log_function_call(function_name, parameters, result)
    
    return result
    
except Exception as e:
    execution_time = (datetime.now() - start_time).total_seconds()
    result = FunctionResult(
        success=False,
        error=str(e),
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # မအောင်မြင်မှုကို မှတ်တမ်းတင်ပါ
    self._log_function_call(function_name, parameters, result)
    
    return result

def _check_rate_limit(self, function_name: str) -> bool:
    """လုပ်ဆောင်မှုအကြိမ်ရေကန့်သတ်ချက်ကို စစ်ဆေးပါ"""
    func_info = self.functions[function_name]
    now = datetime.now()
    
    # မိနစ်တစ်ခုကျော်လျှင် counter ကို ပြန်လည်စတင်ပါ
    if (now - func_info['last_reset']).seconds >= 60:
        func_info['call_count'] = 0
        func_info['last_reset'] = now
    
    # ကန့်သတ်ချက်အောက်တွင်ရှိမရှိစစ်ဆေးပါ
    if func_info['call_count'] >= func_info['rate_limit']:
        return False
    
    func_info['call_count'] += 1
    return True

def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
    """လုပ်ဆောင်မှု parameter များကို စစ်ဆေးပါ"""
    func_params = self.functions[function_name]['parameters']
    
    # လိုအပ်သော parameter များစစ်ဆေးပါ
    for param_name, param_info in func_params.items():
        if param_info.get('required', False) and param_name not in parameters:
            return FunctionResult(
                success=False,
                error=f"Missing required parameter: {param_name}"
            )
    
    # parameter အမျိုးအစားနှင့် ကန့်သတ်ချက်များစစ်ဆေးပါ
    for param_name, value in parameters.items():
        if param_name in func_params:
            param_info = func_params[param_name]
            
            # အမျိုးအစားစစ်ဆေးခြင်း
            expected_type = param_info.get('type')
            if expected_type == 'string' and not isinstance(value, str):
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' must be a string"
                )
            elif expected_type == 'number' and not isinstance(value, (int, float)):
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' must be a number"
                )
            elif expected_type == 'boolean' and not isinstance(value, bool):
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' must be a boolean"
                )
            
            # Enum စစ်ဆေးခြင်း
            if 'enum' in param_info and value not in param_info['enum']:
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' must be one of: {param_info['enum']}"
                )
    
    return FunctionResult(success=True)

def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):
    """လုပ်ဆောင်မှုကို audit ရည်ရွယ်ချက်များအတွက် မှတ်တမ်းတင်ပါ"""
    log_entry = {
        'timestamp': result.timestamp.isoformat(),
        'function_name': function_name,
        'parameters': parameters,
        'success': result.success,
        'execution_time': result.execution_time,
        'error': result.error if not result.success else None
    }
    
    self.audit_log.append(log_entry)
    
    # အပြင်မှတ်တမ်းစနစ်သို့ optionally ရေးသားပါ
    if self.config.get('enable_external_logging', False):
        self._write_to_external_log(log_entry)

def _write_to_external_log(self, log_entry: Dict):
    """အပြင်မှတ်တမ်းစနစ်သို့ log entry ကို ရေးသားပါ"""
    # သင့် logging infrastructure အပေါ်မူတည်ပြီး အကောင်အထည်ဖော်မှု
    # ဥပမာ - ELK stack, CloudWatch, စသည်တို့သို့ ပို့ပါ
    pass

# လုပ်ငန်းဆိုင်ရာ Function အကောင်အထည်ဖော်မှုများ
async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
    """CRM စနစ်မှ ဖောက်သည်အချက်အလက်ကို ရယူပါ"""
    # Database/API ခေါ်ဆိုမှုကို simulation လုပ်ပါ
    await asyncio.sleep(0.1)  # Network delay ကို simulation လုပ်ပါ
    
    customer_data = {
        'customer_id': customer_id,
        'name': 'John Doe',
        'email': 'john.doe@example.com',
        'phone': '+1-555-0123',
        'status': 'active',
        'tier': 'premium'
    }
    
    if include_history:
        customer_data['purchase_history'] = [
            {'date': '2024-01-15', 'product': 'Product A', 'amount': 1500},
            {'date': '2024-03-22', 'product': 'Product B', 'amount': 2300}
        ]
    
    return customer_data

async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                  estimated_value: float, expected_close_date: str) -> Dict:
    """ရောင်းအားအခွင့်အလမ်းအသစ်တစ်ခုကို ဖန်တီးပါ"""
    # CRM API ခေါ်ဆိုမှုကို simulation လုပ်ပါ
    await asyncio.sleep(0.2)
    
    opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'opportunity_id': opportunity_id,
        'customer_id': customer_id,
        'product_id': product_id,
        'estimated_value': estimated_value,
        'expected_close_date': expected_close_date,
        'status': 'open',
        'created_date': datetime.now().isoformat()
    }

async def _generate_sales_report(self, period: str, region: str = None, 
                               product_category: str = None) -> Dict:
    """ရောင်းအားအစီရင်ခံစာကို စုံလင်စွာ ဖန်တီးပါ"""
    # ဒေတာစုစည်းမှုကို simulation လုပ်ပါ
    await asyncio.sleep(0.5)
    
    return {
        'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
        'period': period,
        'region': region,
        'product_category': product_category,
        'total_sales': 125000.00,
        'total_opportunities': 45,
        'conversion_rate': 0.67,
        'top_products': [
            {'product_id': 'PROD-001', 'sales': 45000},
            {'product_id': 'PROD-002', 'sales': 32000}
        ],
        'generated_at': datetime.now().isoformat()
    }

async def _send_notification(self, recipients: List[str], message: str, 
                           priority: str = 'medium', channel: str = 'email') -> Dict:
    """သတ်မှတ်ထားသော channel မှတဆင့် အကြောင်းကြားချက်ပို့ပါ"""
    # Notification service ခေါ်ဆိုမှုကို simulation လုပ်ပါ
    await asyncio.sleep(0.1)
    
    notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'notification_id': notification_id,
        'recipients': recipients,
        'channel': channel,
        'priority': priority,
        'status': 'sent',
        'sent_at': datetime.now().isoformat()
    }

def get_function_definitions(self) -> List[Dict]:
    """မှတ်ပုံတင်ထားသော လုပ်ဆောင်မှုများအတွက် OpenAI-compatible function definitions ကို ရယူပါ"""
    definitions = []
    
    for func_name, func_info in self.functions.items():
        definition = {
            'name': func_name,
            'description': func_info['description'],
            'parameters': {
                'type': 'object',
                'properties': {},
                'required': []
            }
        }
        
        for param_name, param_info in func_info['parameters'].items():
            definition['parameters']['properties'][param_name] = {
                'type': param_info['type'],
                'description': param_info.get('description', '')
            }
            
            if 'enum' in param_info:
                definition['parameters']['properties'][param_name]['enum'] = param_info['enum']
            
            if 'default' in param_info:
                definition['parameters']['properties'][param_name]['default'] = param_info['default']
            
            if param_info.get('required', False):
                definition['parameters']['required'].append(param_name)
        
        definitions.append(definition)
    
    return definitions

# Enterprise Integration အတွက် အသုံးပြုမှု ဥပမာ
async def enterprise_demo():
    """Enterprise AI agent ၏ စွမ်းရည်များကို ပြသပါ"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # ဥပမာ ၁ - ဖောက်သည်မေးမြန်းမှုကို ကိုင်တွယ်ခြင်း
    print("=== ဖောက်သည်မေးမြန်းမှုကို ကိုင်တွယ်ခြင်း ===")
    
    # ဖောက်သည်အချက်အလက်ရယူပါ
    result = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    if result.success:
        print(f"ဖောက်သည်အချက်အလက်ရရှိသည်: {result.data['name']}")
        print(f"လုပ်ဆောင်မှုအချိန်: {result.execution_time:.3f}s")
    
    # ဥပမာ ၂ - ရောင်းအားအခွင့်အလမ်းဖန်တီးခြင်း
    print("\n=== ရောင်းအားအခွင့်အလမ်းဖန်တီးခြင်း ===")
    
    result = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    if result.success:
        print(f"အခွင့်အလမ်းဖန်တီးပြီး: {result.data['opportunity_id']}")
    
    # ဥပမာ ၃ - Batch လုပ်ဆောင်မှုများ
    print("\n=== Batch လုပ်ဆောင်မှုများ ===")
    
    tasks = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': 'အခွင့်အလမ်းအသစ်ဖန်တီးပြီး',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    results = await asyncio.gather(*tasks)
    
    for i, result in enumerate(results):
        if result.success:
            print(f"Task {i+1} အောင်မြင်စွာ ပြီးစီးသည်")
        else:
            print(f"Task {i+1} မအောင်မြင်ပါ: {result.error}")
    
    # Audit log ကို ပြသပါ
    print(f"\n=== Audit Log ({len(agent.audit_log)} entries) ===")
    for entry in agent.audit_log[-3:]:  # နောက်ဆုံး ၃ ခုကို ပြပါ
        print(f"{entry['timestamp']}: {entry['function_name']} - {'SUCCESS' if entry['success'] else 'FAILED'}")

# Enterprise demo ကို run လုပ်ပါ
# asyncio.run(enterprise_demo())

## နိဂုံး

Small Language Models တွင် Function calling သည် static AI assistant များမှ dynamic, စွမ်းရည်ရှိသော agent များသို့ ပြောင်းလဲမှုကို ကိုယ်စားပြုသည်။ ဤ tutorial တွင် အောက်ပါအချက်များကို ဖော်ပြခဲ့သည် -

### အဓိကအချက်များ

1. **အခြေခံအမြင်**: Function calling သည် SLM များကို အပြင် tools နှင့် services များနှင့် ချိတ်ဆက်ခြင်းဖြင့် training data အပေါ်မှ ကျော်လွှားစေသည်။
2. **အကောင်အထည်ဖော်မှုအလွယ်ကူမှု**: Custom templates အသုံးပြုသော အနိမ့်အဆင့်မှ Qwen-Agent နှင့် Foundry Local ကဲ့သို့သော အမြင့်အဆင့် frameworks အထိ အမျိုးမျိုးသောနည်းလမ်းများရှိသည်။
3. **ထုတ်လုပ်မှုအတွက် စဉ်းစားရန်အချက်များ**: Enterprise deployment များတွင် error handling, rate limiting, security, နှင့် audit logging အပေါ် အာရုံစိုက်ရန်လိုအပ်သည်။
4. **စွမ်းဆောင်ရည်တိုးတက်မှု**: လုပ်ဆောင်မှု design, အကျိုးရှိသော execution, နှင့် caching ကို အသုံးပြုခြင်းဖြင့် တုံ့ပြန်မှုအချိန်ကို တိုးတက်စေသည်။

### အနာဂတ်လမ်းကြောင်းများ

SLM နည်းပညာသည် ဆက်လက်တိုးတက်နေသည့်အခါ -

- **Function calling တိကျမှုတိုးတက်မှု**: intent detection နှင့် parameter extraction ပိုမိုကောင်းမွန်လာမည်။
- **Parallel processing တိုးတက်မှု**: လုပ်ဆောင်မှုများကို ပိုမိုစနစ်တကျ စီမံခန့်ခွဲနိုင်မည်။
- **Integration စံသတ်မှတ်များတိုးတက်မှု**: tool integration အတွက် စံသတ်မှတ်များ ပိုမိုတိုးတက်လာမည်။
- **လုံခြုံရေး features တိုးတက်မှု**: authentication နှင့် authorization mechanism များ ပိုမိုကောင်းမွန်လာမည်။
- **အကောင်အထည်ဖော်မှု ecosystem တိုးတက်မှု**: pre-built functions နှင့် integrations များ ပိုမိုတိုးတက်လာမည်။

### စတင်ရန်

သင့် project များတွင် function calling ကို စတင်အကောင်အထည်ဖော်ရန် -

1. **ရိုးရှင်းစွာ စတင်ပါ**: single-function scenarios များဖြင့် စတင်ပါ။
2. **Framework ကို ရွေးချယ်ပါ**: direct implementation (Ollama/Phi-4) သို့မဟုတ် framework-assisted (Qwen-Agent) အနက် ရွေးချယ်ပါ။
3. **လုပ်ဆောင်မှုများကို သေချာစွာ design လုပ်ပါ**: ရှင်းလင်းပြီး documentation ပြုလုပ်ထားသော function definitions အပေါ် အာရုံစိုက်ပါ။
4. **Error handling ကို အစမှစတင်ပါ**: error handling ကို အစမှ robust ဖြစ်အောင် တည်ဆောက်ပါ။
5. **Gradually Scale လုပ်ပါ**: ရိုးရှင်းသော scenarios များမှ စတင်ပြီး အတွေ့အကြုံရရှိသည့်အခါ complex scenarios များသို့ ရွှေ့လျားပါ။

Function calling သည် SLM များကို စိတ်ဝင်စားဖွယ် text generator များမှ အကောင်းဆုံး AI agent များသို့ ပြောင်းလဲစေသည်။ Tutorial တွင် ဖော်ပြထားသော patterns နှင့် practices များကို လိုက်နာခြင်းဖြင့် traditional chat interface များထက် ကျော်လွန်သော AI systems များကို တည်ဆောက်နိုင်ပါမည်။

### Resources နှင့် References
- **Phi-4 Models**: [Hugging Face Collection](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)
- **Qwen3 Documentation**: [Official Qwen Documentation](https://qwen.readthedocs.io/)
- **Ollama**: [Official Website](https://ollama.com/)
- **Foundry Local**: [GitHub Repository](https://github.com/microsoft/Foundry-Local)
- **Function Calling Best Practices**: [Hugging Face Guide](https://huggingface.co/docs/hugs/en/guides/function-calling)

လုပ်ဆောင်မှုခေါ်ယူခြင်းသည် အဆက်မပြတ်တိုးတက်နေသောနယ်ပယ်တစ်ခုဖြစ်ပြီး၊ သင်ရွေးချယ်ထားသော framework များနှင့် model များတွင် နောက်ဆုံးပေါ်ဖွံ့ဖြိုးတိုးတက်မှုများကို အမြဲလေ့လာထားခြင်းဖြင့် ပိုမိုထိရောက်သော AI agent များကို တည်ဆောက်နိုင်မည်ဖြစ်သည်။

## ➡️ နောက်တစ်ခုမှာဘာလုပ်မလဲ

- [03: Model Context Protocol (MCP) Integration](./03.IntroduceMCP.md)

---

**အကြောင်းကြားချက်**:  
ဤစာရွက်စာတမ်းကို AI ဘာသာပြန်ဝန်ဆောင်မှု [Co-op Translator](https://github.com/Azure/co-op-translator) ကို အသုံးပြု၍ ဘာသာပြန်ထားပါသည်။ ကျွန်ုပ်တို့သည် တိကျမှုအတွက် ကြိုးစားနေသော်လည်း၊ အလိုအလျောက် ဘာသာပြန်ခြင်းတွင် အမှားများ သို့မဟုတ် မတိကျမှုများ ပါရှိနိုင်သည်ကို သတိပြုပါ။ မူရင်းဘာသာစကားဖြင့် ရေးသားထားသော စာရွက်စာတမ်းကို အာဏာရှိသော ရင်းမြစ်အဖြစ် သတ်မှတ်သင့်ပါသည်။ အရေးကြီးသော အချက်အလက်များအတွက် လူ့ဘာသာပြန်ပညာရှင်များမှ ပရော်ဖက်ရှင်နယ် ဘာသာပြန်ခြင်းကို အကြံပြုပါသည်။ ဤဘာသာပြန်ကို အသုံးပြုခြင်းမှ ဖြစ်ပေါ်လာသော အလွဲအမှားများ သို့မဟုတ် အနားယူမှုများအတွက် ကျွန်ုပ်တို့သည် တာဝန်မယူပါ။