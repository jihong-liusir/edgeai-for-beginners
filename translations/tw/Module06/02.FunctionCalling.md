<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-07-22T04:30:42+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "tw"
}
-->
# Section02 : 小型語言模型 (SLMs) 的函數調用

## 目錄
1. [什麼是函數調用？](../../../Module06)
2. [函數調用的運作方式](../../../Module06)
3. [應用場景](../../../Module06)
4. [使用 Phi-4-mini 和 Ollama 設置函數調用](../../../Module06)
5. [使用 Qwen3 進行函數調用](../../../Module06)
6. [Foundry Local 集成](../../../Module06)
7. [最佳實踐與故障排除](../../../Module06)
8. [進階範例](../../../Module06)

## 什麼是函數調用？

函數調用是一種強大的功能，允許小型語言模型 (SLMs) 與外部工具、API 和服務進行互動。透過這項功能，SLMs 不再局限於其訓練數據，而是可以：

- **連接外部 API**（如天氣服務、資料庫、搜索引擎）
- **根據用戶請求執行特定函數**
- **從多種來源檢索即時資訊**
- **透過專業工具執行計算任務**
- **串聯多個操作** 以完成複雜的工作流程

這項功能將 SLMs 從靜態的文本生成器轉變為能執行現實任務的動態 AI 代理。

## 函數調用的運作方式

函數調用過程遵循一個系統化的工作流程：

### 1. 工具整合
- **外部工具**：SLMs 可以連接到天氣 API、資料庫、網絡服務和其他外部系統
- **函數定義**：每個工具都以特定的參數、輸入/輸出格式和描述進行定義
- **API 相容性**：工具透過標準化介面（如 REST API、SDK 等）進行整合

### 2. 函數定義
函數由三個關鍵組件定義：
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. 意圖檢測
- **自然語言處理**：SLM 分析用戶輸入以理解意圖
- **函數匹配**：確定需要調用哪些函數來滿足請求
- **參數提取**：識別並提取用戶消息中所需的參數

### 4. JSON 輸出生成
SLM 生成結構化的 JSON，包含：
- 要調用的函數名稱
- 所需參數及其適當的值
- 執行上下文和元數據

### 5. 外部執行
- **參數驗證**：確保所有必要參數都存在且格式正確
- **函數執行**：應用程序使用提供的參數執行指定函數
- **錯誤處理**：管理失敗、超時和無效響應

### 6. 響應整合
- **結果處理**：函數輸出返回給 SLM
- **上下文整合**：SLM 將結果整合到其響應中
- **用戶溝通**：以自然、對話的方式呈現資訊

## 應用場景

### 資料檢索
將自然語言查詢轉換為結構化的 API 調用：
- **「顯示我的最近訂單」** → 帶用戶 ID 和日期篩選條件的資料庫查詢
- **「東京的天氣怎麼樣？」** → 帶地點參數的天氣 API 調用
- **「查找上週 John 發來的郵件」** → 帶發件人和日期篩選條件的郵件服務查詢

### 操作執行
將用戶請求轉換為特定函數調用：
- **「安排明天下午 2 點的會議」** → 日曆 API 整合
- **「給團隊發送一條消息」** → 通訊平台 API
- **「備份我的文件」** → 文件系統操作

### 計算任務
處理複雜的數學或邏輯操作：
- **「計算 $10,000 在 5% 利率下 10 年的複利」** → 財務計算函數
- **「分析這個數據集的趨勢」** → 統計分析工具
- **「優化這條配送路線」** → 路線優化算法

### 資料處理工作流程
串聯多個函數調用以完成複雜操作：
1. **從多個來源檢索數據**
2. **解析並驗證** 信息
3. **轉換** 數據為所需格式
4. **將結果存儲** 到適當系統
5. **生成報告** 或可視化

### UI/UX 整合
實現動態界面更新：
- **「在儀表板上顯示銷售數據」** → 圖表生成與顯示
- **「在地圖上更新新位置」** → 地理空間數據整合
- **「刷新庫存顯示」** → 實時數據同步

## 使用 Phi-4-mini 和 Ollama 設置函數調用

Microsoft 的 Phi-4-mini 支援通過 Ollama 進行單一和並行函數調用。以下是設置步驟：

### 先決條件
- Ollama 版本 0.5.13 或更高
- Phi-4-mini 模型（推薦：`phi4-mini:3.8b-fp16`）

### 安裝步驟

#### 1. 安裝並運行 Phi-4-mini
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. 創建自定義 ModelFile 模板
由於 Ollama 的默認模板目前存在限制，您需要創建一個自定義 ModelFile，模板如下：

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. 創建自定義模型
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### 單一函數調用範例

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### 並行函數調用範例

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## 使用 Qwen3 進行函數調用

Qwen3 提供了高性能且靈活的進階函數調用功能。以下是實現方法：

### 使用 Qwen-Agent 框架

Qwen-Agent 提供了一個高層次框架，簡化了函數調用的實現：

#### 安裝
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### 基本設置

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### 自定義函數實現

您還可以為 Qwen3 定義自定義函數：

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### Qwen3 的進階功能

#### 思考模式控制
Qwen3 支援在思考模式和非思考模式之間動態切換：

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### 多步函數調用
Qwen3 擅長串聯多個函數調用：

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## Foundry Local 集成

Microsoft 的 Foundry Local 提供了一個與 OpenAI 相容的 API，用於在本地運行模型，並提升隱私和性能。

### 設置與安裝

#### Windows
從 [Foundry Local 發佈頁面](https://github.com/microsoft/Foundry-Local/releases) 下載安裝程序，並按照安裝說明進行操作。

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### 基本使用

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### Foundry Local 的進階功能

#### 模型管理
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### 性能優化
Foundry Local 會自動為您的硬件選擇最佳模型版本：
- **CUDA GPU**：下載 GPU 優化模型
- **Qualcomm NPU**：使用 NPU 加速版本
- **僅 CPU**：選擇 CPU 優化模型

## 最佳實踐與故障排除

### 函數定義最佳實踐

#### 1. 清晰且具描述性的命名
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. 全面的參數定義
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. 輸入驗證與錯誤處理
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### 常見問題與解決方案

#### 問題 1：函數未被調用
**症狀**：模型以文本形式回應，而非調用函數

**解決方案**：
1. **檢查函數描述**：確保其清楚地匹配用戶意圖
2. **驗證參數定義**：確保所有必要參數已正確定義
3. **檢查系統提示**：包含明確指示何時使用函數
4. **使用明確請求進行測試**：嘗試「請使用天氣函數獲取倫敦的數據」

#### 問題 2：參數錯誤
**症狀**：函數調用時參數錯誤或缺失

**解決方案**：
1. **添加參數範例**：在參數描述中包含示例值
2. **使用枚舉約束**：將參數值限制為特定選項
3. **實現回退值**：為可選參數提供合理的默認值

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### 問題 3：並行函數調用失敗
**症狀**：僅執行了一個函數，而非多個

**解決方案**：
1. **檢查模型支援**：確保您的模型支援並行函數調用
2. **更新系統提示**：在系統消息中包含「某些工具」或「多個工具」
3. **使用適當的模型版本**：推薦使用 Phi-4-mini:3.8b-fp16 與 Ollama

#### 問題 4：Ollama 模板問題
**症狀**：函數調用無法在默認 Ollama 設置下運行

**解決方案**：
1. **使用自定義 ModelFile**：應用本教程中提供的修正模板
2. **更新 Ollama**：確保使用版本 0.5.13 或更高
3. **檢查模型量化**：較高的量化級別（Q8_0、fp16）比重量化版本效果更好

### 性能優化

#### 1. 高效的函數設計
- **保持函數專注**：每個函數應有單一且明確的目的
- **最小化外部依賴**：減少 API 調用和網絡請求
- **緩存結果**：存儲常用數據以提高響應速度

#### 2. 批處理與異步操作
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. 資源管理
- **連接池化**：重用資料庫和 API 連接
- **速率限制**：對外部 API 實施適當的速率限制
- **超時處理**：為所有外部調用設置合理的超時

## 進階範例

### 多代理協作系統

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### 動態工具選擇系統

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```python
import asyncio
import json
from typing import Dict, List, Any
from dataclasses import dataclass
from datetime import datetime

@dataclass
class FunctionResult:
    """所有函數調用的標準結果格式"""
    success: bool
    data: Any = None
    error: str = None
    execution_time: float = 0.0
    timestamp: datetime = None

class EnterpriseAIAgent:
    """具備全面函數調用能力的生產級 AI 代理"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.functions = {}
        self.audit_log = []
        self.rate_limiters = {}
        
        # 初始化核心業務函數
        self._register_core_functions()
    
    def _register_core_functions(self):
        """註冊所有可用的業務函數"""
        
        # CRM 函數
        self.register_function(
            name="get_customer_info",
            description="從 CRM 檢索客戶信息",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "include_history": {"type": "boolean", "default": False}
            },
            handler=self._get_customer_info,
            rate_limit=100  # 每分鐘調用次數
        )
        
        # 銷售函數
        self.register_function(
            name="create_sales_opportunity",
            description="創建新的銷售機會",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "product_id": {"type": "string", "required": True},
                "estimated_value": {"type": "number", "required": True},
                "expected_close_date": {"type": "string", "required": True}
            },
            handler=self._create_sales_opportunity,
            rate_limit=50
        )
        
        # 分析函數
        self.register_function(
            name="generate_sales_report",
            description="生成銷售績效報告",
            parameters={
                "period": {"type": "string", "enum": ["daily", "weekly", "monthly", "quarterly"]},
                "region": {"type": "string", "required": False},
                "product_category": {"type": "string", "required": False}
            },
            handler=self._generate_sales_report,
            rate_limit=10
        )
        
        # 通知函數
        self.register_function(
            name="send_notification",
            description="向團隊成員發送通知",
            parameters={
                "recipients": {"type": "array", "items": {"type": "string"}},
                "message": {"type": "string", "required": True},
                "priority": {"type": "string", "enum": ["low", "medium", "high"], "default": "medium"},
                "channel": {"type": "string", "enum": ["email", "slack", "teams"], "default": "email"}
            },
            handler=self._send_notification,
            rate_limit=200
        )
    
    def register_function(self, name: str, description: str, parameters: Dict, 
                         handler: callable, rate_limit: int = 60):
        """註冊新函數到代理"""
        self.functions[name] = {
            'description': description,
            'parameters': parameters,
            'handler': handler,
            'rate_limit': rate_limit,
            'call_count': 0,
            'last_reset': datetime.now()
        }
    
    async def execute_function(self, function_name: str, parameters: Dict) -
請提供您需要翻譯的 Markdown 文件內容，我將根據您提供的規則進行翻譯。
"""執行具有全面錯誤處理和日誌記錄的函數"""
start_time = datetime.now()

try:
    # 驗證函數是否存在
    if function_name not in self.functions:
        return FunctionResult(
            success=False,
            error=f"未找到函數 '{function_name}'",
            timestamp=start_time
        )
    
    # 檢查速率限制
    if not self._check_rate_limit(function_name):
        return FunctionResult(
            success=False,
            error=f"函數 '{function_name}' 的速率限制已超過",
            timestamp=start_time
        )
    
    # 驗證參數
    validation_result = self._validate_parameters(function_name, parameters)
    if not validation_result.success:
        return validation_result
    
    # 執行函數
    func_info = self.functions[function_name]
    handler = func_info['handler']
    
    if asyncio.iscoroutinefunction(handler):
        result_data = await handler(**parameters)
    else:
        result_data = handler(**parameters)
    
    execution_time = (datetime.now() - start_time).total_seconds()
    
    result = FunctionResult(
        success=True,
        data=result_data,
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # 記錄成功執行
    self._log_function_call(function_name, parameters, result)
    
    return result
    
except Exception as e:
    execution_time = (datetime.now() - start_time).total_seconds()
    result = FunctionResult(
        success=False,
        error=str(e),
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # 記錄失敗執行
    self._log_function_call(function_name, parameters, result)
    
    return result

def _check_rate_limit(self, function_name: str) -> bool:
    """檢查函數調用是否在速率限制內"""
    func_info = self.functions[function_name]
    now = datetime.now()
    
    # 如果已過去一分鐘，重置計數器
    if (now - func_info['last_reset']).seconds >= 60:
        func_info['call_count'] = 0
        func_info['last_reset'] = now
    
    # 檢查是否在限制內
    if func_info['call_count'] >= func_info['rate_limit']:
        return False
    
    func_info['call_count'] += 1
    return True

def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
    """驗證函數參數"""
    func_params = self.functions[function_name]['parameters']
    
    # 檢查必需參數
    for param_name, param_info in func_params.items():
        if param_info.get('required', False) and param_name not in parameters:
            return FunctionResult(
                success=False,
                error=f"缺少必需參數: {param_name}"
            )
    
    # 驗證參數類型和約束
    for param_name, value in parameters.items():
        if param_name in func_params:
            param_info = func_params[param_name]
            
            # 類型驗證
            expected_type = param_info.get('type')
            if expected_type == 'string' and not isinstance(value, str):
                return FunctionResult(
                    success=False,
                    error=f"參數 '{param_name}' 必須是字串"
                )
            elif expected_type == 'number' and not isinstance(value, (int, float)):
                return FunctionResult(
                    success=False,
                    error=f"參數 '{param_name}' 必須是數字"
                )
            elif expected_type == 'boolean' and not isinstance(value, bool):
                return FunctionResult(
                    success=False,
                    error=f"參數 '{param_name}' 必須是布林值"
                )
            
            # 枚舉驗證
            if 'enum' in param_info and value not in param_info['enum']:
                return FunctionResult(
                    success=False,
                    error=f"參數 '{param_name}' 必須是以下之一: {param_info['enum']}"
                )
    
    return FunctionResult(success=True)

def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):
    """記錄函數調用以供審核"""
    log_entry = {
        'timestamp': result.timestamp.isoformat(),
        'function_name': function_name,
        'parameters': parameters,
        'success': result.success,
        'execution_time': result.execution_time,
        'error': result.error if not result.success else None
    }
    
    self.audit_log.append(log_entry)
    
    # 可選地寫入外部日誌系統
    if self.config.get('enable_external_logging', False):
        self._write_to_external_log(log_entry)

def _write_to_external_log(self, log_entry: Dict):
    """將日誌條目寫入外部日誌系統"""
    # 實現方式取決於您的日誌基礎設施
    # 例如，發送到 ELK 堆棧、CloudWatch 等
    pass

# 業務函數實現
async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
    """從 CRM 系統檢索客戶信息"""
    # 模擬資料庫/API 調用
    await asyncio.sleep(0.1)  # 模擬網絡延遲
    
    customer_data = {
        'customer_id': customer_id,
        'name': 'John Doe',
        'email': 'john.doe@example.com',
        'phone': '+1-555-0123',
        'status': 'active',
        'tier': 'premium'
    }
    
    if include_history:
        customer_data['purchase_history'] = [
            {'date': '2024-01-15', 'product': 'Product A', 'amount': 1500},
            {'date': '2024-03-22', 'product': 'Product B', 'amount': 2300}
        ]
    
    return customer_data

async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                  estimated_value: float, expected_close_date: str) -> Dict:
    """創建新的銷售機會"""
    # 模擬 CRM API 調用
    await asyncio.sleep(0.2)
    
    opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'opportunity_id': opportunity_id,
        'customer_id': customer_id,
        'product_id': product_id,
        'estimated_value': estimated_value,
        'expected_close_date': expected_close_date,
        'status': 'open',
        'created_date': datetime.now().isoformat()
    }

async def _generate_sales_report(self, period: str, region: str = None, 
                               product_category: str = None) -> Dict:
    """生成全面的銷售報告"""
    # 模擬數據聚合
    await asyncio.sleep(0.5)
    
    return {
        'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
        'period': period,
        'region': region,
        'product_category': product_category,
        'total_sales': 125000.00,
        'total_opportunities': 45,
        'conversion_rate': 0.67,
        'top_products': [
            {'product_id': 'PROD-001', 'sales': 45000},
            {'product_id': 'PROD-002', 'sales': 32000}
        ],
        'generated_at': datetime.now().isoformat()
    }

async def _send_notification(self, recipients: List[str], message: str, 
                           priority: str = 'medium', channel: str = 'email') -> Dict:
    """通過指定的渠道發送通知"""
    # 模擬通知服務調用
    await asyncio.sleep(0.1)
    
    notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'notification_id': notification_id,
        'recipients': recipients,
        'channel': channel,
        'priority': priority,
        'status': 'sent',
        'sent_at': datetime.now().isoformat()
    }

def get_function_definitions(self) -> List[Dict]:
    """獲取所有已註冊函數的 OpenAI 兼容函數定義"""
    definitions = []
    
    for func_name, func_info in self.functions.items():
        definition = {
            'name': func_name,
            'description': func_info['description'],
            'parameters': {
                'type': 'object',
                'properties': {},
                'required': []
            }
        }
        
        for param_name, param_info in func_info['parameters'].items():
            definition['parameters']['properties'][param_name] = {
                'type': param_info['type'],
                'description': param_info.get('description', '')
            }
            
            if 'enum' in param_info:
                definition['parameters']['properties'][param_name]['enum'] = param_info['enum']
            
            if 'default' in param_info:
                definition['parameters']['properties'][param_name]['default'] = param_info['default']
            
            if param_info.get('required', False):
                definition['parameters']['required'].append(param_name)
        
        definitions.append(definition)
    
    return definitions

# 企業集成使用範例
async def enterprise_demo():
    """展示企業 AI 代理的能力"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # 範例 1: 客戶查詢處理
    print("=== 客戶查詢處理 ===")
    
    # 獲取客戶信息
    result = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    if result.success:
        print(f"客戶信息已檢索: {result.data['name']}")
        print(f"執行時間: {result.execution_time:.3f}s")
    
    # 範例 2: 創建銷售機會
    print("\n=== 創建銷售機會 ===")
    
    result = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    if result.success:
        print(f"銷售機會已創建: {result.data['opportunity_id']}")
    
    # 範例 3: 批量操作
    print("\n=== 批量操作 ===")
    
    tasks = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': '新銷售機會已創建',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    results = await asyncio.gather(*tasks)
    
    for i, result in enumerate(results):
        if result.success:
            print(f"任務 {i+1} 成功完成")
        else:
            print(f"任務 {i+1} 失敗: {result.error}")
    
    # 顯示審核日誌
    print(f"\n=== 審核日誌 ({len(agent.audit_log)} 條目) ===")
    for entry in agent.audit_log[-3:]:  # 顯示最近 3 條
        print(f"{entry['timestamp']}: {entry['function_name']} - {'成功' if entry['success'] else '失敗'}")

# 執行企業演示
# asyncio.run(enterprise_demo())

## 結論

在小型語言模型中調用函數代表了一種從靜態 AI 助手到動態、能夠與現實世界互動的代理的範式轉變。本教程涵蓋了：

### 關鍵要點

1. **基礎理解**: 函數調用使 SLM 能夠通過連接外部工具和服務超越其訓練數據。
2. **實現靈活性**: 存在多種方法，從使用自定義模板的低級實現到高級框架（如 Qwen-Agent 和 Foundry Local）。
3. **生產考量**: 企業部署需要注意錯誤處理、速率限制、安全性和審核日誌。
4. **性能優化**: 合理的函數設計、高效執行和智能緩存可以顯著提高響應速度。

### 未來方向

隨著 SLM 技術的持續發展，我們可以期待：

- **改進函數調用準確性**: 更好的意圖檢測和參數提取
- **增強並行處理**: 更複雜的多函數協調
- **更好的集成標準**: 工具集成的標準化協議
- **高級安全功能**: 增強的身份驗證和授權機制
- **擴展生態系統**: 不斷增長的預構建函數和集成庫

### 入門指南

要開始在您的項目中實現函數調用：

1. **從簡單開始**: 從基本的單函數場景開始
2. **選擇框架**: 在直接實現（Ollama/Phi-4）或框架輔助（Qwen-Agent）之間選擇
3. **仔細設計函數**: 專注於清晰、文檔完善的函數定義
4. **實現錯誤處理**: 從一開始就構建健全的錯誤處理
5. **逐步擴展**: 隨著經驗的積累，從簡單場景過渡到複雜場景

函數調用將 SLM 從令人印象深刻的文本生成器轉變為能夠解決現實問題的實用 AI 代理。通過遵循本教程中概述的模式和實踐，您可以構建強大、可靠的 AI 系統，遠遠超越傳統的聊天界面。

### 資源和參考
- **Phi-4 模型**: [Hugging Face 集合](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)  
- **Qwen3 文件**: [官方 Qwen 文件](https://qwen.readthedocs.io/)  
- **Ollama**: [官方網站](https://ollama.com/)  
- **Foundry Local**: [GitHub 儲存庫](https://github.com/microsoft/Foundry-Local)  
- **函數調用最佳實踐**: [Hugging Face 指南](https://huggingface.co/docs/hugs/en/guides/function-calling)  

請記住，函數調用是一個不斷發展的領域，持續關注您選擇的框架和模型的最新進展，將有助於您構建更高效的 AI 代理。


## ➡️ 下一步

- [03: 模型上下文協議 (MCP) 整合](./03.IntroduceMCP.md)  

**免責聲明**：  
本文件使用 AI 翻譯服務 [Co-op Translator](https://github.com/Azure/co-op-translator) 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。