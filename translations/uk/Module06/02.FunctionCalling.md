<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-09-18T23:34:02+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "uk"
}
-->
# Розділ02: Виклик функцій у малих мовних моделях (SLMs)

## Зміст
1. [Що таке виклик функцій?](../../../Module06)
2. [Як працює виклик функцій](../../../Module06)
3. [Сценарії застосування](../../../Module06)
4. [Налаштування виклику функцій з Phi-4-mini та Ollama](../../../Module06)
5. [Робота з викликом функцій Qwen3](../../../Module06)
6. [Локальна інтеграція Foundry](../../../Module06)
7. [Найкращі практики та усунення несправностей](../../../Module06)
8. [Розширені приклади](../../../Module06)

## Що таке виклик функцій?

Виклик функцій — це потужна можливість, яка дозволяє малим мовним моделям (SLMs) взаємодіяти із зовнішніми інструментами, API та сервісами. Замість обмеження лише даними навчання, SLM тепер можуть:

- **Підключатися до зовнішніх API** (сервіси погоди, бази даних, пошукові системи)
- **Виконувати конкретні функції** на основі запитів користувача
- **Отримувати інформацію в реальному часі** з різних джерел
- **Виконувати обчислювальні завдання** за допомогою спеціалізованих інструментів
- **Об'єднувати кілька операцій** для складних робочих процесів

Ця можливість перетворює SLM із статичних генераторів тексту на динамічних AI-агентів, здатних виконувати реальні завдання.

## Як працює виклик функцій

Процес виклику функцій слідує систематичному робочому процесу:

### 1. Інтеграція інструментів
- **Зовнішні інструменти**: SLM можуть підключатися до API погоди, баз даних, веб-сервісів та інших зовнішніх систем
- **Визначення функцій**: Кожен інструмент визначається з конкретними параметрами, форматами вводу/виводу та описами
- **Сумісність API**: Інструменти інтегруються через стандартизовані інтерфейси (REST API, SDK тощо)

### 2. Визначення функцій
Функції визначаються трьома ключовими компонентами:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. Виявлення наміру
- **Обробка природної мови**: SLM аналізує введення користувача для розуміння наміру
- **Відповідність функцій**: Визначає, які функції потрібні для виконання запиту
- **Витяг параметрів**: Ідентифікує та витягує необхідні параметри з повідомлення користувача

### 4. Генерація JSON-виводу
SLM створює структурований JSON, що містить:
- Назву функції для виклику
- Необхідні параметри з відповідними значеннями
- Контекст виконання та метадані

### 5. Зовнішнє виконання
- **Перевірка параметрів**: Переконується, що всі необхідні параметри присутні та правильно відформатовані
- **Виконання функції**: Додаток виконує зазначену функцію з наданими параметрами
- **Обробка помилок**: Управляє збоями, тайм-аутами та недійсними відповідями

### 6. Інтеграція відповіді
- **Обробка результатів**: Вивід функції повертається до SLM
- **Інтеграція контексту**: SLM включає результати у свою відповідь
- **Спілкування з користувачем**: Представляє інформацію у природному, розмовному форматі

## Сценарії застосування

### Отримання даних
Перетворення запитів природною мовою у структуровані виклики API:
- **"Покажи мої останні замовлення"** → Запит до бази даних з ID користувача та фільтрами дати
- **"Яка погода в Токіо?"** → Виклик API погоди з параметром локації
- **"Знайди листи від Джона за минулий тиждень"** → Запит до сервісу електронної пошти з фільтрами відправника та дати

### Виконання операцій
Перетворення запитів користувача у конкретні виклики функцій:
- **"Заплануй зустріч на завтра о 14:00"** → Інтеграція з API календаря
- **"Надішли повідомлення команді"** → API платформи комунікації
- **"Створи резервну копію моїх файлів"** → Операція файлової системи

### Обчислювальні завдання
Обробка складних математичних або логічних операцій:
- **"Розрахуй складний відсоток на $10,000 при 5% за 10 років"** → Функція фінансових розрахунків
- **"Проаналізуй цей набір даних на тренди"** → Інструменти статистичного аналізу
- **"Оптимізуй цей маршрут для доставки"** → Алгоритми оптимізації маршруту

### Робочі процеси обробки даних
Об'єднання кількох викликів функцій для складних операцій:
1. **Отримання даних** з кількох джерел
2. **Парсинг та перевірка** інформації
3. **Перетворення** даних у потрібний формат
4. **Збереження результатів** у відповідних системах
5. **Генерація звітів** або візуалізацій

### Інтеграція UI/UX
Динамічне оновлення інтерфейсу:
- **"Покажи дані продажів на панелі"** → Генерація та відображення графіків
- **"Онови карту новими локаціями"** → Інтеграція геопросторових даних
- **"Онови відображення інвентаря"** → Синхронізація даних у реальному часі

## Налаштування виклику функцій з Phi-4-mini та Ollama

Phi-4-mini від Microsoft підтримує як одиночний, так і паралельний виклик функцій через Ollama. Ось як це налаштувати:

### Попередні умови
- Версія Ollama 0.5.13 або новіша
- Модель Phi-4-mini (рекомендовано: `phi4-mini:3.8b-fp16`)

### Кроки встановлення

#### 1. Встановіть та запустіть Phi-4-mini
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. Створіть шаблон ModelFile
Через поточні обмеження у стандартних шаблонах Ollama, необхідно створити власний ModelFile з наступним шаблоном:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. Створіть власну модель
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### Приклад одиночного виклику функції

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### Приклад паралельного виклику функцій

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## Робота з викликом функцій Qwen3

Qwen3 пропонує розширені можливості виклику функцій з чудовою продуктивністю та гнучкістю. Ось як це реалізувати:

### Використання фреймворку Qwen-Agent

Qwen-Agent забезпечує високорівневий фреймворк, який спрощує реалізацію виклику функцій:

#### Встановлення
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### Базове налаштування

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### Реалізація власних функцій

Ви також можете визначити власні функції для Qwen3:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### Розширені функції Qwen3

#### Контроль режиму мислення
Qwen3 підтримує динамічне перемикання між режимами мислення та немислення:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### Багатокроковий виклик функцій
Qwen3 чудово справляється з об'єднанням кількох викликів функцій:

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## Локальна інтеграція Foundry

Foundry Local від Microsoft забезпечує сумісний з OpenAI API для запуску моделей локально з покращеною конфіденційністю та продуктивністю.

### Налаштування та встановлення

#### Windows
Завантажте інсталятор зі сторінки [релізів Foundry Local](https://github.com/microsoft/Foundry-Local/releases) та дотримуйтесь інструкцій з встановлення.

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### Базове використання

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### Розширені функції Foundry Local

#### Управління моделями
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### Оптимізація продуктивності
Foundry Local автоматично вибирає найкращий варіант моделі для вашого обладнання:
- **CUDA GPU**: Завантажує моделі, оптимізовані для GPU
- **Qualcomm NPU**: Використовує варіанти з прискоренням NPU
- **Тільки CPU**: Вибирає моделі, оптимізовані для CPU

## Найкращі практики та усунення несправностей

### Найкращі практики визначення функцій

#### 1. Чітке та описове найменування
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. Всеосяжні визначення параметрів
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. Перевірка вводу та обробка помилок
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### Поширені проблеми та рішення

#### Проблема 1: Функція не викликається
**Симптоми**: Модель відповідає текстом замість виклику функції

**Рішення**:
1. **Перевірте опис функції**: Переконайтеся, що він чітко відповідає наміру користувача
2. **Перевірте визначення параметрів**: Переконайтеся, що всі необхідні параметри правильно визначені
3. **Перегляньте системний підказ**: Включіть чіткі інструкції щодо використання функцій
4. **Тестуйте з явними запитами**: Спробуйте "Будь ласка, використайте функцію погоди для отримання даних про Лондон"

#### Проблема 2: Неправильні параметри
**Симптоми**: Функція викликається з неправильними або відсутніми параметрами

**Рішення**:
1. **Додайте приклади параметрів**: Включіть зразкові значення в опис параметрів
2. **Використовуйте обмеження enum**: Обмежте значення параметрів конкретними опціями, якщо можливо
3. **Реалізуйте резервні значення**: Надайте розумні значення за замовчуванням для необов'язкових параметрів

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### Проблема 3: Збої паралельного виклику функцій
**Симптоми**: Виконується лише одна функція, коли повинні виконуватися кілька

**Рішення**:
1. **Перевірте підтримку моделі**: Переконайтеся, що ваша модель підтримує паралельний виклик функцій
2. **Оновіть системний підказ**: Включіть "деякі інструменти" або "кілька інструментів" у системне повідомлення
3. **Використовуйте відповідні версії моделі**: Рекомендовано Phi-4-mini:3.8b-fp16 для Ollama

#### Проблема 4: Проблеми з шаблоном Ollama
**Симптоми**: Виклик функцій не працює зі стандартним налаштуванням Ollama

**Рішення**:
1. **Використовуйте власний ModelFile**: Застосуйте виправлений шаблон, наданий у цьому посібнику
2. **Оновіть Ollama**: Переконайтеся, що ви використовуєте версію 0.5.13 або новішу
3. **Перевірте квантування моделі**: Вищі рівні квантування (Q8_0, fp16) працюють краще, ніж сильно квантувані версії

### Оптимізація продуктивності

#### 1. Ефективний дизайн функцій
- **Зосередьте функції**: Кожна функція повинна мати одну чітку мету
- **Мінімізуйте зовнішні залежності**: Зменшіть виклики API та мережеві запити, де це можливо
- **Кешуйте результати**: Зберігайте часто запитувані дані для покращення часу відповіді

#### 2. Пакетна обробка та асинхронні операції
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. Управління ресурсами
- **Пулінг з'єднань**: Повторно використовуйте з'єднання з базами даних та API
- **Обмеження швидкості**: Реалізуйте належне обмеження швидкості для зовнішніх API
- **Обробка тайм-аутів**: Встановіть розумні тайм-аути для всіх зовнішніх викликів

## Розширені приклади

### Система співпраці багатьох агентів

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### Система динамічного вибору інструментів

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```python
import asyncio
import json
from typing import Dict, List, Any
from dataclasses import dataclass
from datetime import datetime

@dataclass
class FunctionResult:
    """Стандартний формат результату для всіх викликів функцій"""
    success: bool
    data: Any = None
    error: str = None
    execution_time: float = 0.0
    timestamp: datetime = None

class EnterpriseAIAgent:
    """Готовий до використання AI-агент з розширеними можливостями виклику функцій"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.functions = {}
        self.audit_log = []
        self.rate_limiters = {}
        
        # Ініціалізація основних бізнес-функцій
        self._register_core_functions()
    
    def _register_core_functions(self):
        """Реєстрація всіх доступних бізнес-функцій"""
        
        # Функції CRM
        self.register_function(
            name="get_customer_info",
            description="Отримати інформацію про клієнта з CRM",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "include_history": {"type": "boolean", "default": False}
            },
            handler=self._get_customer_info,
            rate_limit=100  # викликів на хвилину
        )
        
        # Функції продажів
        self.register_function(
            name="create_sales_opportunity",
            description="Створити нову можливість продажу",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "product_id": {"type": "string", "required": True},
                "estimated_value": {"type": "number", "required": True},
                "expected_close_date": {"type": "string", "required": True}
            },
            handler=self._create_sales_opportunity,
            rate_limit=50
        )
        
        # Аналітичні функції
        self.register_function(
            name="generate_sales_report",
            description="Генерувати звіт про продуктивність продажів",
            parameters={
                "period": {"type": "string", "enum": ["daily", "weekly", "monthly", "quarterly"]},
                "region": {"type": "string", "required": False},
                "product_category": {"type": "string", "required": False}
            },
            handler=self._generate_sales_report,
            rate_limit=10
        )
        
        # Функції сповіщень
        self.register_function(
            name="send_notification",
            description="Надіслати сповіщення членам команди",
            parameters={
                "recipients": {"type": "array", "items": {"type": "string"}},
                "message": {"type": "string", "required": True},
                "priority": {"type": "string", "enum": ["low", "medium", "high"], "default": "medium"},
                "channel": {"type": "string", "enum": ["email", "slack", "teams"], "default": "email"}
            },
            handler=self._send_notification,
            rate_limit=200
        )
    
    def register_function(self, name: str, description: str, parameters: Dict, 
                         handler: callable, rate_limit: int = 60):
        """Реєстрація нової функції для агента"""
        self.functions[name] = {
            'description': description,
            'parameters': parameters,

Вибачте, але мені потрібен текст Markdown, який потрібно перекласти. Будь ласка, надайте його, і я з радістю допоможу!
"""Виконання функції з всебічною обробкою помилок та логуванням"""
start_time = datetime.now()

try:
    # Перевірка наявності функції
    if function_name not in self.functions:
        return FunctionResult(
            success=False,
            error=f"Функція '{function_name}' не знайдена",
            timestamp=start_time
        )
    
    # Перевірка обмежень частоти викликів
    if not self._check_rate_limit(function_name):
        return FunctionResult(
            success=False,
            error=f"Перевищено ліміт частоти викликів для функції '{function_name}'",
            timestamp=start_time
        )
    
    # Перевірка параметрів
    validation_result = self._validate_parameters(function_name, parameters)
    if not validation_result.success:
        return validation_result
    
    # Виконання функції
    func_info = self.functions[function_name]
    handler = func_info['handler']
    
    if asyncio.iscoroutinefunction(handler):
        result_data = await handler(**parameters)
    else:
        result_data = handler(**parameters)
    
    execution_time = (datetime.now() - start_time).total_seconds()
    
    result = FunctionResult(
        success=True,
        data=result_data,
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Логування успішного виконання
    self._log_function_call(function_name, parameters, result)
    
    return result
    
except Exception as e:
    execution_time = (datetime.now() - start_time).total_seconds()
    result = FunctionResult(
        success=False,
        error=str(e),
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Логування невдалого виконання
    self._log_function_call(function_name, parameters, result)
    
    return result

def _check_rate_limit(self, function_name: str) -> bool:
    """Перевірка, чи виклик функції відповідає обмеженням частоти"""
    func_info = self.functions[function_name]
    now = datetime.now()
    
    # Скидання лічильника, якщо минула хвилина
    if (now - func_info['last_reset']).seconds >= 60:
        func_info['call_count'] = 0
        func_info['last_reset'] = now
    
    # Перевірка, чи не перевищено ліміт
    if func_info['call_count'] >= func_info['rate_limit']:
        return False
    
    func_info['call_count'] += 1
    return True

def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
    """Перевірка параметрів функції"""
    func_params = self.functions[function_name]['parameters']
    
    # Перевірка обов'язкових параметрів
    for param_name, param_info in func_params.items():
        if param_info.get('required', False) and param_name not in parameters:
            return FunctionResult(
                success=False,
                error=f"Відсутній обов'язковий параметр: {param_name}"
            )
    
    # Перевірка типів параметрів та обмежень
    for param_name, value in parameters.items():
        if param_name in func_params:
            param_info = func_params[param_name]
            
            # Перевірка типу
            expected_type = param_info.get('type')
            if expected_type == 'string' and not isinstance(value, str):
                return FunctionResult(
                    success=False,
                    error=f"Параметр '{param_name}' має бути рядком"
                )
            elif expected_type == 'number' and not isinstance(value, (int, float)):
                return FunctionResult(
                    success=False,
                    error=f"Параметр '{param_name}' має бути числом"
                )
            elif expected_type == 'boolean' and not isinstance(value, bool):
                return FunctionResult(
                    success=False,
                    error=f"Параметр '{param_name}' має бути булевим значенням"
                )
            
            # Перевірка на відповідність значенням enum
            if 'enum' in param_info and value not in param_info['enum']:
                return FunctionResult(
                    success=False,
                    error=f"Параметр '{param_name}' має бути одним із: {param_info['enum']}"
                )
    
    return FunctionResult(success=True)

def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):
    """Логування виклику функції для аудиту"""
    log_entry = {
        'timestamp': result.timestamp.isoformat(),
        'function_name': function_name,
        'parameters': parameters,
        'success': result.success,
        'execution_time': result.execution_time,
        'error': result.error if not result.success else None
    }
    
    self.audit_log.append(log_entry)
    
    # Опціонально записати в зовнішню систему логування
    if self.config.get('enable_external_logging', False):
        self._write_to_external_log(log_entry)

def _write_to_external_log(self, log_entry: Dict):
    """Запис логів у зовнішню систему логування"""
    # Реалізація залежить від вашої інфраструктури логування
    # Наприклад, відправка в ELK stack, CloudWatch тощо
    pass

# Реалізація бізнес-функцій
async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
    """Отримання інформації про клієнта з CRM системи"""
    # Симуляція виклику бази даних/API
    await asyncio.sleep(0.1)  # Симуляція затримки мережі
    
    customer_data = {
        'customer_id': customer_id,
        'name': 'John Doe',
        'email': 'john.doe@example.com',
        'phone': '+1-555-0123',
        'status': 'active',
        'tier': 'premium'
    }
    
    if include_history:
        customer_data['purchase_history'] = [
            {'date': '2024-01-15', 'product': 'Product A', 'amount': 1500},
            {'date': '2024-03-22', 'product': 'Product B', 'amount': 2300}
        ]
    
    return customer_data

async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                  estimated_value: float, expected_close_date: str) -> Dict:
    """Створення нової можливості продажу"""
    # Симуляція виклику API CRM
    await asyncio.sleep(0.2)
    
    opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'opportunity_id': opportunity_id,
        'customer_id': customer_id,
        'product_id': product_id,
        'estimated_value': estimated_value,
        'expected_close_date': expected_close_date,
        'status': 'open',
        'created_date': datetime.now().isoformat()
    }

async def _generate_sales_report(self, period: str, region: str = None, 
                               product_category: str = None) -> Dict:
    """Генерація детального звіту про продажі"""
    # Симуляція агрегації даних
    await asyncio.sleep(0.5)
    
    return {
        'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
        'period': period,
        'region': region,
        'product_category': product_category,
        'total_sales': 125000.00,
        'total_opportunities': 45,
        'conversion_rate': 0.67,
        'top_products': [
            {'product_id': 'PROD-001', 'sales': 45000},
            {'product_id': 'PROD-002', 'sales': 32000}
        ],
        'generated_at': datetime.now().isoformat()
    }

async def _send_notification(self, recipients: List[str], message: str, 
                           priority: str = 'medium', channel: str = 'email') -> Dict:
    """Відправка повідомлення через зазначений канал"""
    # Симуляція виклику сервісу повідомлень
    await asyncio.sleep(0.1)
    
    notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'notification_id': notification_id,
        'recipients': recipients,
        'channel': channel,
        'priority': priority,
        'status': 'sent',
        'sent_at': datetime.now().isoformat()
    }

def get_function_definitions(self) -> List[Dict]:
    """Отримання визначень функцій, сумісних з OpenAI, для всіх зареєстрованих функцій"""
    definitions = []
    
    for func_name, func_info in self.functions.items():
        definition = {
            'name': func_name,
            'description': func_info['description'],
            'parameters': {
                'type': 'object',
                'properties': {},
                'required': []
            }
        }
        
        for param_name, param_info in func_info['parameters'].items():
            definition['parameters']['properties'][param_name] = {
                'type': param_info['type'],
                'description': param_info.get('description', '')
            }
            
            if 'enum' in param_info:
                definition['parameters']['properties'][param_name]['enum'] = param_info['enum']
            
            if 'default' in param_info:
                definition['parameters']['properties'][param_name]['default'] = param_info['default']
            
            if param_info.get('required', False):
                definition['parameters']['required'].append(param_name)
        
        definitions.append(definition)
    
    return definitions

# Приклад використання для інтеграції в підприємстві
async def enterprise_demo():
    """Демонстрація можливостей AI-агента для підприємств"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # Приклад 1: Обробка запитів клієнтів
    print("=== Обробка запитів клієнтів ===")
    
    # Отримання інформації про клієнта
    result = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    if result.success:
        print(f"Інформація про клієнта отримана: {result.data['name']}")
        print(f"Час виконання: {result.execution_time:.3f}s")
    
    # Приклад 2: Створення можливості продажу
    print("\n=== Створення можливості продажу ===")
    
    result = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    if result.success:
        print(f"Можливість створена: {result.data['opportunity_id']}")
    
    # Приклад 3: Пакетні операції
    print("\n=== Пакетні операції ===")
    
    tasks = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': 'Створено нову можливість',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    results = await asyncio.gather(*tasks)
    
    for i, result in enumerate(results):
        if result.success:
            print(f"Завдання {i+1} виконано успішно")
        else:
            print(f"Завдання {i+1} не виконано: {result.error}")
    
    # Відображення журналу аудиту
    print(f"\n=== Журнал аудиту ({len(agent.audit_log)} записів) ===")
    for entry in agent.audit_log[-3:]:  # Показати останні 3 записи
        print(f"{entry['timestamp']}: {entry['function_name']} - {'УСПІХ' if entry['success'] else 'НЕВДАЧА'}")

# Запуск демонстрації для підприємств
# asyncio.run(enterprise_demo())
- **Моделі Phi-4**: [Колекція Hugging Face](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)
- **Документація Qwen3**: [Офіційна документація Qwen](https://qwen.readthedocs.io/)
- **Ollama**: [Офіційний вебсайт](https://ollama.com/)
- **Foundry Local**: [Репозиторій GitHub](https://github.com/microsoft/Foundry-Local)
- **Найкращі практики виклику функцій**: [Посібник Hugging Face](https://huggingface.co/docs/hugs/en/guides/function-calling)

Пам’ятайте, що виклик функцій — це галузь, яка постійно розвивається, і слідкування за останніми новинами у вибраних вами фреймворках та моделях допоможе створювати більш ефективних AI-агентів.


## ➡️ Що далі

- [03: Інтеграція протоколу контексту моделі (MCP)](./03.IntroduceMCP.md)

---

**Відмова від відповідальності**:  
Цей документ був перекладений за допомогою сервісу автоматичного перекладу [Co-op Translator](https://github.com/Azure/co-op-translator). Хоча ми прагнемо до точності, будь ласка, майте на увазі, що автоматичні переклади можуть містити помилки або неточності. Оригінальний документ на його рідній мові слід вважати авторитетним джерелом. Для критичної інформації рекомендується професійний людський переклад. Ми не несемо відповідальності за будь-які непорозуміння або неправильні тлумачення, що виникають внаслідок використання цього перекладу.