<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-09-17T23:05:31+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "tr"
}
-->
# Bölüm02 : Küçük Dil Modellerinde (SLM'ler) Fonksiyon Çağrısı

## İçindekiler
1. [Fonksiyon Çağrısı Nedir?](../../../Module06)
2. [Fonksiyon Çağrısı Nasıl Çalışır?](../../../Module06)
3. [Uygulama Senaryoları](../../../Module06)
4. [Phi-4-mini ve Ollama ile Fonksiyon Çağrısını Ayarlama](../../../Module06)
5. [Qwen3 Fonksiyon Çağrısı ile Çalışma](../../../Module06)
6. [Foundry Local Entegrasyonu](../../../Module06)
7. [En İyi Uygulamalar ve Sorun Giderme](../../../Module06)
8. [İleri Düzey Örnekler](../../../Module06)

## Fonksiyon Çağrısı Nedir?

Fonksiyon çağrısı, Küçük Dil Modellerinin (SLM'ler) harici araçlar, API'ler ve hizmetlerle etkileşim kurmasını sağlayan güçlü bir özelliktir. SLM'ler artık yalnızca eğitim verileriyle sınırlı kalmak yerine:

- **Harici API'lere bağlanabilir** (hava durumu hizmetleri, veritabanları, arama motorları)
- **Kullanıcı taleplerine göre belirli fonksiyonları çalıştırabilir**
- **Çeşitli kaynaklardan gerçek zamanlı bilgi alabilir**
- **Uzman araçlar aracılığıyla hesaplama görevlerini gerçekleştirebilir**
- **Karmaşık iş akışları için birden fazla işlemi zincirleyebilir**

Bu özellik, SLM'leri statik metin üreticilerinden gerçek dünya görevlerini yerine getirebilen dinamik yapay zeka ajanlarına dönüştürür.

## Fonksiyon Çağrısı Nasıl Çalışır?

Fonksiyon çağrısı süreci sistematik bir iş akışını takip eder:

### 1. Araç Entegrasyonu
- **Harici Araçlar**: SLM'ler hava durumu API'leri, veritabanları, web hizmetleri ve diğer harici sistemlere bağlanabilir
- **Fonksiyon Tanımları**: Her araç, belirli parametreler, giriş/çıkış formatları ve açıklamalarla tanımlanır
- **API Uyumluluğu**: Araçlar standart arayüzler (REST API'ler, SDK'lar vb.) aracılığıyla entegre edilir

### 2. Fonksiyon Tanımı
Fonksiyonlar üç temel bileşenle tanımlanır:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. Niyet Algılama
- **Doğal Dil İşleme**: SLM, kullanıcı girdisini analiz ederek niyeti anlar
- **Fonksiyon Eşleştirme**: Talebi yerine getirmek için hangi fonksiyonların gerektiğini belirler
- **Parametre Çıkarımı**: Kullanıcının mesajından gerekli parametreleri tanımlar ve çıkarır

### 4. JSON Çıktı Üretimi
SLM, aşağıdakileri içeren yapılandırılmış JSON oluşturur:
- Çağrılacak fonksiyon adı
- Gerekli parametreler ve uygun değerler
- Çalıştırma bağlamı ve meta veriler

### 5. Harici Çalıştırma
- **Parametre Doğrulama**: Tüm gerekli parametrelerin mevcut ve doğru biçimde olduğundan emin olur
- **Fonksiyon Çalıştırma**: Uygulama, sağlanan parametrelerle belirtilen fonksiyonu çalıştırır
- **Hata Yönetimi**: Başarısızlıkları, zaman aşımını ve geçersiz yanıtları yönetir

### 6. Yanıt Entegrasyonu
- **Sonuç İşleme**: Fonksiyon çıktısı SLM'ye geri döner
- **Bağlam Entegrasyonu**: SLM, sonuçları yanıtına entegre eder
- **Kullanıcı İletişimi**: Bilgiyi doğal, konuşma formatında sunar

## Uygulama Senaryoları

### Veri Alma
Doğal dil sorgularını yapılandırılmış API çağrılarına dönüştürün:
- **"Son siparişlerimi göster"** → Kullanıcı kimliği ve tarih filtreleriyle veritabanı sorgusu
- **"Tokyo'da hava nasıl?"** → Konum parametresiyle hava durumu API çağrısı
- **"Geçen hafta John'dan gelen e-postaları bul"** → Gönderen ve tarih filtreleriyle e-posta hizmeti sorgusu

### İşlem Yürütme
Kullanıcı taleplerini belirli fonksiyon çağrılarına dönüştürün:
- **"Yarın saat 2'de bir toplantı planla"** → Takvim API entegrasyonu
- **"Takıma bir mesaj gönder"** → İletişim platformu API'si
- **"Dosyalarımın yedeğini oluştur"** → Dosya sistemi işlemi

### Hesaplama Görevleri
Karmaşık matematiksel veya mantıksal işlemleri yönetin:
- **"10.000$ için %5 faizle 10 yıl boyunca bileşik faiz hesapla"** → Finansal hesaplama fonksiyonu
- **"Bu veri setini eğilimler için analiz et"** → İstatistiksel analiz araçları
- **"Teslimat için bu rotayı optimize et"** → Rota optimizasyon algoritmaları

### Veri İşleme İş Akışları
Karmaşık işlemler için birden fazla fonksiyon çağrısını zincirleyin:
1. **Birden fazla kaynaktan veri alın**
2. **Bilgiyi ayrıştırın ve doğrulayın**
3. **Veriyi gerekli formata dönüştürün**
4. **Sonuçları uygun sistemlere kaydedin**
5. **Raporlar veya görselleştirmeler oluşturun**

### UI/UX Entegrasyonu
Dinamik arayüz güncellemelerini etkinleştirin:
- **"Satış verilerini panoda göster"** → Grafik oluşturma ve görüntüleme
- **"Haritayı yeni konumlarla güncelle"** → Coğrafi veri entegrasyonu
- **"Envanter görüntüsünü yenile"** → Gerçek zamanlı veri senkronizasyonu

## Phi-4-mini ve Ollama ile Fonksiyon Çağrısını Ayarlama

Microsoft'un Phi-4-mini modeli, Ollama aracılığıyla hem tekli hem de paralel fonksiyon çağrısını destekler. İşte nasıl ayarlanacağı:

### Ön Koşullar
- Ollama sürüm 0.5.13 veya daha yüksek
- Phi-4-mini modeli (önerilen: `phi4-mini:3.8b-fp16`)

### Kurulum Adımları

#### 1. Phi-4-mini'yi Kur ve Çalıştır
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. Özel ModelFile Şablonu Oluştur
Ollama'nın varsayılan şablonlarındaki mevcut sınırlamalar nedeniyle, aşağıdaki şablonla özel bir ModelFile oluşturmanız gerekir:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. Özel Modeli Oluştur
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### Tekli Fonksiyon Çağrısı Örneği

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### Paralel Fonksiyon Çağrısı Örneği

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## Qwen3 Fonksiyon Çağrısı ile Çalışma

Qwen3, mükemmel performans ve esneklikle gelişmiş fonksiyon çağrısı yetenekleri sunar. İşte nasıl uygulanacağı:

### Qwen-Agent Çerçevesini Kullanma

Qwen-Agent, fonksiyon çağrısı uygulamasını basitleştiren üst düzey bir çerçeve sağlar:

#### Kurulum
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### Temel Ayar

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### Özel Fonksiyon Uygulaması

Qwen3 için özel fonksiyonlar da tanımlayabilirsiniz:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### Gelişmiş Qwen3 Özellikleri

#### Düşünme Modu Kontrolü
Qwen3, düşünme ve düşünmeme modları arasında dinamik geçişi destekler:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### Çok Adımlı Fonksiyon Çağrısı
Qwen3, birden fazla fonksiyon çağrısını zincirleme konusunda mükemmeldir:

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## Foundry Local Entegrasyonu

Microsoft'un Foundry Local, modelleri yerel olarak çalıştırmak için OpenAI uyumlu bir API sağlar ve gelişmiş gizlilik ve performans sunar.

### Kurulum ve Kurulum

#### Windows
[Foundry Local sürümleri sayfasından](https://github.com/microsoft/Foundry-Local/releases) yükleyiciyi indirin ve kurulum talimatlarını izleyin.

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### Temel Kullanım

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### Gelişmiş Foundry Local Özellikleri

#### Model Yönetimi
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### Performans Optimizasyonu
Foundry Local, donanımınız için en iyi model varyantını otomatik olarak seçer:
- **CUDA GPU**: GPU için optimize edilmiş modelleri indirir
- **Qualcomm NPU**: NPU hızlandırmalı varyantları kullanır
- **Yalnızca CPU**: CPU için optimize edilmiş modelleri seçer

## En İyi Uygulamalar ve Sorun Giderme

### Fonksiyon Tanımı İçin En İyi Uygulamalar

#### 1. Açık ve Tanımlayıcı İsimlendirme
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. Kapsamlı Parametre Tanımları
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. Giriş Doğrulama ve Hata Yönetimi
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### Yaygın Sorunlar ve Çözümleri

#### Sorun 1: Fonksiyon Çağrılmıyor
**Belirtiler**: Model, fonksiyonu çağırmak yerine metinle yanıt veriyor

**Çözümler**:
1. **Fonksiyon açıklamasını kontrol edin**: Kullanıcının niyetini açıkça karşılayıp karşılamadığını kontrol edin
2. **Parametre tanımlarını doğrulayın**: Tüm gerekli parametrelerin doğru şekilde tanımlandığından emin olun
3. **Sistem istemini gözden geçirin**: Fonksiyonların ne zaman kullanılacağına dair açık talimatlar ekleyin
4. **Açık taleplerle test edin**: "Lütfen Londra için veri almak için hava durumu fonksiyonunu kullanın" gibi ifadeler deneyin

#### Sorun 2: Yanlış Parametreler
**Belirtiler**: Fonksiyon yanlış veya eksik parametrelerle çağrılıyor

**Çözümler**:
1. **Parametre örnekleri ekleyin**: Parametre açıklamalarına örnek değerler ekleyin
2. **Enum kısıtlamaları kullanın**: Parametre değerlerini belirli seçeneklerle sınırlayın
3. **Yedek değerler uygulayın**: İsteğe bağlı parametreler için mantıklı varsayılanlar sağlayın

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### Sorun 3: Paralel Fonksiyon Çağrısı Hataları
**Belirtiler**: Birden fazla fonksiyon çalıştırılması gerektiğinde yalnızca biri çalışıyor

**Çözümler**:
1. **Model desteğini kontrol edin**: Modelinizin paralel fonksiyon çağrısını desteklediğinden emin olun
2. **Sistem istemini güncelleyin**: Sistem mesajına "bazı araçlar" veya "birden fazla araç" ekleyin
3. **Uygun model sürümlerini kullanın**: Ollama için Phi-4-mini:3.8b-fp16 önerilir

#### Sorun 4: Ollama ile Şablon Sorunları
**Belirtiler**: Fonksiyon çağrısı varsayılan Ollama ayarıyla çalışmıyor

**Çözümler**:
1. **Özel ModelFile kullanın**: Bu öğreticide sağlanan düzeltilmiş şablonu uygulayın
2. **Ollama'yı güncelleyin**: 0.5.13 veya daha yüksek bir sürüm kullandığınızdan emin olun
3. **Model kuantizasyonunu kontrol edin**: Daha yüksek kuantizasyon seviyeleri (Q8_0, fp16), aşırı kuantize edilmiş sürümlere göre daha iyi çalışır

### Performans Optimizasyonu

#### 1. Verimli Fonksiyon Tasarımı
- **Fonksiyonları odaklı tutun**: Her fonksiyonun tek bir, açık amacı olmalıdır
- **Harici bağımlılıkları en aza indirin**: API çağrılarını ve ağ isteklerini mümkün olduğunca azaltın
- **Sonuçları önbelleğe alın**: Sıkça talep edilen verileri saklayarak yanıt sürelerini iyileştirin

#### 2. Toplu İşleme ve Asenkron Operasyonlar
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. Kaynak Yönetimi
- **Bağlantı havuzu**: Veritabanı ve API bağlantılarını yeniden kullanın
- **Hız sınırlaması**: Harici API'ler için uygun hız sınırlaması uygulayın
- **Zaman aşımı yönetimi**: Tüm harici çağrılar için makul zaman aşımı süreleri belirleyin

## İleri Düzey Örnekler

### Çoklu Ajan İşbirliği Sistemi

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### Dinamik Araç Seçim Sistemi

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```
Lütfen bana çevrilecek Markdown dosyasını sağlayın, böylece Türkçe'ye çevirebilirim.
"""Bir fonksiyonu kapsamlı hata yönetimi ve kayıt tutma ile çalıştır"""

başlangıç_zamanı = datetime.now()

try:
    # Fonksiyonun varlığını doğrula
    if function_name not in self.functions:
        return FunctionResult(
            success=False,
            error=f"Fonksiyon '{function_name}' bulunamadı",
            timestamp=başlangıç_zamanı
        )
    
    # Hız limitlerini kontrol et
    if not self._check_rate_limit(function_name):
        return FunctionResult(
            success=False,
            error=f"Fonksiyon '{function_name}' için hız limiti aşıldı",
            timestamp=başlangıç_zamanı
        )
    
    # Parametreleri doğrula
    validation_result = self._validate_parameters(function_name, parameters)
    if not validation_result.success:
        return validation_result
    
    # Fonksiyonu çalıştır
    func_info = self.functions[function_name]
    handler = func_info['handler']
    
    if asyncio.iscoroutinefunction(handler):
        result_data = await handler(**parameters)
    else:
        result_data = handler(**parameters)
    
    execution_time = (datetime.now() - başlangıç_zamanı).total_seconds()
    
    result = FunctionResult(
        success=True,
        data=result_data,
        execution_time=execution_time,
        timestamp=başlangıç_zamanı
    )
    
    # Başarılı çalıştırmayı kaydet
    self._log_function_call(function_name, parameters, result)
    
    return result
    
except Exception as e:
    execution_time = (datetime.now() - başlangıç_zamanı).total_seconds()
    result = FunctionResult(
        success=False,
        error=str(e),
        execution_time=execution_time,
        timestamp=başlangıç_zamanı
    )
    
    # Başarısız çalıştırmayı kaydet
    self._log_function_call(function_name, parameters, result)
    
    return result

def _check_rate_limit(self, function_name: str) -> bool:
    """Fonksiyon çağrısının hız limitleri içinde olup olmadığını kontrol et"""
    func_info = self.functions[function_name]
    now = datetime.now()
    
    # Bir dakika geçtiyse sayaç sıfırla
    if (now - func_info['last_reset']).seconds >= 60:
        func_info['call_count'] = 0
        func_info['last_reset'] = now
    
    # Limit altında olup olmadığını kontrol et
    if func_info['call_count'] >= func_info['rate_limit']:
        return False
    
    func_info['call_count'] += 1
    return True

def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
    """Fonksiyon parametrelerini doğrula"""
    func_params = self.functions[function_name]['parameters']
    
    # Gerekli parametreleri kontrol et
    for param_name, param_info in func_params.items():
        if param_info.get('required', False) and param_name not in parameters:
            return FunctionResult(
                success=False,
                error=f"Gerekli parametre eksik: {param_name}"
            )
    
    # Parametre türlerini ve kısıtlamalarını doğrula
    for param_name, value in parameters.items():
        if param_name in func_params:
            param_info = func_params[param_name]
            
            # Tür doğrulama
            expected_type = param_info.get('type')
            if expected_type == 'string' and not isinstance(value, str):
                return FunctionResult(
                    success=False,
                    error=f"Parametre '{param_name}' bir string olmalı"
                )
            elif expected_type == 'number' and not isinstance(value, (int, float)):
                return FunctionResult(
                    success=False,
                    error=f"Parametre '{param_name}' bir sayı olmalı"
                )
            elif expected_type == 'boolean' and not isinstance(value, bool):
                return FunctionResult(
                    success=False,
                    error=f"Parametre '{param_name}' bir boolean olmalı"
                )
            
            # Enum doğrulama
            if 'enum' in param_info and value not in param_info['enum']:
                return FunctionResult(
                    success=False,
                    error=f"Parametre '{param_name}' şu değerlerden biri olmalı: {param_info['enum']}"
                )
    
    return FunctionResult(success=True)

def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):
    """Denetim amaçlı fonksiyon çağrısını kaydet"""
    log_entry = {
        'timestamp': result.timestamp.isoformat(),
        'function_name': function_name,
        'parameters': parameters,
        'success': result.success,
        'execution_time': result.execution_time,
        'error': result.error if not result.success else None
    }
    
    self.audit_log.append(log_entry)
    
    # İsteğe bağlı olarak harici kayıt sistemine yaz
    if self.config.get('enable_external_logging', False):
        self._write_to_external_log(log_entry)

def _write_to_external_log(self, log_entry: Dict):
    """Harici kayıt sistemine kayıt yaz"""
    # Uygulama, kayıt altyapınıza bağlı olacaktır
    # Örneğin, ELK stack, CloudWatch vb. gönderim
    pass

# İş Fonksiyonlarının Uygulamaları
async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
    """CRM sisteminden müşteri bilgilerini al"""
    # Veritabanı/API çağrısını simüle et
    await asyncio.sleep(0.1)  # Ağ gecikmesini simüle et
    
    customer_data = {
        'customer_id': customer_id,
        'name': 'John Doe',
        'email': 'john.doe@example.com',
        'phone': '+1-555-0123',
        'status': 'active',
        'tier': 'premium'
    }
    
    if include_history:
        customer_data['purchase_history'] = [
            {'date': '2024-01-15', 'product': 'Ürün A', 'amount': 1500},
            {'date': '2024-03-22', 'product': 'Ürün B', 'amount': 2300}
        ]
    
    return customer_data

async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                  estimated_value: float, expected_close_date: str) -> Dict:
    """Yeni bir satış fırsatı oluştur"""
    # CRM API çağrısını simüle et
    await asyncio.sleep(0.2)
    
    opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'opportunity_id': opportunity_id,
        'customer_id': customer_id,
        'product_id': product_id,
        'estimated_value': estimated_value,
        'expected_close_date': expected_close_date,
        'status': 'open',
        'created_date': datetime.now().isoformat()
    }

async def _generate_sales_report(self, period: str, region: str = None, 
                               product_category: str = None) -> Dict:
    """Kapsamlı satış raporu oluştur"""
    # Veri toplama işlemini simüle et
    await asyncio.sleep(0.5)
    
    return {
        'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
        'period': period,
        'region': region,
        'product_category': product_category,
        'total_sales': 125000.00,
        'total_opportunities': 45,
        'conversion_rate': 0.67,
        'top_products': [
            {'product_id': 'PROD-001', 'sales': 45000},
            {'product_id': 'PROD-002', 'sales': 32000}
        ],
        'generated_at': datetime.now().isoformat()
    }

async def _send_notification(self, recipients: List[str], message: str, 
                           priority: str = 'medium', channel: str = 'email') -> Dict:
    """Belirtilen kanal üzerinden bildirim gönder"""
    # Bildirim hizmeti çağrısını simüle et
    await asyncio.sleep(0.1)
    
    notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'notification_id': notification_id,
        'recipients': recipients,
        'channel': channel,
        'priority': priority,
        'status': 'sent',
        'sent_at': datetime.now().isoformat()
    }

def get_function_definitions(self) -> List[Dict]:
    """Kayıtlı tüm fonksiyonlar için OpenAI uyumlu fonksiyon tanımlarını al"""
    definitions = []
    
    for func_name, func_info in self.functions.items():
        definition = {
            'name': func_name,
            'description': func_info['description'],
            'parameters': {
                'type': 'object',
                'properties': {},
                'required': []
            }
        }
        
        for param_name, param_info in func_info['parameters'].items():
            definition['parameters']['properties'][param_name] = {
                'type': param_info['type'],
                'description': param_info.get('description', '')
            }
            
            if 'enum' in param_info:
                definition['parameters']['properties'][param_name]['enum'] = param_info['enum']
            
            if 'default' in param_info:
                definition['parameters']['properties'][param_name]['default'] = param_info['default']
            
            if param_info.get('required', False):
                definition['parameters']['required'].append(param_name)
        
        definitions.append(definition)
    
    return definitions

# Kurumsal Entegrasyon için Kullanım Örneği
async def enterprise_demo():
    """Kurumsal AI ajan yeteneklerini göster"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # Örnek 1: Müşteri sorgusu işleme
    print("=== Müşteri Sorgusu İşleme ===")
    
    # Müşteri bilgilerini al
    result = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    if result.success:
        print(f"Müşteri Bilgisi Alındı: {result.data['name']}")
        print(f"Çalıştırma Süresi: {result.execution_time:.3f}s")
    
    # Örnek 2: Satış fırsatı oluşturma
    print("\n=== Satış Fırsatı Oluşturma ===")
    
    result = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    if result.success:
        print(f"Fırsat Oluşturuldu: {result.data['opportunity_id']}")
    
    # Örnek 3: Toplu işlemler
    print("\n=== Toplu İşlemler ===")
    
    tasks = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': 'Yeni fırsat oluşturuldu',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    results = await asyncio.gather(*tasks)
    
    for i, result in enumerate(results):
        if result.success:
            print(f"Görev {i+1} başarıyla tamamlandı")
        else:
            print(f"Görev {i+1} başarısız oldu: {result.error}")
    
    # Denetim kaydını göster
    print(f"\n=== Denetim Kaydı ({len(agent.audit_log)} giriş) ===")
    for entry in agent.audit_log[-3:]:  # Son 3 girişi göster
        print(f"{entry['timestamp']}: {entry['function_name']} - {'BAŞARILI' if entry['success'] else 'BAŞARISIZ'}")

# Kurumsal demoyu çalıştır
# asyncio.run(enterprise_demo())

## Sonuç

Küçük Dil Modellerinde (SLM) fonksiyon çağrısı, statik AI asistanlarından gerçek dünyayla etkileşim kurabilen dinamik, yetenekli ajanlara geçişi temsil eder. Bu eğitimde şunlar ele alındı:

### Temel Çıkarımlar

1. **Temel Anlayış**: Fonksiyon çağrısı, SLM'lerin eğitim verilerinin ötesine geçerek harici araçlara ve hizmetlere bağlanmasını sağlar.

2. **Esnek Uygulama**: Düşük seviyeli özelleştirilmiş şablonlardan Qwen-Agent ve Foundry Local gibi yüksek seviyeli çerçevelere kadar çeşitli yaklaşımlar mevcuttur.

3. **Üretim Düşünceleri**: Kurumsal dağıtımlar hata yönetimi, hız sınırlaması, güvenlik ve denetim kaydı gibi konulara dikkat gerektirir.

4. **Performans Optimizasyonu**: Uygun fonksiyon tasarımı, verimli çalıştırma ve akıllı önbellekleme yanıt sürelerini önemli ölçüde iyileştirebilir.

### Gelecek Yönelimler

SLM teknolojisi gelişmeye devam ettikçe şunları bekleyebiliriz:

- **Geliştirilmiş Fonksiyon Çağrısı Doğruluğu**: Daha iyi niyet algılama ve parametre çıkarımı
- **Gelişmiş Paralel İşleme**: Daha sofistike çoklu fonksiyon düzenlemesi
- **Daha İyi Entegrasyon Standartları**: Araç entegrasyonu için standartlaştırılmış protokoller
- **Gelişmiş Güvenlik Özellikleri**: Geliştirilmiş kimlik doğrulama ve yetkilendirme mekanizmaları
- **Genişleyen Ekosistem**: Önceden oluşturulmuş fonksiyonlar ve entegrasyonların büyüyen kütüphanesi

### Başlangıç

Projelerinizde fonksiyon çağrısını uygulamaya başlamak için:

1. **Basit Başlayın**: Temel tek fonksiyon senaryolarıyla başlayın
2. **Çerçevenizi Seçin**: Doğrudan uygulama (Ollama/Phi-4) veya çerçeve destekli (Qwen-Agent) arasında seçim yapın
3. **Fonksiyonları Dikkatle Tasarlayın**: Açık, iyi belgelenmiş fonksiyon tanımlarına odaklanın
4. **Hata Yönetimini Uygulayın**: En başından itibaren sağlam hata yönetimi oluşturun
5. **Kademeli Ölçeklendirin**: Deneyim kazandıkça basit senaryolardan karmaşık senaryolara geçin

Fonksiyon çağrısı, SLM'leri etkileyici metin üreticilerinden gerçek dünya sorunlarını çözebilen pratik AI ajanlarına dönüştürür. Bu eğitimde belirtilen kalıpları ve uygulamaları takip ederek, geleneksel sohbet arayüzlerinin çok ötesine geçen güçlü, güvenilir AI sistemleri oluşturabilirsiniz.

### Kaynaklar ve Referanslar
- **Phi-4 Modelleri**: [Hugging Face Koleksiyonu](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)
- **Qwen3 Belgeleri**: [Resmi Qwen Belgeleri](https://qwen.readthedocs.io/)
- **Ollama**: [Resmi Web Sitesi](https://ollama.com/)
- **Foundry Local**: [GitHub Deposu](https://github.com/microsoft/Foundry-Local)
- **Fonksiyon Çağırma En İyi Uygulamaları**: [Hugging Face Rehberi](https://huggingface.co/docs/hugs/en/guides/function-calling)

Unutmayın ki fonksiyon çağırma sürekli gelişen bir alan olup, seçtiğiniz çerçeveler ve modellerdeki en son gelişmeleri takip etmek, daha etkili yapay zeka ajanları oluşturmanıza yardımcı olacaktır.


## ➡️ Sırada ne var

- [03: Model Bağlam Protokolü (MCP) Entegrasyonu](./03.IntroduceMCP.md)

---

**Feragatname**:  
Bu belge, AI çeviri hizmeti [Co-op Translator](https://github.com/Azure/co-op-translator) kullanılarak çevrilmiştir. Doğruluk için çaba göstersek de, otomatik çevirilerin hata veya yanlışlık içerebileceğini lütfen unutmayın. Belgenin orijinal dili, yetkili kaynak olarak kabul edilmelidir. Kritik bilgiler için profesyonel insan çevirisi önerilir. Bu çevirinin kullanımından kaynaklanan yanlış anlamalar veya yanlış yorumlamalar için sorumluluk kabul etmiyoruz.