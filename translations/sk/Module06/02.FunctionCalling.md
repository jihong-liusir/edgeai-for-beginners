<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-09-18T18:33:15+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "sk"
}
-->
# Section02 : Volanie funkcií v malých jazykových modeloch (SLMs)

## Obsah
1. [Čo je volanie funkcií?](../../../Module06)
2. [Ako funguje volanie funkcií](../../../Module06)
3. [Scenáre použitia](../../../Module06)
4. [Nastavenie volania funkcií s Phi-4-mini a Ollama](../../../Module06)
5. [Práca s volaním funkcií Qwen3](../../../Module06)
6. [Integrácia Foundry Local](../../../Module06)
7. [Najlepšie postupy a riešenie problémov](../../../Module06)
8. [Pokročilé príklady](../../../Module06)

## Čo je volanie funkcií?

Volanie funkcií je výkonná schopnosť, ktorá umožňuje malým jazykovým modelom (SLMs) interagovať s externými nástrojmi, API a službami. Namiesto obmedzenia na svoje tréningové dáta môžu SLMs teraz:

- **Pripojiť sa k externým API** (služby počasia, databázy, vyhľadávače)
- **Vykonávať konkrétne funkcie** na základe požiadaviek používateľa
- **Získavať informácie v reálnom čase** z rôznych zdrojov
- **Vykonávať výpočtové úlohy** prostredníctvom špecializovaných nástrojov
- **Reťaziť viacero operácií** pre komplexné pracovné postupy

Táto schopnosť transformuje SLMs zo statických generátorov textu na dynamických AI agentov schopných vykonávať úlohy v reálnom svete.

## Ako funguje volanie funkcií

Proces volania funkcií nasleduje systematický pracovný postup:

### 1. Integrácia nástrojov
- **Externé nástroje**: SLMs sa môžu pripojiť k API počasia, databázam, webovým službám a iným externým systémom
- **Definície funkcií**: Každý nástroj je definovaný so špecifickými parametrami, formátmi vstupov/výstupov a popismi
- **Kompatibilita API**: Nástroje sú integrované prostredníctvom štandardizovaných rozhraní (REST API, SDK, atď.)

### 2. Definícia funkcií
Funkcie sú definované s tromi kľúčovými komponentmi:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. Detekcia zámeru
- **Spracovanie prirodzeného jazyka**: SLM analyzuje vstup používateľa na pochopenie zámeru
- **Priradenie funkcie**: Určuje, ktoré funkcie sú potrebné na splnenie požiadavky
- **Extrahovanie parametrov**: Identifikuje a extrahuje požadované parametre zo správy používateľa

### 4. Generovanie výstupu JSON
SLM generuje štruktúrovaný JSON obsahujúci:
- Názov funkcie na volanie
- Požadované parametre s vhodnými hodnotami
- Kontext vykonania a metadáta

### 5. Externé vykonanie
- **Validácia parametrov**: Zabezpečuje, že všetky požadované parametre sú prítomné a správne formátované
- **Vykonanie funkcie**: Aplikácia vykoná špecifikovanú funkciu s poskytnutými parametrami
- **Riešenie chýb**: Spravuje zlyhania, časové limity a neplatné odpovede

### 6. Integrácia odpovede
- **Spracovanie výsledkov**: Výstup funkcie je vrátený do SLM
- **Integrácia kontextu**: SLM začlení výsledky do svojej odpovede
- **Komunikácia s používateľom**: Predstaví informácie v prirodzenom, konverzačnom formáte

## Scenáre použitia

### Získavanie údajov
Konvertovanie dotazov v prirodzenom jazyku na štruktúrované API volania:
- **"Ukáž moje nedávne objednávky"** → Dotaz do databázy s ID používateľa a filtrami dátumu
- **"Aké je počasie v Tokiu?"** → Volanie API počasia s parametrom lokácie
- **"Nájdi e-maily od Johna z minulého týždňa"** → Dotaz do e-mailovej služby s odosielateľom a filtrami dátumu

### Vykonávanie operácií
Transformácia požiadaviek používateľa na konkrétne volania funkcií:
- **"Naplánuj stretnutie na zajtra o 14:00"** → Integrácia kalendára API
- **"Pošli správu tímu"** → API komunikačnej platformy
- **"Vytvor zálohu mojich súborov"** → Operácia súborového systému

### Výpočtové úlohy
Riešenie komplexných matematických alebo logických operácií:
- **"Vypočítaj zložený úrok na $10,000 pri 5% na 10 rokov"** → Funkcia finančných výpočtov
- **"Analyzuj tento dataset na trendy"** → Nástroje štatistickej analýzy
- **"Optimalizuj túto trasu pre doručenie"** → Algoritmy optimalizácie trás

### Pracovné postupy spracovania údajov
Reťazenie viacerých volaní funkcií pre komplexné operácie:
1. **Získanie údajov** z viacerých zdrojov
2. **Parsovanie a validácia** informácií
3. **Transformácia** údajov do požadovaného formátu
4. **Ukladanie výsledkov** do vhodných systémov
5. **Generovanie správ** alebo vizualizácií

### Integrácia UI/UX
Umožnenie dynamických aktualizácií rozhrania:
- **"Ukáž údaje o predaji na paneli"** → Generovanie a zobrazenie grafov
- **"Aktualizuj mapu s novými lokalitami"** → Integrácia geodát
- **"Obnov zobrazenie inventára"** → Synchronizácia údajov v reálnom čase

## Nastavenie volania funkcií s Phi-4-mini a Ollama

Phi-4-mini od Microsoftu podporuje jednorazové aj paralelné volanie funkcií prostredníctvom Ollama. Tu je postup nastavenia:

### Predpoklady
- Ollama verzia 0.5.13 alebo vyššia
- Model Phi-4-mini (odporúčaný: `phi4-mini:3.8b-fp16`)

### Kroky inštalácie

#### 1. Inštalácia a spustenie Phi-4-mini
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. Vytvorenie vlastnej šablóny ModelFile
Kvôli aktuálnym obmedzeniam v predvolených šablónach Ollama je potrebné vytvoriť vlastný ModelFile s nasledujúcou šablónou:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. Vytvorenie vlastného modelu
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### Príklad jednorazového volania funkcie

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### Príklad paralelného volania funkcií

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## Práca s volaním funkcií Qwen3

Qwen3 ponúka pokročilé schopnosti volania funkcií s vynikajúcim výkonom a flexibilitou. Tu je postup implementácie:

### Použitie rámca Qwen-Agent

Qwen-Agent poskytuje vysokoúrovňový rámec, ktorý zjednodušuje implementáciu volania funkcií:

#### Inštalácia
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### Základné nastavenie

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### Implementácia vlastných funkcií

Môžete tiež definovať vlastné funkcie pre Qwen3:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### Pokročilé funkcie Qwen3

#### Ovládanie režimu myslenia
Qwen3 podporuje dynamické prepínanie medzi režimom myslenia a nemyslenia:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### Viackrokové volanie funkcií
Qwen3 vyniká v reťazení viacerých volaní funkcií:

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## Integrácia Foundry Local

Foundry Local od Microsoftu poskytuje API kompatibilné s OpenAI na lokálne spúšťanie modelov s vylepšeným súkromím a výkonom.

### Nastavenie a inštalácia

#### Windows
Stiahnite inštalačný program zo [stránky vydaní Foundry Local](https://github.com/microsoft/Foundry-Local/releases) a postupujte podľa pokynov na inštaláciu.

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### Základné použitie

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### Pokročilé funkcie Foundry Local

#### Správa modelov
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### Optimalizácia výkonu
Foundry Local automaticky vyberá najlepšiu variantu modelu pre váš hardvér:
- **CUDA GPU**: Sťahuje modely optimalizované pre GPU
- **Qualcomm NPU**: Používa varianty akcelerované NPU
- **Iba CPU**: Vyberá modely optimalizované pre CPU

## Najlepšie postupy a riešenie problémov

### Najlepšie postupy pri definícii funkcií

#### 1. Jasné a popisné názvy
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. Komplexné definície parametrov
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. Validácia vstupov a riešenie chýb
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### Bežné problémy a riešenia

#### Problém 1: Funkcia sa nevolá
**Príznaky**: Model odpovedá textom namiesto volania funkcie

**Riešenia**:
1. **Skontrolujte popis funkcie**: Uistite sa, že jasne zodpovedá zámeru používateľa
2. **Overte definície parametrov**: Uistite sa, že všetky požadované parametre sú správne definované
3. **Preskúmajte systémový prompt**: Zahrňte jasné pokyny o tom, kedy použiť funkcie
4. **Testujte s explicitnými požiadavkami**: Skúste "Prosím, použite funkciu počasia na získanie údajov pre Londýn"

#### Problém 2: Nesprávne parametre
**Príznaky**: Funkcia sa volá s nesprávnymi alebo chýbajúcimi parametrami

**Riešenia**:
1. **Pridajte príklady parametrov**: Zahrňte vzorové hodnoty do popisov parametrov
2. **Použite obmedzenia enum**: Obmedzte hodnoty parametrov na konkrétne možnosti, ak je to možné
3. **Implementujte náhradné hodnoty**: Poskytnite rozumné predvolené hodnoty pre voliteľné parametre

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### Problém 3: Zlyhanie paralelného volania funkcií
**Príznaky**: Vykoná sa iba jedna funkcia, keď by mali bežať viaceré

**Riešenia**:
1. **Skontrolujte podporu modelu**: Uistite sa, že váš model podporuje paralelné volanie funkcií
2. **Aktualizujte systémový prompt**: Zahrňte "niektoré nástroje" alebo "viaceré nástroje" do systémovej správy
3. **Použite vhodné verzie modelov**: Odporúčaný Phi-4-mini:3.8b-fp16 pre Ollama

#### Problém 4: Problémy so šablónou v Ollama
**Príznaky**: Volanie funkcií nefunguje s predvoleným nastavením Ollama

**Riešenia**:
1. **Použite vlastný ModelFile**: Použite opravenú šablónu uvedenú v tomto návode
2. **Aktualizujte Ollama**: Uistite sa, že používate verziu 0.5.13 alebo vyššiu
3. **Skontrolujte kvantizáciu modelu**: Vyššie úrovne kvantizácie (Q8_0, fp16) fungujú lepšie ako silne kvantizované verzie

### Optimalizácia výkonu

#### 1. Efektívny dizajn funkcií
- **Zamerajte funkcie**: Každá funkcia by mala mať jeden jasný účel
- **Minimalizujte externé závislosti**: Znížte volania API a sieťové požiadavky, kde je to možné
- **Cache výsledkov**: Ukladajte často požadované údaje na zlepšenie času odozvy

#### 2. Batching a asynchrónne operácie
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. Správa zdrojov
- **Pooling pripojení**: Znovu použite pripojenia k databázam a API
- **Obmedzenie rýchlosti**: Implementujte správne obmedzenie rýchlosti pre externé API
- **Spracovanie časových limitov**: Nastavte rozumné časové limity pre všetky externé volania

## Pokročilé príklady

### Systém spolupráce viacerých agentov

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### Systém dynamického výberu nástrojov

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```
# Úvod

Tento dokument poskytuje prehľad o tom, ako používať @@INLINE_CODE_1@@ na dosiahnutie optimálnych výsledkov.

## Požiadavky

Pred začatím sa uistite, že máte nainštalované nasledujúce:

- @@INLINE_CODE_2@@ vo verzii 3.0 alebo novšej
- Prístup k @@INLINE_CODE_3@@

## Inštalácia

1. Stiahnite si balík z @@INLINE_CODE_4@@.
2. Spustite príkaz @@INLINE_CODE_5@@ na inštaláciu.
3. Overte inštaláciu pomocou @@INLINE_CODE_6@@.

[!NOTE] Ak narazíte na problémy počas inštalácie, pozrite si dokumentáciu na @@INLINE_CODE_7@@.

## Použitie

### Základné nastavenie

Použite nasledujúci kód na inicializáciu:

```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

[!TIP] Uistite sa, že ste správne nastavili premenné pred spustením.

### Príklad

Tu je jednoduchý príklad, ako používať @@INLINE_CODE_8@@:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

[!WARNING] Nepoužívajte @@INLINE_CODE_9@@ v produkčnom prostredí bez dôkladného testovania.

## Časté otázky

**Otázka:** Ako môžem aktualizovať na najnovšiu verziu?  
**Odpoveď:** Spustite príkaz @@INLINE_CODE_10@@ a postupujte podľa pokynov.

**Otázka:** Čo robiť, ak narazím na chybu?  
**Odpoveď:** Skontrolujte logy v @@INLINE_CODE_11@@ a kontaktujte podporu na @@INLINE_CODE_12@@.

[!IMPORTANT] Vždy zálohujte svoje dáta pred vykonaním akýchkoľvek zmien.

## Záver

Dodržiavaním vyššie uvedených krokov môžete efektívne používať @@INLINE_CODE_13@@ na dosiahnutie svojich cieľov. Ak máte ďalšie otázky, neváhajte sa obrátiť na našu podporu.
„Vykonajte funkciu s komplexným spracovaním chýb a logovaním“  
start_time = datetime.now()  

try:  
    # Overenie, či funkcia existuje  
    if function_name not in self.functions:  
        return FunctionResult(  
            success=False,  
            error=f"Funkcia '{function_name}' nebola nájdená",  
            timestamp=start_time  
        )  

    # Kontrola limitov volaní  
    if not self._check_rate_limit(function_name):  
        return FunctionResult(  
            success=False,  
            error=f"Prekročený limit volaní pre funkciu '{function_name}'",  
            timestamp=start_time  
        )  

    # Overenie parametrov  
    validation_result = self._validate_parameters(function_name, parameters)  
    if not validation_result.success:  
        return validation_result  

    # Vykonanie funkcie  
    func_info = self.functions[function_name]  
    handler = func_info['handler']  

    if asyncio.iscoroutinefunction(handler):  
        result_data = await handler(**parameters)  
    else:  
        result_data = handler(**parameters)  

    execution_time = (datetime.now() - start_time).total_seconds()  

    result = FunctionResult(  
        success=True,  
        data=result_data,  
        execution_time=execution_time,  
        timestamp=start_time  
    )  

    # Logovanie úspešného vykonania  
    self._log_function_call(function_name, parameters, result)  

    return result  

except Exception as e:  
    execution_time = (datetime.now() - start_time).total_seconds()  
    result = FunctionResult(  
        success=False,  
        error=str(e),  
        execution_time=execution_time,  
        timestamp=start_time  
    )  

    # Logovanie neúspešného vykonania  
    self._log_function_call(function_name, parameters, result)  

    return result  

def _check_rate_limit(self, function_name: str) -> bool:  
    „Skontrolujte, či je volanie funkcie v rámci limitov“  
    func_info = self.functions[function_name]  
    now = datetime.now()  

    # Resetovanie počítadla, ak uplynula minúta  
    if (now - func_info['last_reset']).seconds >= 60:  
        func_info['call_count'] = 0  
        func_info['last_reset'] = now  

    # Kontrola, či je pod limitom  
    if func_info['call_count'] >= func_info['rate_limit']:  
        return False  

    func_info['call_count'] += 1  
    return True  

def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:  
    „Overenie parametrov funkcie“  
    func_params = self.functions[function_name]['parameters']  

    # Kontrola povinných parametrov  
    for param_name, param_info in func_params.items():  
        if param_info.get('required', False) and param_name not in parameters:  
            return FunctionResult(  
                success=False,  
                error=f"Chýba povinný parameter: {param_name}"  
            )  

    # Overenie typov parametrov a obmedzení  
    for param_name, value in parameters.items():  
        if param_name in func_params:  
            param_info = func_params[param_name]  

            # Overenie typu  
            expected_type = param_info.get('type')  
            if expected_type == 'string' and not isinstance(value, str):  
                return FunctionResult(  
                    success=False,  
                    error=f"Parameter '{param_name}' musí byť typu string"  
                )  
            elif expected_type == 'number' and not isinstance(value, (int, float)):  
                return FunctionResult(  
                    success=False,  
                    error=f"Parameter '{param_name}' musí byť číslo"  
                )  
            elif expected_type == 'boolean' and not isinstance(value, bool):  
                return FunctionResult(  
                    success=False,  
                    error=f"Parameter '{param_name}' musí byť boolean"  
                )  

            # Overenie enum  
            if 'enum' in param_info and value not in param_info['enum']:  
                return FunctionResult(  
                    success=False,  
                    error=f"Parameter '{param_name}' musí byť jeden z: {param_info['enum']}"  
                )  

    return FunctionResult(success=True)  

def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):  
    „Logovanie volania funkcie na účely auditu“  
    log_entry = {  
        'timestamp': result.timestamp.isoformat(),  
        'function_name': function_name,  
        'parameters': parameters,  
        'success': result.success,  
        'execution_time': result.execution_time,  
        'error': result.error if not result.success else None  
    }  

    self.audit_log.append(log_entry)  

    # Voliteľne zapisovať do externého logovacieho systému  
    if self.config.get('enable_external_logging', False):  
        self._write_to_external_log(log_entry)  

def _write_to_external_log(self, log_entry: Dict):  
    „Zapisovanie logov do externého logovacieho systému“  
    # Implementácia závisí od vašej logovacej infraštruktúry  
    # napr. posielanie do ELK stacku, CloudWatch, atď.  
    pass  

# Implementácie obchodných funkcií  
async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:  
    „Získanie informácií o zákazníkovi z CRM systému“  
    # Simulácia volania databázy/API  
    await asyncio.sleep(0.1)  # Simulácia sieťového oneskorenia  

    customer_data = {  
        'customer_id': customer_id,  
        'name': 'John Doe',  
        'email': 'john.doe@example.com',  
        'phone': '+1-555-0123',  
        'status': 'active',  
        'tier': 'premium'  
    }  

    if include_history:  
        customer_data['purchase_history'] = [  
            {'date': '2024-01-15', 'product': 'Product A', 'amount': 1500},  
            {'date': '2024-03-22', 'product': 'Product B', 'amount': 2300}  
        ]  

    return customer_data  

async def _create_sales_opportunity(self, customer_id: str, product_id: str,  
                                  estimated_value: float, expected_close_date: str) -> Dict:  
    „Vytvorenie novej obchodnej príležitosti“  
    # Simulácia volania CRM API  
    await asyncio.sleep(0.2)  

    opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"  

    return {  
        'opportunity_id': opportunity_id,  
        'customer_id': customer_id,  
        'product_id': product_id,  
        'estimated_value': estimated_value,  
        'expected_close_date': expected_close_date,  
        'status': 'open',  
        'created_date': datetime.now().isoformat()  
    }  

async def _generate_sales_report(self, period: str, region: str = None,  
                               product_category: str = None) -> Dict:  
    „Generovanie komplexnej správy o predaji“  
    # Simulácia agregácie dát  
    await asyncio.sleep(0.5)  

    return {  
        'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",  
        'period': period,  
        'region': region,  
        'product_category': product_category,  
        'total_sales': 125000.00,  
        'total_opportunities': 45,  
        'conversion_rate': 0.67,  
        'top_products': [  
            {'product_id': 'PROD-001', 'sales': 45000},  
            {'product_id': 'PROD-002', 'sales': 32000}  
        ],  
        'generated_at': datetime.now().isoformat()  
    }  

async def _send_notification(self, recipients: List[str], message: str,  
                           priority: str = 'medium', channel: str = 'email') -> Dict:  
    „Odoslanie notifikácie cez zvolený kanál“  
    # Simulácia volania notifikačnej služby  
    await asyncio.sleep(0.1)  

    notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"  

    return {  
        'notification_id': notification_id,  
        'recipients': recipients,  
        'channel': channel,  
        'priority': priority,  
        'status': 'sent',  
        'sent_at': datetime.now().isoformat()  
    }  

def get_function_definitions(self) -> List[Dict]:  
    „Získanie definícií funkcií kompatibilných s OpenAI pre všetky registrované funkcie“  
    definitions = []  

    for func_name, func_info in self.functions.items():  
        definition = {  
            'name': func_name,  
            'description': func_info['description'],  
            'parameters': {  
                'type': 'object',  
                'properties': {},  
                'required': []  
            }  
        }  

        for param_name, param_info in func_info['parameters'].items():  
            definition['parameters']['properties'][param_name] = {  
                'type': param_info['type'],  
                'description': param_info.get('description', '')  
            }  

            if 'enum' in param_info:  
                definition['parameters']['properties'][param_name]['enum'] = param_info['enum']  

            if 'default' in param_info:  
                definition['parameters']['properties'][param_name]['default'] = param_info['default']  

            if param_info.get('required', False):  
                definition['parameters']['required'].append(param_name)  

        definitions.append(definition)  

    return definitions  

# Príklad použitia pre podnikové integrácie  
async def enterprise_demo():  
    „Ukážka schopností podnikových AI agentov“  

    config = {  
        'enable_external_logging': True,  
        'max_concurrent_functions': 10,  
        'default_timeout': 30  
    }  

    agent = EnterpriseAIAgent(config)  

    # Príklad 1: Spracovanie zákazníckych dopytov  
    print("=== Spracovanie zákazníckych dopytov ===")  

    # Získanie informácií o zákazníkovi  
    result = await agent.execute_function(  
        'get_customer_info',  
        {'customer_id': 'CUST-12345', 'include_history': True}  
    )  

    if result.success:  
        print(f"Informácie o zákazníkovi získané: {result.data['name']}")  
        print(f"Čas vykonania: {result.execution_time:.3f}s")  

    # Príklad 2: Vytvorenie obchodnej príležitosti  
    print("\n=== Vytvorenie obchodnej príležitosti ===")  

    result = await agent.execute_function(  
        'create_sales_opportunity',  
        {  
            'customer_id': 'CUST-12345',  
            'product_id': 'PROD-001',  
            'estimated_value': 15000.0,  
            'expected_close_date': '2025-09-30'  
        }  
    )  

    if result.success:  
        print(f"Príležitosť vytvorená: {result.data['opportunity_id']}")  

    # Príklad 3: Hromadné operácie  
    print("\n=== Hromadné operácie ===")  

    tasks = [  
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),  
        agent.execute_function('send_notification', {  
            'recipients': ['manager@company.com'],  
            'message': 'Nová príležitosť vytvorená',  
            'priority': 'high',  
            'channel': 'email'  
        })  
    ]  

    results = await asyncio.gather(*tasks)  

    for i, result in enumerate(results):  
        if result.success:  
            print(f"Úloha {i+1} úspešne dokončená")  
        else:  
            print(f"Úloha {i+1} zlyhala: {result.error}")  

    # Zobrazenie audit logu  
    print(f"\n=== Audit Log ({len(agent.audit_log)} záznamov) ===")  
    for entry in agent.audit_log[-3:]:  # Zobraziť posledné 3 záznamy  
        print(f"{entry['timestamp']}: {entry['function_name']} - {'ÚSPECH' if entry['success'] else 'ZLYHANIE'}")  

# Spustenie podnikovej ukážky  
# asyncio.run(enterprise_demo())  

## Záver  

Volanie funkcií v malých jazykových modeloch predstavuje posun od statických AI asistentov k dynamickým, schopným agentom, ktorí dokážu interagovať s reálnym svetom. Tento tutoriál pokryl:  

### Kľúčové poznatky  

1. **Základné pochopenie**: Volanie funkcií umožňuje SLM rozšíriť sa nad rámec ich tréningových dát prostredníctvom pripojenia k externým nástrojom a službám.  

2. **Flexibilita implementácie**: Existuje viacero prístupov, od nízkoúrovňových implementácií s vlastnými šablónami až po vysokoúrovňové rámce ako Qwen-Agent a Foundry Local.  

3. **Produkčné úvahy**: Podnikové nasadenia vyžadujú pozornosť na spracovanie chýb, limity volaní, bezpečnosť a audit logovanie.  

4. **Optimalizácia výkonu**: Správny návrh funkcií, efektívne vykonávanie a inteligentné cachovanie môžu výrazne zlepšiť časy odozvy.  

### Budúce smerovanie  

Ako sa technológia SLM ďalej vyvíja, môžeme očakávať:  

- **Zlepšená presnosť volania funkcií**: Lepšia detekcia zámerov a extrakcia parametrov  
- **Pokročilé paralelné spracovanie**: Sofistikovanejšia orchestrácia viacerých funkcií  
- **Lepšie integračné štandardy**: Štandardizované protokoly pre integráciu nástrojov  
- **Pokročilé bezpečnostné funkcie**: Vylepšené mechanizmy autentifikácie a autorizácie  
- **Rozšírený ekosystém**: Rastúca knižnica predpripravených funkcií a integrácií  

### Začiatok  

Ak chcete začať implementovať volanie funkcií vo svojich projektoch:  

1. **Začnite jednoducho**: Začnite s jednoduchými scenármi jednofunkčných volaní  
2. **Vyberte si rámec**: Vyberte si medzi priamou implementáciou (Ollama/Phi-4) alebo rámcom (Qwen-Agent)  
3. **Dôkladne navrhnite funkcie**: Zamerajte sa na jasné, dobre dokumentované definície funkcií  
4. **Implementujte spracovanie chýb**: Od začiatku budujte robustné spracovanie chýb  
5. **Postupne škálujte**: Prejdite od jednoduchých k zložitejším scenárom, ako získate skúsenosti  

Volanie funkcií transformuje SLM z pôsobivých generátorov textu na praktických AI agentov schopných riešiť reálne problémy. Dodržiavaním vzorov a postupov uvedených v tomto tutoriáli môžete vytvárať výkonné, spoľahlivé AI systémy, ktoré presahujú tradičné chatovacie rozhrania.  

### Zdroje a odkazy  
- **Phi-4 Modely**: [Hugging Face Kolekcia](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)
- **Qwen3 Dokumentácia**: [Oficiálna Qwen Dokumentácia](https://qwen.readthedocs.io/)
- **Ollama**: [Oficiálna Webstránka](https://ollama.com/)
- **Foundry Local**: [GitHub Repozitár](https://github.com/microsoft/Foundry-Local)
- **Najlepšie Praktiky pre Volanie Funkcií**: [Hugging Face Príručka](https://huggingface.co/docs/hugs/en/guides/function-calling)

Pamätajte, že volanie funkcií je dynamicky sa rozvíjajúca oblasť, a sledovanie najnovších vývojov vo vašich vybraných frameworkoch a modeloch vám pomôže vytvárať efektívnejších AI agentov.


## ➡️ Čo ďalej

- [03: Integrácia Model Context Protocol (MCP)](./03.IntroduceMCP.md)

---

**Upozornenie**:  
Tento dokument bol preložený pomocou služby AI prekladu [Co-op Translator](https://github.com/Azure/co-op-translator). Hoci sa snažíme o presnosť, prosím, berte na vedomie, že automatizované preklady môžu obsahovať chyby alebo nepresnosti. Pôvodný dokument v jeho pôvodnom jazyku by mal byť považovaný za autoritatívny zdroj. Pre kritické informácie sa odporúča profesionálny ľudský preklad. Nie sme zodpovední za akékoľvek nedorozumenia alebo nesprávne interpretácie vyplývajúce z použitia tohto prekladu.