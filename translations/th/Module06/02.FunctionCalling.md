<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-09-18T07:17:50+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "th"
}
-->
# Section02 : การเรียกใช้งานฟังก์ชันใน Small Language Models (SLMs)

## สารบัญ
1. [Function Calling คืออะไร?](../../../Module06)
2. [Function Calling ทำงานอย่างไร](../../../Module06)
3. [กรณีการใช้งาน](../../../Module06)
4. [การตั้งค่า Function Calling ด้วย Phi-4-mini และ Ollama](../../../Module06)
5. [การทำงานกับ Qwen3 Function Calling](../../../Module06)
6. [การรวม Foundry Local](../../../Module06)
7. [แนวทางปฏิบัติที่ดีที่สุดและการแก้ไขปัญหา](../../../Module06)
8. [ตัวอย่างขั้นสูง](../../../Module06)

## Function Calling คืออะไร?

Function Calling เป็นความสามารถที่ทรงพลังที่ช่วยให้ Small Language Models (SLMs) สามารถเชื่อมต่อกับเครื่องมือภายนอก, APIs และบริการต่างๆ ได้ โดยไม่จำกัดเพียงข้อมูลที่ได้รับการฝึกอบรม SLMs สามารถ:

- **เชื่อมต่อกับ APIs ภายนอก** (บริการพยากรณ์อากาศ, ฐานข้อมูล, เครื่องมือค้นหา)
- **ดำเนินการฟังก์ชันเฉพาะ** ตามคำขอของผู้ใช้
- **ดึงข้อมูลแบบเรียลไทม์** จากแหล่งข้อมูลต่างๆ
- **ทำงานคำนวณ** ผ่านเครื่องมือเฉพาะทาง
- **เชื่อมโยงการดำเนินการหลายขั้นตอน** เพื่อสร้างกระบวนการที่ซับซ้อน

ความสามารถนี้เปลี่ยน SLMs จากเครื่องมือสร้างข้อความแบบคงที่ให้กลายเป็นตัวแทน AI ที่สามารถทำงานในโลกจริงได้

## Function Calling ทำงานอย่างไร

กระบวนการ Function Calling มีขั้นตอนที่เป็นระบบดังนี้:

### 1. การรวมเครื่องมือ
- **เครื่องมือภายนอก**: SLMs สามารถเชื่อมต่อกับ APIs พยากรณ์อากาศ, ฐานข้อมูล, บริการเว็บ และระบบอื่นๆ
- **การกำหนดฟังก์ชัน**: เครื่องมือแต่ละตัวถูกกำหนดด้วยพารามิเตอร์เฉพาะ, รูปแบบการรับ/ส่งข้อมูล และคำอธิบาย
- **ความเข้ากันได้กับ API**: เครื่องมือถูกเชื่อมต่อผ่านอินเทอร์เฟซมาตรฐาน (REST APIs, SDKs เป็นต้น)

### 2. การกำหนดฟังก์ชัน
ฟังก์ชันถูกกำหนดด้วยองค์ประกอบสำคัญสามส่วน:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. การตรวจจับเจตนา
- **การประมวลผลภาษาธรรมชาติ**: SLM วิเคราะห์ข้อความของผู้ใช้เพื่อทำความเข้าใจเจตนา
- **การจับคู่ฟังก์ชัน**: กำหนดว่าฟังก์ชันใดที่จำเป็นในการตอบสนองคำขอ
- **การดึงพารามิเตอร์**: ระบุและดึงพารามิเตอร์ที่จำเป็นจากข้อความของผู้ใช้

### 4. การสร้าง JSON Output
SLM สร้าง JSON ที่มีโครงสร้างซึ่งประกอบด้วย:
- ชื่อฟังก์ชันที่ต้องเรียกใช้
- พารามิเตอร์ที่จำเป็นพร้อมค่าที่เหมาะสม
- บริบทการดำเนินการและข้อมูลเมตา

### 5. การดำเนินการภายนอก
- **การตรวจสอบพารามิเตอร์**: ตรวจสอบว่าพารามิเตอร์ทั้งหมดมีอยู่และมีรูปแบบที่ถูกต้อง
- **การดำเนินการฟังก์ชัน**: แอปพลิเคชันดำเนินการฟังก์ชันที่ระบุด้วยพารามิเตอร์ที่ให้มา
- **การจัดการข้อผิดพลาด**: จัดการความล้มเหลว, การหมดเวลา และการตอบสนองที่ไม่ถูกต้อง

### 6. การรวมผลลัพธ์
- **การประมวลผลผลลัพธ์**: ผลลัพธ์ของฟังก์ชันถูกส่งกลับไปยัง SLM
- **การรวมบริบท**: SLM รวมผลลัพธ์เข้ากับการตอบสนอง
- **การสื่อสารกับผู้ใช้**: นำเสนอข้อมูลในรูปแบบที่เป็นธรรมชาติและสนทนา

## กรณีการใช้งาน

### การดึงข้อมูล
แปลงคำถามภาษาธรรมชาติเป็นการเรียก API ที่มีโครงสร้าง:
- **"แสดงคำสั่งซื้อล่าสุดของฉัน"** → คำสั่งฐานข้อมูลพร้อม ID ผู้ใช้และตัวกรองวันที่
- **"อากาศที่โตเกียวเป็นอย่างไร?"** → การเรียก API พยากรณ์อากาศพร้อมพารามิเตอร์ตำแหน่ง
- **"ค้นหาอีเมลจาก John เมื่อสัปดาห์ที่แล้ว"** → คำสั่งบริการอีเมลพร้อมตัวกรองผู้ส่งและวันที่

### การดำเนินการ
แปลงคำขอของผู้ใช้เป็นการเรียกฟังก์ชันเฉพาะ:
- **"จัดประชุมสำหรับพรุ่งนี้เวลา 14.00 น."** → การรวม API ปฏิทิน
- **"ส่งข้อความถึงทีม"** → API แพลตฟอร์มการสื่อสาร
- **"สร้างสำรองข้อมูลของไฟล์ของฉัน"** → การดำเนินการระบบไฟล์

### งานคำนวณ
จัดการการคำนวณทางคณิตศาสตร์หรือเชิงตรรกะที่ซับซ้อน:
- **"คำนวณดอกเบี้ยทบต้นสำหรับ $10,000 ที่ 5% เป็นเวลา 10 ปี"** → ฟังก์ชันการคำนวณทางการเงิน
- **"วิเคราะห์ชุดข้อมูลนี้เพื่อหาแนวโน้ม"** → เครื่องมือวิเคราะห์ทางสถิติ
- **"ปรับเส้นทางนี้ให้เหมาะสมสำหรับการจัดส่ง"** → อัลกอริทึมการปรับเส้นทาง

### กระบวนการประมวลผลข้อมูล
เชื่อมโยงการเรียกฟังก์ชันหลายครั้งเพื่อดำเนินการที่ซับซ้อน:
1. **ดึงข้อมูล** จากหลายแหล่ง
2. **แยกและตรวจสอบ** ข้อมูล
3. **แปลง** ข้อมูลเป็นรูปแบบที่ต้องการ
4. **จัดเก็บผลลัพธ์** ในระบบที่เหมาะสม
5. **สร้างรายงาน** หรือการแสดงผล

### การรวม UI/UX
เปิดใช้งานการอัปเดตอินเทอร์เฟซแบบไดนามิก:
- **"แสดงข้อมูลการขายบนแดชบอร์ด"** → การสร้างและแสดงแผนภูมิ
- **"อัปเดตแผนที่ด้วยตำแหน่งใหม่"** → การรวมข้อมูลภูมิศาสตร์
- **"รีเฟรชการแสดงสินค้าคงคลัง"** → การซิงโครไนซ์ข้อมูลแบบเรียลไทม์

## การตั้งค่า Function Calling ด้วย Phi-4-mini และ Ollama

Phi-4-mini ของ Microsoft รองรับการเรียกฟังก์ชันทั้งแบบเดี่ยวและแบบขนานผ่าน Ollama วิธีการตั้งค่ามีดังนี้:

### ข้อกำหนดเบื้องต้น
- Ollama เวอร์ชัน 0.5.13 หรือสูงกว่า
- โมเดล Phi-4-mini (แนะนำ: `phi4-mini:3.8b-fp16`)

### ขั้นตอนการติดตั้ง

#### 1. ติดตั้งและเรียกใช้ Phi-4-mini
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. สร้างเทมเพลต ModelFile แบบกำหนดเอง
เนื่องจากข้อจำกัดในเทมเพลตเริ่มต้นของ Ollama คุณต้องสร้าง ModelFile แบบกำหนดเองด้วยเทมเพลตดังนี้:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. สร้างโมเดลแบบกำหนดเอง
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### ตัวอย่างการเรียกฟังก์ชันแบบเดี่ยว

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### ตัวอย่างการเรียกฟังก์ชันแบบขนาน

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## การทำงานกับ Qwen3 Function Calling

Qwen3 มีความสามารถในการเรียกฟังก์ชันขั้นสูงที่มีประสิทธิภาพและความยืดหยุ่นสูง วิธีการใช้งานมีดังนี้:

### การใช้ Qwen-Agent Framework

Qwen-Agent มีเฟรมเวิร์กระดับสูงที่ช่วยให้การเรียกฟังก์ชันง่ายขึ้น:

#### การติดตั้ง
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### การตั้งค่าพื้นฐาน

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### การกำหนดฟังก์ชันแบบกำหนดเอง

คุณสามารถกำหนดฟังก์ชันแบบกำหนดเองสำหรับ Qwen3 ได้:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### ฟีเจอร์ขั้นสูงของ Qwen3

#### การควบคุม Thinking Mode
Qwen3 รองรับการสลับระหว่างโหมดคิดและไม่คิดแบบไดนามิก:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### การเรียกฟังก์ชันหลายขั้นตอน
Qwen3 มีความสามารถในการเชื่อมโยงการเรียกฟังก์ชันหลายครั้ง:

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## การรวม Foundry Local

Foundry Local ของ Microsoft มี API ที่เข้ากันได้กับ OpenAI สำหรับการรันโมเดลในเครื่องพร้อมความเป็นส่วนตัวและประสิทธิภาพที่เพิ่มขึ้น

### การตั้งค่าและการติดตั้ง

#### Windows
ดาวน์โหลดตัวติดตั้งจาก [หน้าปล่อย Foundry Local](https://github.com/microsoft/Foundry-Local/releases) และทำตามคำแนะนำการติดตั้ง

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### การใช้งานพื้นฐาน

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### ฟีเจอร์ขั้นสูงของ Foundry Local

#### การจัดการโมเดล
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### การปรับปรุงประสิทธิภาพ
Foundry Local เลือกตัวแปรโมเดลที่ดีที่สุดสำหรับฮาร์ดแวร์ของคุณโดยอัตโนมัติ:
- **CUDA GPU**: ดาวน์โหลดโมเดลที่ปรับให้เหมาะสมกับ GPU
- **Qualcomm NPU**: ใช้ตัวแปรที่เร่งด้วย NPU
- **CPU-only**: เลือกโมเดลที่ปรับให้เหมาะสมกับ CPU

## แนวทางปฏิบัติที่ดีที่สุดและการแก้ไขปัญหา

### แนวทางปฏิบัติที่ดีที่สุดในการกำหนดฟังก์ชัน

#### 1. การตั้งชื่อที่ชัดเจนและอธิบายได้
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. การกำหนดพารามิเตอร์ที่ครอบคลุม
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. การตรวจสอบข้อมูลเข้าและการจัดการข้อผิดพลาด
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### ปัญหาทั่วไปและวิธีแก้ไข

#### ปัญหา 1: ฟังก์ชันไม่ได้ถูกเรียกใช้
**อาการ**: โมเดลตอบกลับด้วยข้อความแทนที่จะเรียกฟังก์ชัน

**วิธีแก้ไข**:
1. **ตรวจสอบคำอธิบายฟังก์ชัน**: ตรวจสอบให้แน่ใจว่าตรงกับเจตนาของผู้ใช้อย่างชัดเจน
2. **ตรวจสอบการกำหนดพารามิเตอร์**: ตรวจสอบให้แน่ใจว่าพารามิเตอร์ที่จำเป็นทั้งหมดถูกกำหนดไว้อย่างถูกต้อง
3. **ตรวจสอบข้อความระบบ**: รวมคำแนะนำที่ชัดเจนเกี่ยวกับเวลาที่ควรใช้ฟังก์ชัน
4. **ทดสอบด้วยคำขอที่ชัดเจน**: ลอง "กรุณาใช้ฟังก์ชันพยากรณ์อากาศเพื่อรับข้อมูลสำหรับลอนดอน"

#### ปัญหา 2: พารามิเตอร์ไม่ถูกต้อง
**อาการ**: ฟังก์ชันถูกเรียกใช้ด้วยพารามิเตอร์ที่ผิดหรือขาดหายไป

**วิธีแก้ไข**:
1. **เพิ่มตัวอย่างพารามิเตอร์**: รวมค่าตัวอย่างในคำอธิบายพารามิเตอร์
2. **ใช้ข้อจำกัด enum**: จำกัดค่าพารามิเตอร์ให้เป็นตัวเลือกเฉพาะเมื่อเป็นไปได้
3. **กำหนดค่าตกหล่น**: ให้ค่าดีฟอลต์ที่เหมาะสมสำหรับพารามิเตอร์ที่ไม่จำเป็น

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### ปัญหา 3: การเรียกฟังก์ชันแบบขนานล้มเหลว
**อาการ**: มีเพียงฟังก์ชันเดียวที่ดำเนินการเมื่อควรดำเนินการหลายฟังก์ชัน

**วิธีแก้ไข**:
1. **ตรวจสอบการรองรับโมเดล**: ตรวจสอบให้แน่ใจว่าโมเดลของคุณรองรับการเรียกฟังก์ชันแบบขนาน
2. **อัปเดตข้อความระบบ**: รวม "เครื่องมือบางอย่าง" หรือ "เครื่องมือหลายตัว" ในข้อความระบบ
3. **ใช้เวอร์ชันโมเดลที่เหมาะสม**: แนะนำ Phi-4-mini:3.8b-fp16 สำหรับ Ollama

#### ปัญหา 4: ปัญหาเทมเพลตกับ Ollama
**อาการ**: การเรียกฟังก์ชันไม่ทำงานกับการตั้งค่าเริ่มต้นของ Ollama

**วิธีแก้ไข**:
1. **ใช้ ModelFile แบบกำหนดเอง**: ใช้เทมเพลตที่แก้ไขแล้วที่ให้ไว้ในบทแนะนำนี้
2. **อัปเดต Ollama**: ตรวจสอบให้แน่ใจว่าคุณใช้เวอร์ชัน 0.5.13 หรือสูงกว่า
3. **ตรวจสอบการควอนไทซ์โมเดล**: ระดับการควอนไทซ์ที่สูงขึ้น (Q8_0, fp16) ทำงานได้ดีกว่ารุ่นที่ถูกควอนไทซ์มาก

### การปรับปรุงประสิทธิภาพ

#### 1. การออกแบบฟังก์ชันที่มีประสิทธิภาพ
- **ทำให้ฟังก์ชันมีเป้าหมายชัดเจน**: ฟังก์ชันแต่ละตัวควรมีวัตถุประสงค์เดียวที่ชัดเจน
- **ลดการพึ่งพาภายนอก**: ลดการเรียก API และคำขอเครือข่ายเมื่อเป็นไปได้
- **แคชผลลัพธ์**: เก็บข้อมูลที่ถูกเรียกบ่อยเพื่อปรับปรุงเวลาในการตอบสนอง

#### 2. การจัดการงานแบบกลุ่มและแบบอะซิงโครนัส
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. การจัดการทรัพยากร
- **การใช้การเชื่อมต่อซ้ำ**: ใช้การเชื่อมต่อฐานข้อมูลและ API ซ้ำ
- **การจำกัดอัตรา**: ใช้การจำกัดอัตราที่เหมาะสมสำหรับ APIs ภายนอก
- **การจัดการการหมดเวลา**: ตั้งค่าการหมดเวลาที่เหมาะสมสำหรับการเรียกภายนอกทั้งหมด

## ตัวอย่างขั้นสูง

### ระบบการทำงานร่วมกันของหลายตัวแทน

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### ระบบการเลือกเครื่องมือแบบไดนามิก

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```python
import asyncio
import json
from typing import Dict, List, Any
from dataclasses import dataclass
from datetime import datetime

@dataclass
class FunctionResult:
    """รูปแบบผลลัพธ์มาตรฐานสำหรับการเรียกฟังก์ชันทั้งหมด"""
    success: bool
    data: Any = None
    error: str = None
    execution_time: float = 0.0
    timestamp: datetime = None

class EnterpriseAIAgent:
    """ตัวแทน AI ที่พร้อมใช้งานในระดับองค์กรพร้อมความสามารถในการเรียกฟังก์ชันที่ครอบคลุม"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.functions = {}
        self.audit_log = []
        self.rate_limiters = {}
        
        # เริ่มต้นฟังก์ชันธุรกิจหลัก
        self._register_core_functions()
    
    def _register_core_functions(self):
        """ลงทะเบียนฟังก์ชันธุรกิจที่มีอยู่ทั้งหมด"""
        
        # ฟังก์ชัน CRM
        self.register_function(
            name="get_customer_info",
            description="ดึงข้อมูลลูกค้าจาก CRM",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "include_history": {"type": "boolean", "default": False}
            },
            handler=self._get_customer_info,
            rate_limit=100  # การเรียกต่อนาที
        )
        
        # ฟังก์ชันการขาย
        self.register_function(
            name="create_sales_opportunity",
            description="สร้างโอกาสการขายใหม่",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "product_id": {"type": "string", "required": True},
                "estimated_value": {"type": "number", "required": True},
                "expected_close_date": {"type": "string", "required": True}
            },
            handler=self._create_sales_opportunity,
            rate_limit=50
        )
        
        # ฟังก์ชันวิเคราะห์
        self.register_function(
            name="generate_sales_report",
            description="สร้างรายงานประสิทธิภาพการขาย",
            parameters={
                "period": {"type": "string", "enum": ["daily", "weekly", "monthly", "quarterly"]},
                "region": {"type": "string", "required": False},
                "product_category": {"type": "string", "required": False}
            },
            handler=self._generate_sales_report,
            rate_limit=10
        )
        
        # ฟังก์ชันการแจ้งเตือน
       
Could you please provide the markdown file content that needs to be translated?
"""ดำเนินการฟังก์ชันพร้อมการจัดการข้อผิดพลาดและการบันทึกอย่างครอบคลุม"""
start_time = datetime.now()

try:
    # ตรวจสอบว่าฟังก์ชันมีอยู่หรือไม่
    if function_name not in self.functions:
        return FunctionResult(
            success=False,
            error=f"ไม่พบฟังก์ชัน '{function_name}'",
            timestamp=start_time
        )
    
    # ตรวจสอบข้อจำกัดการเรียกใช้งาน
    if not self._check_rate_limit(function_name):
        return FunctionResult(
            success=False,
            error=f"เกินข้อจำกัดการเรียกใช้งานสำหรับฟังก์ชัน '{function_name}'",
            timestamp=start_time
        )
    
    # ตรวจสอบความถูกต้องของพารามิเตอร์
    validation_result = self._validate_parameters(function_name, parameters)
    if not validation_result.success:
        return validation_result
    
    # ดำเนินการฟังก์ชัน
    func_info = self.functions[function_name]
    handler = func_info['handler']
    
    if asyncio.iscoroutinefunction(handler):
        result_data = await handler(**parameters)
    else:
        result_data = handler(**parameters)
    
    execution_time = (datetime.now() - start_time).total_seconds()
    
    result = FunctionResult(
        success=True,
        data=result_data,
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # บันทึกการดำเนินการที่สำเร็จ
    self._log_function_call(function_name, parameters, result)
    
    return result
    
except Exception as e:
    execution_time = (datetime.now() - start_time).total_seconds()
    result = FunctionResult(
        success=False,
        error=str(e),
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # บันทึกการดำเนินการที่ล้มเหลว
    self._log_function_call(function_name, parameters, result)
    
    return result

def _check_rate_limit(self, function_name: str) -> bool:
    """ตรวจสอบว่าการเรียกใช้งานฟังก์ชันอยู่ภายใต้ข้อจำกัดหรือไม่"""
    func_info = self.functions[function_name]
    now = datetime.now()
    
    # รีเซ็ตตัวนับหากผ่านไปหนึ่งนาที
    if (now - func_info['last_reset']).seconds >= 60:
        func_info['call_count'] = 0
        func_info['last_reset'] = now
    
    # ตรวจสอบว่าต่ำกว่าข้อจำกัดหรือไม่
    if func_info['call_count'] >= func_info['rate_limit']:
        return False
    
    func_info['call_count'] += 1
    return True

def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
    """ตรวจสอบความถูกต้องของพารามิเตอร์ฟังก์ชัน"""
    func_params = self.functions[function_name]['parameters']
    
    # ตรวจสอบพารามิเตอร์ที่จำเป็น
    for param_name, param_info in func_params.items():
        if param_info.get('required', False) and param_name not in parameters:
            return FunctionResult(
                success=False,
                error=f"พารามิเตอร์ที่จำเป็นหายไป: {param_name}"
            )
    
    # ตรวจสอบประเภทและข้อจำกัดของพารามิเตอร์
    for param_name, value in parameters.items():
        if param_name in func_params:
            param_info = func_params[param_name]
            
            # การตรวจสอบประเภท
            expected_type = param_info.get('type')
            if expected_type == 'string' and not isinstance(value, str):
                return FunctionResult(
                    success=False,
                    error=f"พารามิเตอร์ '{param_name}' ต้องเป็น string"
                )
            elif expected_type == 'number' and not isinstance(value, (int, float)):
                return FunctionResult(
                    success=False,
                    error=f"พารามิเตอร์ '{param_name}' ต้องเป็น number"
                )
            elif expected_type == 'boolean' and not isinstance(value, bool):
                return FunctionResult(
                    success=False,
                    error=f"พารามิเตอร์ '{param_name}' ต้องเป็น boolean"
                )
            
            # การตรวจสอบค่า enum
            if 'enum' in param_info and value not in param_info['enum']:
                return FunctionResult(
                    success=False,
                    error=f"พารามิเตอร์ '{param_name}' ต้องเป็นหนึ่งใน: {param_info['enum']}"
                )
    
    return FunctionResult(success=True)

def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):
    """บันทึกการเรียกใช้งานฟังก์ชันเพื่อการตรวจสอบ"""
    log_entry = {
        'timestamp': result.timestamp.isoformat(),
        'function_name': function_name,
        'parameters': parameters,
        'success': result.success,
        'execution_time': result.execution_time,
        'error': result.error if not result.success else None
    }
    
    self.audit_log.append(log_entry)
    
    # เขียนไปยังระบบบันทึกภายนอกหากเปิดใช้งาน
    if self.config.get('enable_external_logging', False):
        self._write_to_external_log(log_entry)

def _write_to_external_log(self, log_entry: Dict):
    """เขียนรายการบันทึกไปยังระบบบันทึกภายนอก"""
    # การดำเนินการขึ้นอยู่กับโครงสร้างพื้นฐานการบันทึกของคุณ
    # เช่น ส่งไปยัง ELK stack, CloudWatch เป็นต้น
    pass

# การดำเนินการฟังก์ชันทางธุรกิจ
async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
    """ดึงข้อมูลลูกค้าจากระบบ CRM"""
    # จำลองการเรียกฐานข้อมูล/API
    await asyncio.sleep(0.1)  # จำลองความล่าช้าเครือข่าย
    
    customer_data = {
        'customer_id': customer_id,
        'name': 'John Doe',
        'email': 'john.doe@example.com',
        'phone': '+1-555-0123',
        'status': 'active',
        'tier': 'premium'
    }
    
    if include_history:
        customer_data['purchase_history'] = [
            {'date': '2024-01-15', 'product': 'Product A', 'amount': 1500},
            {'date': '2024-03-22', 'product': 'Product B', 'amount': 2300}
        ]
    
    return customer_data

async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                  estimated_value: float, expected_close_date: str) -> Dict:
    """สร้างโอกาสการขายใหม่"""
    # จำลองการเรียก API CRM
    await asyncio.sleep(0.2)
    
    opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'opportunity_id': opportunity_id,
        'customer_id': customer_id,
        'product_id': product_id,
        'estimated_value': estimated_value,
        'expected_close_date': expected_close_date,
        'status': 'open',
        'created_date': datetime.now().isoformat()
    }

async def _generate_sales_report(self, period: str, region: str = None, 
                               product_category: str = None) -> Dict:
    """สร้างรายงานการขายที่ครอบคลุม"""
    # จำลองการรวบรวมข้อมูล
    await asyncio.sleep(0.5)
    
    return {
        'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
        'period': period,
        'region': region,
        'product_category': product_category,
        'total_sales': 125000.00,
        'total_opportunities': 45,
        'conversion_rate': 0.67,
        'top_products': [
            {'product_id': 'PROD-001', 'sales': 45000},
            {'product_id': 'PROD-002', 'sales': 32000}
        ],
        'generated_at': datetime.now().isoformat()
    }

async def _send_notification(self, recipients: List[str], message: str, 
                           priority: str = 'medium', channel: str = 'email') -> Dict:
    """ส่งการแจ้งเตือนผ่านช่องทางที่กำหนด"""
    # จำลองการเรียกบริการแจ้งเตือน
    await asyncio.sleep(0.1)
    
    notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'notification_id': notification_id,
        'recipients': recipients,
        'channel': channel,
        'priority': priority,
        'status': 'sent',
        'sent_at': datetime.now().isoformat()
    }

def get_function_definitions(self) -> List[Dict]:
    """รับคำจำกัดความของฟังก์ชันที่เข้ากันได้กับ OpenAI สำหรับฟังก์ชันที่ลงทะเบียนทั้งหมด"""
    definitions = []
    
    for func_name, func_info in self.functions.items():
        definition = {
            'name': func_name,
            'description': func_info['description'],
            'parameters': {
                'type': 'object',
                'properties': {},
                'required': []
            }
        }
        
        for param_name, param_info in func_info['parameters'].items():
            definition['parameters']['properties'][param_name] = {
                'type': param_info['type'],
                'description': param_info.get('description', '')
            }
            
            if 'enum' in param_info:
                definition['parameters']['properties'][param_name]['enum'] = param_info['enum']
            
            if 'default' in param_info:
                definition['parameters']['properties'][param_name]['default'] = param_info['default']
            
            if param_info.get('required', False):
                definition['parameters']['required'].append(param_name)
        
        definitions.append(definition)
    
    return definitions

# ตัวอย่างการใช้งานสำหรับการบูรณาการในองค์กร
async def enterprise_demo():
    """แสดงความสามารถของตัวแทน AI ในองค์กร"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # ตัวอย่างที่ 1: การประมวลผลคำถามลูกค้า
    print("=== การประมวลผลคำถามลูกค้า ===")
    
    # ดึงข้อมูลลูกค้า
    result = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    if result.success:
        print(f"ดึงข้อมูลลูกค้า: {result.data['name']}")
        print(f"เวลาที่ใช้ในการดำเนินการ: {result.execution_time:.3f}s")
    
    # ตัวอย่างที่ 2: การสร้างโอกาสการขาย
    print("\n=== การสร้างโอกาสการขาย ===")
    
    result = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    if result.success:
        print(f"สร้างโอกาสการขาย: {result.data['opportunity_id']}")
    
    # ตัวอย่างที่ 3: การดำเนินการแบบกลุ่ม
    print("\n=== การดำเนินการแบบกลุ่ม ===")
    
    tasks = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': 'สร้างโอกาสใหม่',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    results = await asyncio.gather(*tasks)
    
    for i, result in enumerate(results):
        if result.success:
            print(f"งานที่ {i+1} สำเร็จ")
        else:
            print(f"งานที่ {i+1} ล้มเหลว: {result.error}")
    
    # แสดงบันทึกการตรวจสอบ
    print(f"\n=== บันทึกการตรวจสอบ ({len(agent.audit_log)} รายการ) ===")
    for entry in agent.audit_log[-3:]:  # แสดง 3 รายการล่าสุด
        print(f"{entry['timestamp']}: {entry['function_name']} - {'สำเร็จ' if entry['success'] else 'ล้มเหลว'}")

# เรียกใช้งาน enterprise demo
# asyncio.run(enterprise_demo())

## สรุป

การเรียกใช้งานฟังก์ชันใน Small Language Models เป็นการเปลี่ยนแปลงจากผู้ช่วย AI แบบคงที่ไปสู่ตัวแทนที่มีความสามารถในการโต้ตอบกับโลกจริง บทเรียนนี้ครอบคลุม:

### ประเด็นสำคัญ

1. **ความเข้าใจพื้นฐาน**: การเรียกใช้งานฟังก์ชันช่วยให้ SLMs ขยายขอบเขตเกินกว่าข้อมูลการฝึกอบรมโดยการเชื่อมต่อกับเครื่องมือและบริการภายนอก

2. **ความยืดหยุ่นในการดำเนินการ**: มีหลายวิธีในการดำเนินการ ตั้งแต่การใช้งานระดับต่ำด้วยเทมเพลตที่กำหนดเองไปจนถึงเฟรมเวิร์กระดับสูง เช่น Qwen-Agent และ Foundry Local

3. **ข้อควรพิจารณาในการใช้งานจริง**: การใช้งานในองค์กรต้องให้ความสำคัญกับการจัดการข้อผิดพลาด ข้อจำกัดการเรียกใช้งาน ความปลอดภัย และการบันทึกการตรวจสอบ

4. **การปรับปรุงประสิทธิภาพ**: การออกแบบฟังก์ชันที่เหมาะสม การดำเนินการที่มีประสิทธิภาพ และการแคชที่ชาญฉลาดสามารถปรับปรุงเวลาตอบสนองได้อย่างมาก

### ทิศทางในอนาคต

เมื่อเทคโนโลยี SLMs พัฒนาไปเรื่อย ๆ เราสามารถคาดหวัง:

- **ความแม่นยำในการเรียกใช้งานฟังก์ชันที่ดีขึ้น**: การตรวจจับเจตนาและการดึงพารามิเตอร์ที่ดีขึ้น
- **การประมวลผลแบบขนานที่ดีขึ้น**: การจัดการฟังก์ชันหลายตัวที่ซับซ้อนมากขึ้น
- **มาตรฐานการบูรณาการที่ดีขึ้น**: โปรโตคอลที่เป็นมาตรฐานสำหรับการบูรณาการเครื่องมือ
- **คุณสมบัติด้านความปลอดภัยขั้นสูง**: การตรวจสอบสิทธิ์และการอนุญาตที่ดีขึ้น
- **ระบบนิเวศที่ขยายตัว**: ไลบรารีฟังก์ชันและการบูรณาการที่เติบโตขึ้น

### เริ่มต้นใช้งาน

เพื่อเริ่มต้นการใช้งานฟังก์ชันในโครงการของคุณ:

1. **เริ่มต้นง่าย ๆ**: เริ่มต้นด้วยสถานการณ์ฟังก์ชันเดียวที่ง่าย
2. **เลือกเฟรมเวิร์คของคุณ**: เลือกระหว่างการใช้งานโดยตรง (Ollama/Phi-4) หรือการช่วยเหลือโดยเฟรมเวิร์ค (Qwen-Agent)
3. **ออกแบบฟังก์ชันอย่างรอบคอบ**: เน้นคำจำกัดความของฟังก์ชันที่ชัดเจนและมีเอกสารประกอบ
4. **ดำเนินการจัดการข้อผิดพลาด**: สร้างการจัดการข้อผิดพลาดที่แข็งแกร่งตั้งแต่เริ่มต้น
5. **ขยายขนาดอย่างค่อยเป็นค่อยไป**: ย้ายจากสถานการณ์ง่ายไปสู่สถานการณ์ที่ซับซ้อนเมื่อคุณมีประสบการณ์มากขึ้น

การเรียกใช้งานฟังก์ชันเปลี่ยน SLMs จากเครื่องมือสร้างข้อความที่น่าประทับใจไปสู่ตัวแทน AI ที่ใช้งานได้จริงซึ่งสามารถแก้ปัญหาในโลกจริงได้ โดยการปฏิบัติตามรูปแบบและแนวทางปฏิบัติที่ระบุในบทเรียนนี้ คุณสามารถสร้างระบบ AI ที่ทรงพลังและเชื่อถือได้ซึ่งขยายเกินกว่าการสนทนาแบบดั้งเดิม

### แหล่งข้อมูลและอ้างอิง
- **Phi-4 Models**: [Hugging Face Collection](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)
- **Qwen3 Documentation**: [Official Qwen Documentation](https://qwen.readthedocs.io/)
- **Ollama**: [Official Website](https://ollama.com/)
- **Foundry Local**: [GitHub Repository](https://github.com/microsoft/Foundry-Local)
- **Function Calling Best Practices**: [Hugging Face Guide](https://huggingface.co/docs/hugs/en/guides/function-calling)

โปรดจำไว้ว่า การเรียกใช้งานฟังก์ชันเป็นสาขาที่มีการพัฒนาอย่างต่อเนื่อง การติดตามความก้าวหน้าล่าสุดในเฟรมเวิร์กและโมเดลที่คุณเลือกใช้จะช่วยให้คุณสร้างตัวแทน AI ที่มีประสิทธิภาพมากขึ้น


## ➡️ สิ่งที่ต้องทำต่อไป

- [03: การรวม Model Context Protocol (MCP)](./03.IntroduceMCP.md)

---

**ข้อจำกัดความรับผิดชอบ**:  
เอกสารนี้ได้รับการแปลโดยใช้บริการแปลภาษา AI [Co-op Translator](https://github.com/Azure/co-op-translator) แม้ว่าเราจะพยายามให้การแปลมีความถูกต้องมากที่สุด แต่โปรดทราบว่าการแปลโดยอัตโนมัติอาจมีข้อผิดพลาดหรือความไม่ถูกต้อง เอกสารต้นฉบับในภาษาดั้งเดิมควรถือเป็นแหล่งข้อมูลที่เชื่อถือได้ สำหรับข้อมูลที่สำคัญ ขอแนะนำให้ใช้บริการแปลภาษามืออาชีพ เราไม่รับผิดชอบต่อความเข้าใจผิดหรือการตีความที่ผิดพลาดซึ่งเกิดจากการใช้การแปลนี้