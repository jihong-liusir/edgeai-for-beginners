<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-09-18T14:12:03+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "id"
}
-->
# Section02 : Pemanggilan Fungsi dalam Small Language Models (SLMs)

## Daftar Isi
1. [Apa itu Pemanggilan Fungsi?](../../../Module06)
2. [Bagaimana Pemanggilan Fungsi Bekerja](../../../Module06)
3. [Skenario Aplikasi](../../../Module06)
4. [Mengatur Pemanggilan Fungsi dengan Phi-4-mini dan Ollama](../../../Module06)
5. [Bekerja dengan Pemanggilan Fungsi Qwen3](../../../Module06)
6. [Integrasi Lokal Foundry](../../../Module06)
7. [Praktik Terbaik dan Pemecahan Masalah](../../../Module06)
8. [Contoh Lanjutan](../../../Module06)

## Apa itu Pemanggilan Fungsi?

Pemanggilan fungsi adalah kemampuan yang memungkinkan Small Language Models (SLMs) berinteraksi dengan alat eksternal, API, dan layanan. Dengan fitur ini, SLM tidak lagi terbatas pada data pelatihannya, tetapi dapat:

- **Terhubung ke API eksternal** (layanan cuaca, basis data, mesin pencari)
- **Menjalankan fungsi tertentu** berdasarkan permintaan pengguna
- **Mengambil informasi real-time** dari berbagai sumber
- **Melakukan tugas komputasi** melalui alat khusus
- **Menggabungkan beberapa operasi** untuk alur kerja yang kompleks

Kemampuan ini mengubah SLM dari generator teks statis menjadi agen AI dinamis yang dapat melakukan tugas dunia nyata.

## Bagaimana Pemanggilan Fungsi Bekerja

Proses pemanggilan fungsi mengikuti alur kerja yang sistematis:

### 1. Integrasi Alat
- **Alat Eksternal**: SLM dapat terhubung ke API cuaca, basis data, layanan web, dan sistem eksternal lainnya
- **Definisi Fungsi**: Setiap alat didefinisikan dengan parameter spesifik, format input/output, dan deskripsi
- **Kompatibilitas API**: Alat diintegrasikan melalui antarmuka standar (REST API, SDK, dll.)

### 2. Definisi Fungsi
Fungsi didefinisikan dengan tiga komponen utama:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. Deteksi Intent
- **Pemrosesan Bahasa Alami**: SLM menganalisis input pengguna untuk memahami maksud
- **Pencocokan Fungsi**: Menentukan fungsi mana yang diperlukan untuk memenuhi permintaan
- **Ekstraksi Parameter**: Mengidentifikasi dan mengekstrak parameter yang diperlukan dari pesan pengguna

### 4. Pembuatan Output JSON
SLM menghasilkan JSON terstruktur yang berisi:
- Nama fungsi yang akan dipanggil
- Parameter yang diperlukan dengan nilai yang sesuai
- Konteks eksekusi dan metadata

### 5. Eksekusi Eksternal
- **Validasi Parameter**: Memastikan semua parameter yang diperlukan ada dan diformat dengan benar
- **Eksekusi Fungsi**: Aplikasi menjalankan fungsi yang ditentukan dengan parameter yang diberikan
- **Penanganan Kesalahan**: Mengelola kegagalan, waktu habis, dan respons yang tidak valid

### 6. Integrasi Respons
- **Pemrosesan Hasil**: Output fungsi dikembalikan ke SLM
- **Integrasi Konteks**: SLM menggabungkan hasil ke dalam responsnya
- **Komunikasi dengan Pengguna**: Menyajikan informasi dalam format percakapan yang alami

## Skenario Aplikasi

### Pengambilan Data
Mengubah kueri bahasa alami menjadi panggilan API terstruktur:
- **"Tampilkan pesanan saya yang terbaru"** → Kueri basis data dengan ID pengguna dan filter tanggal
- **"Bagaimana cuaca di Tokyo?"** → Panggilan API cuaca dengan parameter lokasi
- **"Cari email dari John minggu lalu"** → Kueri layanan email dengan pengirim dan filter tanggal

### Eksekusi Operasi
Mengubah permintaan pengguna menjadi panggilan fungsi tertentu:
- **"Jadwalkan rapat untuk besok pukul 2 siang"** → Integrasi API kalender
- **"Kirim pesan ke tim"** → API platform komunikasi
- **"Buat cadangan file saya"** → Operasi sistem file

### Tugas Komputasi
Menangani operasi matematis atau logis yang kompleks:
- **"Hitung bunga majemuk dari $10,000 dengan 5% selama 10 tahun"** → Fungsi kalkulasi keuangan
- **"Analisis dataset ini untuk tren"** → Alat analisis statistik
- **"Optimalkan rute ini untuk pengiriman"** → Algoritma optimasi rute

### Alur Kerja Pemrosesan Data
Menggabungkan beberapa panggilan fungsi untuk operasi kompleks:
1. **Mengambil data** dari berbagai sumber
2. **Memparsing dan memvalidasi** informasi
3. **Mengubah** data ke format yang diperlukan
4. **Menyimpan hasil** di sistem yang sesuai
5. **Menghasilkan laporan** atau visualisasi

### Integrasi UI/UX
Memungkinkan pembaruan antarmuka yang dinamis:
- **"Tampilkan data penjualan di dasbor"** → Pembuatan dan tampilan grafik
- **"Perbarui peta dengan lokasi baru"** → Integrasi data geospasial
- **"Segarkan tampilan inventaris"** → Sinkronisasi data real-time

## Mengatur Pemanggilan Fungsi dengan Phi-4-mini dan Ollama

Phi-4-mini dari Microsoft mendukung pemanggilan fungsi tunggal dan paralel melalui Ollama. Berikut cara mengaturnya:

### Prasyarat
- Ollama versi 0.5.13 atau lebih tinggi
- Model Phi-4-mini (direkomendasikan: `phi4-mini:3.8b-fp16`)

### Langkah Instalasi

#### 1. Instal dan Jalankan Phi-4-mini
```bash
# Download the model (if not already present)
ollama run phi4-mini:3.8b-fp16

# Verify the model is available
ollama list
```

#### 2. Buat Template ModelFile Kustom
Karena keterbatasan template default Ollama saat ini, Anda perlu membuat ModelFile kustom dengan template berikut:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. Buat Model Kustom
```bash
# Save the template above as 'Modelfile' and run:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### Contoh Pemanggilan Fungsi Tunggal

```python
import json
import requests

# Define the tool/function
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# Create the message with system prompt including tools
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# Make request to Ollama API
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### Contoh Pemanggilan Fungsi Paralel

```python
import json
import requests

# Define multiple tools for parallel execution
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# The model will generate parallel function calls
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## Bekerja dengan Pemanggilan Fungsi Qwen3

Qwen3 menawarkan kemampuan pemanggilan fungsi yang canggih dengan kinerja dan fleksibilitas yang luar biasa. Berikut cara mengimplementasikannya:

### Menggunakan Kerangka Qwen-Agent

Qwen-Agent menyediakan kerangka tingkat tinggi yang menyederhanakan implementasi pemanggilan fungsi:

#### Instalasi
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### Pengaturan Dasar

```python
import os
from qwen_agent.agents import Assistant

# Configure the LLM
llm_cfg = {
    'model': 'Qwen3-8B',
    # Option 1: Use Alibaba Model Studio
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # Option 2: Use local deployment
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'EMPTY',
    
    # Optional configuration for thinking mode
    'generate_cfg': {
        'thought_in_content': True,  # Include reasoning in response
    }
}

# Define tools using MCP (Model Context Protocol)
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # Built-in code execution tool
]

# Create the assistant
bot = Assistant(llm=llm_cfg, function_list=tools)

# Example usage
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# Generate response with function calling
for response in bot.run(messages=messages):
    print(response)
```

### Implementasi Fungsi Kustom

Anda juga dapat mendefinisikan fungsi kustom untuk Qwen3:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # Simulate weather API call
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# Use the custom tool
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### Fitur Lanjutan Qwen3

#### Kontrol Mode Berpikir
Qwen3 mendukung pengalihan dinamis antara mode berpikir dan non-berpikir:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### Pemanggilan Fungsi Multi-langkah
Qwen3 unggul dalam menggabungkan beberapa panggilan fungsi:

```python
# Complex workflow example
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 will automatically determine the sequence of function calls needed
```

## Integrasi Lokal Foundry

Foundry Local dari Microsoft menyediakan API yang kompatibel dengan OpenAI untuk menjalankan model secara lokal dengan privasi dan kinerja yang lebih baik.

### Pengaturan dan Instalasi

#### Windows
Unduh installer dari [halaman rilis Foundry Local](https://github.com/microsoft/Foundry-Local/releases) dan ikuti instruksi instalasi.

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### Penggunaan Dasar

```python
import openai
from foundry_local import FoundryLocalManager

# Initialize with model alias
alias = "phi-3.5-mini"  # Or any supported model
manager = FoundryLocalManager(alias)

# Create OpenAI client pointing to local endpoint
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# Define functions for the model
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# Make function calling request
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### Fitur Lanjutan Foundry Local

#### Manajemen Model
```bash
# List available models
foundry model list

# Download specific model
foundry model download phi-3.5-mini

# Run model interactively
foundry model run phi-3.5-mini

# Remove model from cache
foundry model remove phi-3.5-mini

# Delete all cached models
foundry model remove "*"
```

#### Optimasi Kinerja
Foundry Local secara otomatis memilih varian model terbaik untuk perangkat keras Anda:
- **CUDA GPU**: Mengunduh model yang dioptimalkan untuk GPU
- **Qualcomm NPU**: Menggunakan varian yang dipercepat NPU
- **CPU-only**: Memilih model yang dioptimalkan untuk CPU

## Praktik Terbaik dan Pemecahan Masalah

### Praktik Terbaik Definisi Fungsi

#### 1. Penamaan yang Jelas dan Deskriptif
```python
# Good
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# Avoid
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. Definisi Parameter yang Komprehensif
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. Validasi Input dan Penanganan Kesalahan
```python
def execute_function(function_name, parameters):
    try:
        # Validate required parameters
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # Validate email format
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # Execute function logic
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### Masalah Umum dan Solusinya

#### Masalah 1: Fungsi Tidak Dipanggil
**Gejala**: Model merespons dengan teks alih-alih memanggil fungsi

**Solusi**:
1. **Periksa deskripsi fungsi**: Pastikan deskripsi sesuai dengan maksud pengguna
2. **Verifikasi definisi parameter**: Pastikan semua parameter yang diperlukan didefinisikan dengan benar
3. **Tinjau prompt sistem**: Sertakan instruksi yang jelas tentang kapan menggunakan fungsi
4. **Uji dengan permintaan eksplisit**: Coba "Gunakan fungsi cuaca untuk mendapatkan data di London"

#### Masalah 2: Parameter Tidak Tepat
**Gejala**: Fungsi dipanggil dengan parameter yang salah atau hilang

**Solusi**:
1. **Tambahkan contoh parameter**: Sertakan nilai contoh dalam deskripsi parameter
2. **Gunakan batasan enum**: Batasi nilai parameter ke opsi tertentu jika memungkinkan
3. **Implementasikan nilai cadangan**: Berikan nilai default yang masuk akal untuk parameter opsional

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### Masalah 3: Kegagalan Pemanggilan Fungsi Paralel
**Gejala**: Hanya satu fungsi yang dijalankan ketika beberapa fungsi seharusnya dijalankan

**Solusi**:
1. **Periksa dukungan model**: Pastikan model Anda mendukung pemanggilan fungsi paralel
2. **Perbarui prompt sistem**: Sertakan "beberapa alat" atau "alat ganda" dalam pesan sistem
3. **Gunakan versi model yang sesuai**: Phi-4-mini:3.8b-fp16 direkomendasikan untuk Ollama

#### Masalah 4: Masalah Template dengan Ollama
**Gejala**: Pemanggilan fungsi tidak berfungsi dengan pengaturan Ollama default

**Solusi**:
1. **Gunakan ModelFile kustom**: Terapkan template yang diperbaiki yang disediakan dalam tutorial ini
2. **Perbarui Ollama**: Pastikan Anda menggunakan versi 0.5.13 atau lebih tinggi
3. **Periksa kuantisasi model**: Tingkat kuantisasi yang lebih tinggi (Q8_0, fp16) bekerja lebih baik daripada versi yang sangat terkuantisasi

### Optimasi Kinerja

#### 1. Desain Fungsi yang Efisien
- **Fokus fungsi**: Setiap fungsi harus memiliki tujuan yang jelas dan tunggal
- **Minimalkan ketergantungan eksternal**: Kurangi panggilan API dan permintaan jaringan jika memungkinkan
- **Cache hasil**: Simpan data yang sering diminta untuk meningkatkan waktu respons

#### 2. Operasi Batch dan Async
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. Manajemen Sumber Daya
- **Pooling koneksi**: Gunakan kembali koneksi basis data dan API
- **Pembatasan kecepatan**: Terapkan pembatasan kecepatan yang tepat untuk API eksternal
- **Penanganan waktu habis**: Tetapkan waktu habis yang wajar untuk semua panggilan eksternal

## Contoh Lanjutan

### Sistem Kolaborasi Multi-Agent

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # Research Agent
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # Analysis Agent
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # Communication Agent
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # Implement actual email sending logic
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # Implement actual Slack API call
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # Step 1: Research phase
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # Step 2: Analysis phase
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # Step 3: Communication phase
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# Usage example
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# Run the example
# asyncio.run(main())
```

### Sistem Pemilihan Alat Dinamis

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # Add more tool definitions as needed
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # Simple evaluation for demo - in production, use a proper math parser
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# Usage example
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # Analyze which tools might be needed
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # Get function definitions for the LLM
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # In a real implementation, you would pass these to your LLM
        # The LLM would then decide which functions to call and with what parameters

### Enterprise Integration Example

```
Sure! Please provide the markdown file you'd like me to translate.
"""Menjalankan fungsi dengan penanganan kesalahan dan pencatatan yang komprehensif"""
start_time = datetime.now()

try:
    # Validasi apakah fungsi tersedia
    if function_name not in self.functions:
        return FunctionResult(
            success=False,
            error=f"Fungsi '{function_name}' tidak ditemukan",
            timestamp=start_time
        )
    
    # Periksa batas penggunaan
    if not self._check_rate_limit(function_name):
        return FunctionResult(
            success=False,
            error=f"Batas penggunaan terlampaui untuk fungsi '{function_name}'",
            timestamp=start_time
        )
    
    # Validasi parameter
    validation_result = self._validate_parameters(function_name, parameters)
    if not validation_result.success:
        return validation_result
    
    # Jalankan fungsi
    func_info = self.functions[function_name]
    handler = func_info['handler']
    
    if asyncio.iscoroutinefunction(handler):
        result_data = await handler(**parameters)
    else:
        result_data = handler(**parameters)
    
    execution_time = (datetime.now() - start_time).total_seconds()
    
    result = FunctionResult(
        success=True,
        data=result_data,
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Catat eksekusi yang berhasil
    self._log_function_call(function_name, parameters, result)
    
    return result
    
except Exception as e:
    execution_time = (datetime.now() - start_time).total_seconds()
    result = FunctionResult(
        success=False,
        error=str(e),
        execution_time=execution_time,
        timestamp=start_time
    )
    
    # Catat eksekusi yang gagal
    self._log_function_call(function_name, parameters, result)
    
    return result

def _check_rate_limit(self, function_name: str) -> bool:
    """Periksa apakah panggilan fungsi masih dalam batas penggunaan"""
    func_info = self.functions[function_name]
    now = datetime.now()
    
    # Reset penghitung jika satu menit telah berlalu
    if (now - func_info['last_reset']).seconds >= 60:
        func_info['call_count'] = 0
        func_info['last_reset'] = now
    
    # Periksa apakah masih dalam batas
    if func_info['call_count'] >= func_info['rate_limit']:
        return False
    
    func_info['call_count'] += 1
    return True

def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
    """Validasi parameter fungsi"""
    func_params = self.functions[function_name]['parameters']
    
    # Periksa parameter yang wajib
    for param_name, param_info in func_params.items():
        if param_info.get('required', False) and param_name not in parameters:
            return FunctionResult(
                success=False,
                error=f"Parameter wajib tidak ditemukan: {param_name}"
            )
    
    # Validasi tipe dan batasan parameter
    for param_name, value in parameters.items():
        if param_name in func_params:
            param_info = func_params[param_name]
            
            # Validasi tipe
            expected_type = param_info.get('type')
            if expected_type == 'string' and not isinstance(value, str):
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' harus berupa string"
                )
            elif expected_type == 'number' and not isinstance(value, (int, float)):
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' harus berupa angka"
                )
            elif expected_type == 'boolean' and not isinstance(value, bool):
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' harus berupa boolean"
                )
            
            # Validasi nilai enum
            if 'enum' in param_info and value not in param_info['enum']:
                return FunctionResult(
                    success=False,
                    error=f"Parameter '{param_name}' harus salah satu dari: {param_info['enum']}"
                )
    
    return FunctionResult(success=True)

def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):
    """Catat panggilan fungsi untuk tujuan audit"""
    log_entry = {
        'timestamp': result.timestamp.isoformat(),
        'function_name': function_name,
        'parameters': parameters,
        'success': result.success,
        'execution_time': result.execution_time,
        'error': result.error if not result.success else None
    }
    
    self.audit_log.append(log_entry)
    
    # Opsional: tulis ke sistem pencatatan eksternal
    if self.config.get('enable_external_logging', False):
        self._write_to_external_log(log_entry)

def _write_to_external_log(self, log_entry: Dict):
    """Tulis entri log ke sistem pencatatan eksternal"""
    # Implementasi tergantung pada infrastruktur pencatatan Anda
    # Misalnya, kirim ke ELK stack, CloudWatch, dll.
    pass

# Implementasi Fungsi Bisnis
async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
    """Ambil informasi pelanggan dari sistem CRM"""
    # Simulasikan panggilan database/API
    await asyncio.sleep(0.1)  # Simulasikan penundaan jaringan
    
    customer_data = {
        'customer_id': customer_id,
        'name': 'John Doe',
        'email': 'john.doe@example.com',
        'phone': '+1-555-0123',
        'status': 'active',
        'tier': 'premium'
    }
    
    if include_history:
        customer_data['purchase_history'] = [
            {'date': '2024-01-15', 'product': 'Product A', 'amount': 1500},
            {'date': '2024-03-22', 'product': 'Product B', 'amount': 2300}
        ]
    
    return customer_data

async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                  estimated_value: float, expected_close_date: str) -> Dict:
    """Buat peluang penjualan baru"""
    # Simulasikan panggilan API CRM
    await asyncio.sleep(0.2)
    
    opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'opportunity_id': opportunity_id,
        'customer_id': customer_id,
        'product_id': product_id,
        'estimated_value': estimated_value,
        'expected_close_date': expected_close_date,
        'status': 'open',
        'created_date': datetime.now().isoformat()
    }

async def _generate_sales_report(self, period: str, region: str = None, 
                               product_category: str = None) -> Dict:
    """Buat laporan penjualan yang komprehensif"""
    # Simulasikan agregasi data
    await asyncio.sleep(0.5)
    
    return {
        'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
        'period': period,
        'region': region,
        'product_category': product_category,
        'total_sales': 125000.00,
        'total_opportunities': 45,
        'conversion_rate': 0.67,
        'top_products': [
            {'product_id': 'PROD-001', 'sales': 45000},
            {'product_id': 'PROD-002', 'sales': 32000}
        ],
        'generated_at': datetime.now().isoformat()
    }

async def _send_notification(self, recipients: List[str], message: str, 
                           priority: str = 'medium', channel: str = 'email') -> Dict:
    """Kirim notifikasi melalui saluran yang ditentukan"""
    # Simulasikan panggilan layanan notifikasi
    await asyncio.sleep(0.1)
    
    notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    return {
        'notification_id': notification_id,
        'recipients': recipients,
        'channel': channel,
        'priority': priority,
        'status': 'sent',
        'sent_at': datetime.now().isoformat()
    }

def get_function_definitions(self) -> List[Dict]:
    """Dapatkan definisi fungsi yang kompatibel dengan OpenAI untuk semua fungsi yang terdaftar"""
    definitions = []
    
    for func_name, func_info in self.functions.items():
        definition = {
            'name': func_name,
            'description': func_info['description'],
            'parameters': {
                'type': 'object',
                'properties': {},
                'required': []
            }
        }
        
        for param_name, param_info in func_info['parameters'].items():
            definition['parameters']['properties'][param_name] = {
                'type': param_info['type'],
                'description': param_info.get('description', '')
            }
            
            if 'enum' in param_info:
                definition['parameters']['properties'][param_name]['enum'] = param_info['enum']
            
            if 'default' in param_info:
                definition['parameters']['properties'][param_name]['default'] = param_info['default']
            
            if param_info.get('required', False):
                definition['parameters']['required'].append(param_name)
        
        definitions.append(definition)
    
    return definitions

# Contoh Penggunaan untuk Integrasi Perusahaan
async def enterprise_demo():
    """Demonstrasikan kemampuan agen AI perusahaan"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # Contoh 1: Pemrosesan pertanyaan pelanggan
    print("=== Pemrosesan Pertanyaan Pelanggan ===")
    
    # Ambil informasi pelanggan
    result = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    if result.success:
        print(f"Informasi Pelanggan Diperoleh: {result.data['name']}")
        print(f"Waktu Eksekusi: {result.execution_time:.3f}s")
    
    # Contoh 2: Pembuatan peluang penjualan
    print("\n=== Pembuatan Peluang Penjualan ===")
    
    result = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    if result.success:
        print(f"Peluang Dibuat: {result.data['opportunity_id']}")
    
    # Contoh 3: Operasi batch
    print("\n=== Operasi Batch ===")
    
    tasks = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': 'Peluang baru telah dibuat',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    results = await asyncio.gather(*tasks)
    
    for i, result in enumerate(results):
        if result.success:
            print(f"Tugas {i+1} selesai dengan sukses")
        else:
            print(f"Tugas {i+1} gagal: {result.error}")
    
    # Tampilkan log audit
    print(f"\n=== Log Audit ({len(agent.audit_log)} entri) ===")
    for entry in agent.audit_log[-3:]:  # Tampilkan 3 entri terakhir
        print(f"{entry['timestamp']}: {entry['function_name']} - {'BERHASIL' if entry['success'] else 'GAGAL'}")

# Jalankan demo perusahaan
# asyncio.run(enterprise_demo())

## Kesimpulan

Pemanggilan fungsi dalam Small Language Models (SLM) mewakili perubahan paradigma dari asisten AI statis menjadi agen dinamis yang mampu berinteraksi dengan dunia nyata. Tutorial ini telah mencakup:

### Poin Penting

1. **Pemahaman Dasar**: Pemanggilan fungsi memungkinkan SLM untuk melampaui data pelatihannya dengan terhubung ke alat dan layanan eksternal.

2. **Fleksibilitas Implementasi**: Terdapat berbagai pendekatan, mulai dari implementasi tingkat rendah dengan template khusus hingga kerangka kerja tingkat tinggi seperti Qwen-Agent dan Foundry Local.

3. **Pertimbangan Produksi**: Implementasi di tingkat perusahaan memerlukan perhatian pada penanganan kesalahan, batas penggunaan, keamanan, dan pencatatan audit.

4. **Optimasi Performa**: Desain fungsi yang tepat, eksekusi yang efisien, dan caching yang cerdas dapat meningkatkan waktu respons secara signifikan.

### Arah Masa Depan

Seiring perkembangan teknologi SLM, kita dapat mengharapkan:

- **Akurasi Pemanggilan Fungsi yang Lebih Baik**: Deteksi niat dan ekstraksi parameter yang lebih baik
- **Pemrosesan Paralel yang Lebih Canggih**: Orkestrasi multi-fungsi yang lebih kompleks
- **Standar Integrasi yang Lebih Baik**: Protokol yang terstandarisasi untuk integrasi alat
- **Fitur Keamanan yang Lebih Maju**: Mekanisme autentikasi dan otorisasi yang lebih baik
- **Ekosistem yang Berkembang**: Perpustakaan fungsi dan integrasi yang terus bertambah

### Langkah Awal

Untuk mulai mengimplementasikan pemanggilan fungsi dalam proyek Anda:

1. **Mulai Sederhana**: Mulailah dengan skenario fungsi tunggal yang sederhana
2. **Pilih Kerangka Kerja Anda**: Pilih antara implementasi langsung (Ollama/Phi-4) atau berbasis kerangka kerja (Qwen-Agent)
3. **Desain Fungsi dengan Cermat**: Fokus pada definisi fungsi yang jelas dan terdokumentasi dengan baik
4. **Implementasi Penanganan Kesalahan**: Bangun penanganan kesalahan yang kuat sejak awal
5. **Skalakan Secara Bertahap**: Beralih dari skenario sederhana ke kompleks seiring bertambahnya pengalaman

Pemanggilan fungsi mengubah SLM dari generator teks yang mengesankan menjadi agen AI praktis yang mampu menyelesaikan masalah dunia nyata. Dengan mengikuti pola dan praktik yang dijelaskan dalam tutorial ini, Anda dapat membangun sistem AI yang kuat dan andal yang melampaui antarmuka obrolan tradisional.

### Sumber Daya dan Referensi
- **Model Phi-4**: [Koleksi Hugging Face](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)
- **Dokumentasi Qwen3**: [Dokumentasi Resmi Qwen](https://qwen.readthedocs.io/)
- **Ollama**: [Situs Resmi](https://ollama.com/)
- **Foundry Local**: [Repositori GitHub](https://github.com/microsoft/Foundry-Local)
- **Praktik Terbaik Pemanggilan Fungsi**: [Panduan Hugging Face](https://huggingface.co/docs/hugs/en/guides/function-calling)

Ingatlah bahwa pemanggilan fungsi adalah bidang yang terus berkembang, dan tetap mengikuti perkembangan terbaru dalam kerangka kerja dan model yang Anda pilih akan membantu Anda membangun agen AI yang lebih efektif.


## ➡️ Langkah Selanjutnya

- [03: Integrasi Protokol Konteks Model (MCP)](./03.IntroduceMCP.md)

---

**Penafian**:  
Dokumen ini telah diterjemahkan menggunakan layanan penerjemahan AI [Co-op Translator](https://github.com/Azure/co-op-translator). Meskipun kami berusaha untuk memberikan hasil yang akurat, harap diingat bahwa terjemahan otomatis mungkin mengandung kesalahan atau ketidakakuratan. Dokumen asli dalam bahasa aslinya harus dianggap sebagai sumber yang otoritatif. Untuk informasi yang bersifat kritis, disarankan menggunakan jasa penerjemahan manusia profesional. Kami tidak bertanggung jawab atas kesalahpahaman atau penafsiran yang keliru yang timbul dari penggunaan terjemahan ini.