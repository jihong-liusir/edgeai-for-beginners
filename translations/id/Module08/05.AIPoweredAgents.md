<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "382a763fcea7087e68a94c26216e5e70",
  "translation_date": "2025-09-22T22:36:13+00:00",
  "source_file": "Module08/05.AIPoweredAgents.md",
  "language_code": "id"
}
-->
# Sesi 5: Bangun Agen Berbasis AI dengan Cepat menggunakan Foundry Local

Catatan: Kemampuan agen di Foundry Local terus berkembangâ€”pastikan dukungan dalam catatan rilis terbaru sebelum menerapkan pola lanjutan.

## Ikhtisar

Gunakan Foundry Local untuk membuat prototipe aplikasi berbasis agen dengan cepat: sistem prompt, grounding, dan pola orkestrasi. Ketika dukungan agen tersedia, Anda dapat menggunakan pemanggilan fungsi yang kompatibel dengan OpenAI atau memanfaatkan Azure AI Agents di sisi cloud dalam desain hybrid.

Referensi:
- Dokumentasi Foundry Local: https://learn.microsoft.com/en-us/azure/ai-foundry/foundry-local/
- Azure AI Foundry Agents: https://learn.microsoft.com/en-us/azure/ai-services/agents/overview
- Contoh pemanggilan fungsi (Foundry Local samples): https://github.com/microsoft/Foundry-Local/tree/main/samples/python/functioncalling

## Tujuan Pembelajaran
- Merancang sistem prompt dan strategi grounding untuk perilaku yang dapat diandalkan
- Menerapkan pola pemanggilan fungsi (penggunaan alat)
- Mengorkestrasi alur kerja multi-agen (lokal dan hybrid)
- Merencanakan observabilitas dan keamanan

## Bagian 1: Sistem Prompt dan Grounding

- Tentukan peran, batasan, dan skema output yang ketat
- Dasarkan respons pada data lokal atau data perusahaan
- Terapkan output JSON untuk otomatisasi lanjutan

## Bagian 2: Pemanggilan Fungsi (Kompatibel dengan OpenAI)

```python
# tools.py
import json

def get_weather(city: str) -> str:
    return f"Weather in {city}: Sunny, 25C"

FUNCTIONS = [
    {
        "name": "get_weather",
        "description": "Get current weather for a city",
        "parameters": {
            "type": "object",
            "properties": {
                "city": {"type": "string", "description": "City name"}
            },
            "required": ["city"]
        }
    }
]
```

```python
# agent.py
import requests
import json
from tools import FUNCTIONS, get_weather

BASE_URL = "http://localhost:8000"
MODEL = "phi-4-mini"

SYSTEM_PROMPT = "You are a helpful assistant. Use tools when needed."

def call_model(messages, functions=None):
    payload = {
        "model": MODEL,
        "messages": messages,
        "functions": functions,
        "function_call": "auto"
    }
    r = requests.post(f"{BASE_URL}/v1/chat/completions", json=payload, timeout=60)
    r.raise_for_status()
    return r.json()

messages = [{"role": "system", "content": SYSTEM_PROMPT},
            {"role": "user", "content": "What's the weather in Paris?"}]

resp = call_model(messages, functions=FUNCTIONS)
choice = resp["choices"][0]["message"]

if "function_call" in choice:
    fc = choice["function_call"]
    if fc["name"] == "get_weather":
        args = json.loads(fc["arguments"])
        result = get_weather(args["city"])
        messages.append(choice)
        messages.append({"role": "function", "name": "get_weather", "content": result})
        final = call_model(messages)
        print(final["choices"][0]["message"]["content"]) 
else:
    print(choice.get("content"))
```

Jalankan:
```powershell
# Ensure a model is running
foundry model run phi-4-mini
python agent.py
```


## Bagian 3: Orkestrasi Multi-Agen (Pola)

Rancang koordinator yang mengarahkan tugas ke agen spesialis (retrieval, reasoning, execution) menggunakan endpoint yang kompatibel dengan OpenAI dari Foundry Local.

Langkah 1) Tentukan agen spesialis
```python
# agents/specialists.py
import requests
BASE_URL = "http://localhost:8000"
MODEL = "phi-4-mini"

headers = {"Content-Type": "application/json", "Authorization": "Bearer local-key"}

def chat(messages, max_tokens=300, temperature=0.4):
    r = requests.post(f"{BASE_URL}/v1/chat/completions", json={
        "model": MODEL,
        "messages": messages,
        "max_tokens": max_tokens,
        "temperature": temperature
    }, headers=headers, timeout=60)
    r.raise_for_status()
    return r.json()["choices"][0]["message"]["content"]

class RetrievalAgent:
    SYSTEM = "You retrieve relevant snippets from knowledge sources based on a query."
    def run(self, query: str) -> str:
        # Placeholder: in real use, fetch from local files or vector DB
        messages = [{"role": "system", "content": self.SYSTEM},
                    {"role": "user", "content": f"Retrieve key facts for: {query}"}]
        return chat(messages)

class ReasoningAgent:
    SYSTEM = "You analyze inputs step by step and produce structured conclusions."
    def run(self, context: str, question: str) -> str:
        messages = [
            {"role": "system", "content": self.SYSTEM},
            {"role": "user", "content": f"Context:\n{context}\n\nQuestion: {question}\nThink step-by-step and produce a concise answer."}
        ]
        return chat(messages)

class ExecutionAgent:
    SYSTEM = "You transform decisions into actionable steps (JSON with actions)."
    def run(self, decision: str) -> str:
        messages = [
            {"role": "system", "content": self.SYSTEM},
            {"role": "user", "content": f"Turn this decision into 3 executable steps as JSON:\n{decision}"}
        ]
        return chat(messages)
```

Langkah 2) Bangun koordinator
```python
# agents/coordinator.py
from agents.specialists import RetrievalAgent, ReasoningAgent, ExecutionAgent

class Coordinator:
    def __init__(self):
        self.retrieval = RetrievalAgent()
        self.reasoning = ReasoningAgent()
        self.execution = ExecutionAgent()

    def handle(self, user_goal: str) -> dict:
        # 1. Retrieve context
        context = self.retrieval.run(user_goal)
        # 2. Reason on context
        decision = self.reasoning.run(context, user_goal)
        # 3. Produce actionable steps
        actions = self.execution.run(decision)
        return {
            "goal": user_goal,
            "context": context,
            "decision": decision,
            "actions": actions
        }

if __name__ == "__main__":
    # Ensure: foundry model run phi-4-mini
    coord = Coordinator()
    result = coord.handle("Create a plan to onboard 5 new customers this month")
    print(result)
```

Langkah 3) Validasi terhadap Foundry Local
```powershell
REM Confirm the local endpoint and model are available
foundry model list
foundry model run phi-4-mini
curl http://localhost:8000/v1/models

REM Run the coordinator
python -m samples.05.agents.coordinator
```


Panduan:
- Terapkan retry dan timeout antar agen
- Tambahkan penyimpanan kecil dalam memori (dict) untuk status percakapan/thread
- Perkenalkan pembatasan kecepatan saat menghubungkan beberapa panggilan

## Bagian 4: Observabilitas dan Keamanan

Lacak prompt, respons, dan kesalahan secara lokal, sambil menerapkan kebersihan data dalam stack agen Anda.

Langkah 1) Logging permintaan ringan (opsional)

Catatan: Helper berikut tidak disertakan secara default. Buat `infra/obs.py` jika Anda ingin logging JSON lokal untuk eksperimen.
```python
# infra/obs.py
import time, json, os
from datetime import datetime

LOG_DIR = os.getenv("FOUNDRY_AGENT_LOG_DIR", "./agent_logs")
os.makedirs(LOG_DIR, exist_ok=True)

def log_event(kind: str, payload: dict):
    ts = datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
    path = os.path.join(LOG_DIR, f"{ts}_{kind}.json")
    with open(path, "w", encoding="utf-8") as f:
        json.dump(payload, f, ensure_ascii=False, indent=2)
```

Integrasikan logging ke dalam agen (opsional):
```python
# in agents/specialists.py after receiving content
from infra.obs import log_event
# ... inside chat(...)
resp = r.json()
log_event("chat_request", {"endpoint": f"{BASE_URL}/v1/chat/completions"})
log_event("chat_response", resp)
return resp["choices"][0]["message"]["content"]
```


Langkah 2) Validasi ketersediaan dan kesehatan dasar melalui CLI
```powershell
REM Ensure Foundry Local is running a model
foundry model list
foundry model run phi-4-mini

REM Validate the OpenAI-compatible endpoint
curl http://localhost:8000/v1/models
```


Langkah 3) Redaksi dan kebersihan PII
- Sebelum mengirim pesan ke model, hapus atau hash field sensitif (email, nomor telepon, ID)
- Simpan data sumber mentah di perangkat, hanya kirim string konteks yang diperlukan

Contoh helper redaksi:
```python
# infra/redact.py
import re
EMAIL_RE = re.compile(r"[\w\.-]+@[\w\.-]+")
PHONE_RE = re.compile(r"\+?\d[\d\s\-]{7,}\d")

def sanitize(text: str) -> str:
    text = EMAIL_RE.sub("[REDACTED_EMAIL]", text)
    text = PHONE_RE.sub("[REDACTED_PHONE]", text)
    return text
```

Gunakan dalam agen:
```python
from infra.redact import sanitize
# user_goal = sanitize(user_goal)
# context = sanitize(context)
```


Langkah 4) Circuit breakers dan penanganan kesalahan
- Bungkus setiap panggilan agen dengan try/except dan backoff eksponensial
- Hentikan pipeline pada kegagalan berulang

```python
import time

def with_retry(func, retries=3, base_delay=0.5):
    for i in range(retries):
        try:
            return func()
        except Exception as e:
            if i == retries - 1:
                raise
            time.sleep(base_delay * (2 ** i))
```


Langkah 5) Jejak audit lokal dan ekspor
- Simpan log JSON di bawah `./agent_logs`
- Secara berkala kompres dan rotasi log
- Ekspor ringkasan untuk tinjauan (jumlah, rata-rata latensi, tingkat kesalahan)

Langkah 6) Cross-check dengan dokumentasi Microsoft Learn
- Foundry Local menyediakan API yang kompatibel dengan OpenAI (divalidasi dengan `curl /v1/models`)
- Gunakan `foundry model run <name>` untuk memastikan ketersediaan model
- Ikuti panduan resmi untuk integrasi klien dan aplikasi contoh (Open WebUI/how-tos)

Referensi:
- Foundry Local (Learn): https://learn.microsoft.com/en-us/azure/ai-foundry/foundry-local/
- Open WebUI how-to: https://learn.microsoft.com/en-us/azure/ai-foundry/foundry-local/how-to/how-to-chat-application-with-open-web-ui
- Contoh pemanggilan fungsi: https://github.com/microsoft/Foundry-Local/tree/main/samples/python/functioncalling

## Langkah Selanjutnya
- Jelajahi Azure AI Agents untuk orkestrasi berbasis cloud
- Tambahkan konektor perusahaan (Microsoft Graph, Search, database)

---

